<html><head></head><body>
    <section>
      <header class="header-title chapter-title">
                    Image Processing with Nearest Neighbors
                </header>
      <article>
        <p>In this chapter and the following one, we are going to take a different approach. The nearest neighbors algorithm will take a supporting role here, while image processing will be the main protagonist of the chapter. We will start by loading images and we will use Python to represent them in a suitable format for the machine learning algorithms to work with. We will be using the nearest neighbors algorithm for classification and regression. We will also learn how to compress information in images into a smaller space. Many of the concepts explained here are transferable and can be used with other algorithms with slight tweaks. Later, in <a href="https://cdp.packtpub.com/hands_on_machine_learning_with_scikit_learn/wp-admin/post.php?post=33&amp;action=edit">Chapter 7</a>, <em>Neural</em><em>Networks - Here Comes the Deep Learning</em>, we will build on the knowledge acquired here and continue with image processing by using neural networks. In this chapter, we are going to cover the following topics:</p>
        <ul>
          <li>Nearest neighbors </li>
          <li>Loading and displaying images</li>
          <li>Image classification</li>
          <li>Using custom distances</li>
          <li>Using nearest neighbors for regression</li>
          <li>Reducing the dimensions of our image data</li>
        </ul>
        <h1 id="uuid-95719b93-008b-4416-a417-9ebf5b9705db" class="mce-root">Nearest neighbors</h1>
        <div class="mce-root packt_quote">"We learn by example and by direct experience because there are real limits to the adequacy of verbal instruction."</div>
        <div class="mce-root packt_quote CDPAlignRight CDPAlign">– <span class="authorOrTitle">Malcolm Gladwell</span></div>
        <p>It feels as if Malcolm Gladwell is explaining the K-nearest neighbors algorithm in the preceding quote; we only need to replace "<em>verbal instruction</em>" with "<em>mathematical equation</em>." In cases such as linear models, training data is used to learn a mathematical equation that models the data. Once a model is learned, we can easily put the training data aside. Here, in the nearest neighbors algorithm, the data itself is the model. Whenever we encounter a new data sample, we compare it to the training dataset. We locate the K-nearest samples in the training set to the newly encountered sample, and then we use the class labels of the K samples in the training set to assign a label to the new sample.</p>
        <p>A few things should be noted here:</p>
        <ul>
          <li>The concept of training doesn't really exist here. Unlike other algorithms, where the training time is dependent on the amount of training data, the computational cost is mostly spent in the nearest neighbors algorithm at prediction time. </li>
          <li>Most of the recent research done on the nearest neighbors algorithm is focused on finding the optimum ways to quickly search through the training data during prediction time. </li>
          <li>What does <em>nearest</em> mean? In this chapter, we will learn about the different distance measures used to compare different data points to each other. Two data points are deemed near to each other depending on the distance metric used.</li>
          <li>What is <em>K</em>? We can compare a new data point to 1, 2, 3, or 50 other samples in the training set. The number of samples we decide to compare to is <em>K</em>, and we are going to see how different values of <em>K</em> affect the behavior of the algorithms.</li>
        </ul>
        <p>Before using the nearest neighbors algorithm for image classification, we need to firstlearn how to deal with images. In the next section, we will load and display one of the most commonly used image datasets in the field of machine learning and image processing. </p>
        <div class="packt_infobox">When finding the nearest neighbors of a sample, you can compare it to all the other training samples. This is a naive brute-force approach that doesn't scale well with the size of the training data. A more efficient approach for larger datasets requires the training samples to be stored in a specific data structure that is optimized for search. K-D tree and ball tree are two available data structures. These two data structures are parameterized by <kbd>leaf_size</kbd>. As its value approaches the size of the training set, the K-D tree and ball tree turn into a brute-force search. Conversely, setting the leaf size to <kbd>1</kbd> introduces lots of overhead when traversing the trees. A default leaf size of <kbd>30</kbd> is good middle ground for many sample sizes.</div>
        <h1 id="uuid-5457a1d2-2ff0-4bdb-9d31-16b7877cbcb0">Loading and displaying images</h1>
        <div class="packt_quote">"Photographs are two-dimensional. I work in four dimensions." </div>
        <div class="packt_quote CDPAlignRight CDPAlign">– Tino Sehgal</div>
        <p>When asked about the number of dimensions that an image has, photographers, painters, illustrators, and almost everyone else on this planet will agree that images are two-dimensional objects. Only machine learning practitioners see images differently. For us, every pixel in a black and white image is a separate dimension. Dimensions expand even more with colored images, but that's something for later. We see each pixel as a separate dimension so that we can deal with each pixel and its value as a unique feature that defines the image, along with the other pixels (features). So, unlike<em/>Tino Sehgal, we can sometimes end up working with 4,000 dimensions. </p>
        <p>The <strong>ModifiedNational Institute</strong><strong>of </strong><strong>Standards</strong><strong>and </strong><strong>Technology</strong>(<strong>MNIST</strong>) dataset is a collection of handwritten digits that is commonly used inimage processing. Due to its popularity, it is included in <kbd>scikit-learn</kbd>, and we can load it as we usually do with other datasets:</p>
        <pre>from sklearn.datasets import load_digits<br/>digits = load_digits()</pre>
        <p class="mce-root">The dataset has digits from <kbd>0</kbd> to <kbd>9</kbd>. We can access their targets (labels) as follows:</p>
        <pre>digits['target']<br/># Output: array([0, 1, 2, ..., 8, 9, 8])</pre>
        <p>Similarly, we can load the pixel values, as follows:</p>
        <pre>digits['data']<br/># Output: <br/># array([[ 0., 0., 5., ..., 0., 0., 0.], <br/>#  [ 0., 0., 0., ..., 10., 0., 0.], <br/>#  ..., <br/>#  [ 0., 0., 2., ..., 12., 0., 0.], <br/>#  [ 0., 0., 10., ..., 12., 1., 0.]])</pre>
        <p>Each line is a picture and each integer is a pixel value. In this dataset, the pixels take values between <kbd>0</kbd> and <kbd>16</kbd>. The shape of the dataset (<kbd>digits['data'].shape</kbd>) is <em>1,797 x 64</em>. In other words, we have 1,797 square-shaped pictures, and each of them has 64 pixels (width = height = 8). </p>
        <p>Knowing this information, we can create the following function to display an image. It takes an array of 64 values and reshapes it into a two-dimensional array with 8 rows and 8 columns. It also uses the corresponding target of the image to show on top of the digit. The <kbd>matplotlib</kbd> axis (<kbd>ax</kbd>) is given so that we can display the image on it:</p>
        <pre>def display_img(img, target, ax):<br/>    img = img.reshape((8, 8))<br/>    ax.imshow(img, cmap='gray')<br/>    ax.set_title(f'Digit: {str(target)}')<br/>    ax.grid(False)</pre>
        <p>We can now use the function we just created to display the first eight digits of our dataset:</p>
        <pre>fig, axs = plt.subplots(1, 8, figsize=(15, 10))<br/><br/>for i in range(8):<br/>    display_img(digits['data'][i], digits['target'][i], axs[i])<br/><br/>fig.show()</pre>
        <p>The digits look as follows:</p>
        <p class="CDPAlignCenter CDPAlign">
          <img src="assets/a162711f-176a-4239-bc38-b37cc6ecee3f.png" style="width:59.33em;"/>
        </p>
        <p>Being able to display the digits is a good first step. Next, we need to convert them into our usual training and test formats. This time, we want to keep each image as one row, so there is no need to reshape it into <em>8 x 8</em> matrices:</p>
        <pre>from sklearn.model_selection import train_test_split<br/>x, y = digits['data'], digits['target']<br/>x_train, x_test, y_train, y_test = train_test_split(x, y)</pre>
        <p>At this point, the data is ready to be used with an image classification algorithm. By learning to predict the targets when given a bunch of pixels, we are already one step closer to making our computer understand the handwritten text. </p>
        <h1 id="uuid-f94b01a6-8917-461e-a101-66c5c4527d18">Image classification</h1>
        <p>Now that we have our data ready, we can predict the digits using the nearest neighbors classifier, as follows:</p>
        <pre>from sklearn.neighbors import KNeighborsClassifier<br/><br/>clf = KNeighborsClassifier(n_neighbors=11, metric='manhattan')<br/>clf.fit(x_train, y_train)<br/>y_test_pred = clf.predict(x_test)</pre>
        <p>For this example, I set <kbd>n_neighbors</kbd> to <kbd>11</kbd> and <kbd>metric</kbd> to <kbd>manhattan</kbd>, meaning at prediction time, we compare each new sample to the 11 nearest training samples, using the Manhattan distance to evaluate how near they are. More on these parameters in a bit. This model made predictions with an accuracy of 96.4% on the test set. This might sound reasonable, but I'm sorry to break it to you; this isn't a fantastic score for this particular dataset. Anyway, let's keep on dissecting the model's performance further. </p>
        <h2 id="uuid-7a5c695d-e82e-468c-95a7-063849069969">Using a confusion matrix to understand the model's mistakes</h2>
        <p>When dealing with a dataset with 10 class labels, a single accuracy score can only tell us so much. To better understand what digits were harder to guess than others, we can print the model's confusion matrix. This is a square matrix where the actual labels are shown as rows and the predicted labels are shown as columns. Then, the numbers in each cell show the testing instances that fell into it. Let me create it now, and it will become clearer in a moment. The <kbd>plot_confusion_matrix</kbd> function needs the classifier's instance, along with the test's <kbd>x</kbd> and <kbd>y</kbd> values, to display the matrix:</p>
        <pre>from sklearn.metrics import plot_confusion_matrix<br/>plot_confusion_matrix(clf, x_test, y_test, cmap='Greys')</pre>
        <p>Once called, the function runs the model internally on the test data and displays the following matrix:</p>
        <p class="CDPAlignCenter CDPAlign">
          <img src="assets/3cfef06e-3d56-4368-941f-b71cbb4f47a1.png" style="width:43.00em;"/>
        </p>
        <p>Ideally, all the cells should have zeros, except for the diagonal cells. Falling into a diagonal cell means that a sample is correctly labeled. However, there are only a few non-zero cells here. The four samples at the intersection of row 8 and column 1 signify that our model has classified four samples as <kbd>1</kbd>, while their actual label was <kbd>8</kbd>. Most likely, those were too-skinny eights that looked like ones to the algorithm. The same conclusions can be made for the remaining non-diagonal non-zero cells. </p>
        <h2 id="uuid-806de7f7-769e-4ff9-b381-ef2ac58d4ec8">Picking a suitable metric</h2>
        <p>The images we are using are just lists of numbers (vectors). The distance metric decides whether one image is close to another. This also applies to non-image data, where distance metrics are used to decide whether one sample is close to another. Two commonly used metrics are the <strong>M</strong><strong>anhattan</strong> and<strong>Euclidean</strong> distances:</p>
        <table style="border-collapse: collapse;width: 100%" border="1">
          <tbody>
            <tr>
              <td style="width: 10.4478%" class="CDPAlignCenter CDPAlign">
                <strong>Name</strong>
              </td>
              <td style="width: 39.5522%" class="CDPAlignCenter CDPAlign">
                <strong>Manhattan (L1 norm)</strong>
              </td>
              <td style="width: 40%" class="CDPAlignCenter">
                <strong>Euclidean (L2 norm)</strong>
              </td>
            </tr>
            <tr>
              <td style="width: 10.4478%" class="CDPAlignLeft CDPAlign">Formula</td>
              <td style="width: 39.5522%" class="CDPAlignCenter CDPAlign">
                <strong>
                  <img class="fm-editor-equation" src="assets/e2930e27-c687-4f0f-b3bc-18888a658497.png" style="width:15.92em;"/>
                </strong>
              </td>
              <td style="width: 40%" class="CDPAlignCenter CDPAlign">
                <strong>
                  <img class="fm-editor-equation" src="assets/d4b9a9b8-1441-4eb6-8865-032cdb4295a5.png" style="width:16.25em;"/>
                </strong>
              </td>
            </tr>
          </tbody>
        </table>
        <p><br/>
Most likely, the equation for the Manhattan distance will remind you of the mean absolute error and L1 regularization, while the Euclidean distance resembles the mean squared error and L2 regularization. This resemblance is a nice reminder of how many concepts stem from common ideas:</p>
        <p class="CDPAlignCenter CDPAlign">
          <img src="assets/0a526191-f4f1-42b4-acbb-be335c7273f7.png" style="width:12.00em;"/>
        </p>
        <p>For the <strong>M</strong><strong>anhattan</strong> distance, the distance between <span class="packt_screen">A</span> and <span class="packt_screen">C</span> is calculated by going from <span class="packt_screen">A</span> to <span class="packt_screen">D</span>, and then from <span class="packt_screen">D</span> to <span class="packt_screen">C</span>. It gets its name from Manhattan Island in New York, where its landscape is divided into blocks. For the <strong>Euclidean</strong> distance, the distance between <span class="packt_screen">A</span> and <span class="packt_screen">C</span> is calculated via the diagonal line between the two points. There is a generalized form for the two metrics, called the <strong>Minkowski</strong> distance, and here is its formula:</p>
        <p class="CDPAlignCenter CDPAlign">
          <img class="fm-editor-equation" src="assets/848895b2-14e8-47d2-97fb-6996b9c61839.png" style="width:16.67em;"/>
        </p>
        <p>Setting <kbd>p</kbd> to <kbd>1</kbd> gives us the Manhattan distance, and we can get the Euclidean distance by setting it to <kbd>2</kbd>. I am sure you can tell now where <kbd>1</kbd> and <kbd>2</kbd> in the L1 and L2 norms come from. To be able to compare the different values of <kbd>p</kbd>, we can run the following code. Here, we calculate the Minkowski distance for the two points—<kbd>(1, 2)</kbd> and <kbd>(4, 6)</kbd>—for different values of <kbd>p</kbd>:</p>
        <pre>from sklearn.neighbors import DistanceMetric<br/><br/>points = pd.DataFrame(<br/>    [[1, 2], [4, 6]], columns=['x1', 'x2']<br/>)<br/><br/>d = [<br/>  (p, DistanceMetric.get_metric('minkowski', p=p).pairwise(points)[0][-1])<br/>  for p in [1, 2, 10, 50, 100]<br/>]</pre>
        <p>Plotting the results shows us how the Minkowski distance changes with <kbd>p</kbd>:</p>
        <p class="CDPAlignCenter CDPAlign">
          <img src="assets/969974fd-d414-48a7-b0af-3afff2ebe68f.png" style="width:32.25em;"/>
        </p>
        <p>Clearly, the Minkowski distance decreases with an increase in <kbd>p</kbd>. For <kbd>p = 1</kbd>, the distance is <kbd>7</kbd>, <kbd>(4 - 1) + (6 - 2)</kbd>, and for <kbd>p = 2</kbd>, the distance is <kbd>5</kbd>, the square root of <kbd>(9 + 16)</kbd>. For higher values of <kbd>p</kbd>, the distance calculated approaches <kbd>4</kbd>, which is <kbd>(6 - 2)</kbd> only. In other words, as <kbd>p</kbd> approaches infinity, the distance is just the maximum of all the spans between the points on all the axes, which is known as the Chebyshev distance.</p>
        <div class="packt_infobox">The term <em>metric</em> is used to describe a distance measure that follows the following criteria:<br/><br/>
It cannot be negative: <img class="fm-editor-equation" src="assets/e1e821f0-1c45-4c76-9137-9850474e9a52.png" style="width:5.75em;height:1.25em;"/>, and it is symmetric: <img class="fm-editor-equation" src="assets/b98b8d27-e50e-4273-a005-ca7dbb7b1e35.png" style="width:9.33em;"/>.<br/>
The distance from one point to itself is 0. It follows the following triangle inequality criterion: <img class="fm-editor-equation" src="assets/73493af6-edf4-40b2-ad39-bf4f833fc034.png" style="width:14.75em;"/>.</div>
        <p>Another common metric is the <strong>cosine</strong> distance, and its formula is as follows:</p>
        <p class="CDPAlignCenter CDPAlign">
          <img class="fm-editor-equation" src="assets/d1e22299-fe13-4583-b408-d19e09b01940.png" style="width:17.33em;"/>
        </p>
        <p>Unlike the Euclidean distance, the cosine distance is scale-insensitive. I think it would be better to show the difference between the two metrics with the following example.</p>
        <p>Here, we take one digit and multiply each pixel value by <kbd>2</kbd>:</p>
        <p class="CDPAlignCenter CDPAlign">
          <img src="assets/d95898c9-60d8-4961-bc9a-db69578ee328.png" style="width:50.17em;"/>
        </p>
        <p>Now, let's calculate the distances between the original image and the intensified one:</p>
        <pre>from sklearn.metrics.pairwise import (<br/>    euclidean_distances, <br/>    manhattan_distances, <br/>    cosine_distances<br/>)<br/><br/>d0 = manhattan_distances(<br/> [1.0 * digits['data'][0], 2.0 * digits['data'][0]]<br/>)[0,1]<br/><br/>d1 = euclidean_distances(<br/> [1.0 * digits['data'][0], 2.0 * digits['data'][0]]<br/>)[0,1]<br/><br/>d2 = cosine_distances(<br/> [1.0 * digits['data'][0], 2.0 * digits['data'][0]]<br/>)[0,1]</pre>
        <p>Running the preceding code gives us the values for each distance—Manhattan = <kbd>294</kbd>, Euclidean = <kbd>55.41</kbd>, and cosine = <kbd>0</kbd>. As expected, the cosine distance does not care about the constant we used to multiply the pixels with, and it considers the two versions of the same images as one. The other two metrics, on the other hand, saw the two versions as further apart. </p>
        <h2 id="uuid-7ccf58d6-d0d7-4797-8448-effafaf0137d">Setting the correct K</h2>
        <p>Equally important to metric selection is knowing how many neighbors to listen to when making a decision. You don't want to ask too few neighbors as maybe they don't know enough. You also don't want to ask everyone as the very distant neighbors probably don't know much about the sample at hand. To put it formally, a decision made based on too few neighbors introduces variance since any slight changes in the data will result in different neighborhoods and different results. Conversely, a decision made based on too many neighbors is a biased decision as it is less sensitive to the differences between the neighborhoods. Keep this in mind. Here, I used the model with different settings for <em>K</em> and plotted the resulting accuracy:</p>
        <p class="CDPAlignCenter CDPAlign">
          <img src="assets/532bfe59-376d-4d7e-a533-4eb75efc66df.png" style="width:58.42em;"/>
        </p>
        <div class="packt_tip packt_infobox">The concept of bias-variance trade-off will follow us throughout this book. When it comes to picking sides, we usually opt to use a biased model when we have smaller training sets. A high-variance model will overfit if there isn't enough data to learn from. The most biased model is one where <em>K</em> is set to the number of training samples. Then, all the new data points will get the same prediction and will be assigned to the same label as the majority class. Conversely, when we have a good amount of data, the few closest neighbors within a smaller radius are a better choice to consult, as it's more likely that they will belong to the same class as our new sample. </div>
        <p>Now, we have two hyperparameters to set: the number of neighbors and the distance metrics. In the next section, we are going to use a grid search to find the optimum values for these parameters.</p>
        <h2 id="uuid-9e770878-b4e3-4777-98ab-3d6ba59a6f55">Hyperparameter tuning using GridSearchCV</h2>
        <p><kbd>GridSearchCV</kbd> is a method for looping over all the possible hyperparameter combinations and employing cross-validation to pick the optimum hyperparameters. For each hyperparameter combination, we do not want to limit ourselves to just one accuracy score. So, to get a better understanding of the estimator's accuracy of each combination, we make use of K-fold cross-validation. Then, the data is split into a number of folds, and for each iteration, all folds but one are used for training, and the remaining one is used for testing. This method for hyperparameter tuning performs an exhaustive search over all possible parameter combinations, hence the <kbd>Grid</kbd> prefix. In the following code, we give <kbd>GridSearchCV</kbd> a Python dictionary with all the parameter values we want to loop over, as well as the estimator we want to tune. We also specify the number of folds to split the data into, and then we call the grid search's <kbd>fit</kbd> method with the training data. Remember, it is bad practice to learn anything from the test dataset, which should be kept aside for now. Here is the code to do this:</p>
        <pre>from sklearn.model_selection import GridSearchCV<br/>from sklearn.neighbors import KNeighborsClassifier<br/><br/>parameters = {<br/>    'metric':('manhattan','euclidean', 'cosine'), <br/>    'n_neighbors': range(1, 21)<br/>}<br/><br/>knn = KNeighborsClassifier()<br/>gscv = GridSearchCV(knn, param_grid=parameters, scoring='accuracy')<br/><br/>gscv.fit(x_train, y_train)</pre>
        <p>Once done, we can show the best parameters found via <kbd>gscv.best_params_</kbd>. We can also show the accuracy achieved when using the chosen parameter via <kbd>gscv.best_score_</kbd>. Here, the <kbd>euclidean</kbd> distance was chosen as <kbd>metric</kbd> and <kbd>n_neighbors</kbd> was set to <kbd>3</kbd>. I also got an accuracy score of 98.7% when using the chosen hyperparameters. </p>
        <p>We can now use the resulting classifier to make predictions for the test set:</p>
        <pre>from sklearn.metrics import accuracy_score<br/><br/>y_test_pred = gscv.predict(x_test)<br/>accuracy_score(y_test, y_test_pred)</pre>
        <p class="mce-root">This gave me an accuracy of 98.0% on the test set. Luckily, the grid search helped us improve the accuracy of our estimator by picking the optimum hyperparameters.</p>
        <div class="mce-root packt_tip"><kbd>GridSearchCV</kbd> can become computationally expensive if we have too many hyperparameters to search through and too many values for each one. When facing a problem like this,<kbd>RandomizedSearchCV</kbd> may be an alternative solution since it randomly picks hyperparameter values while searching. Both hyperparameter tuning algorithms use the <kbd>accuracy</kbd> score by default for classifiers and <kbd>R</kbd><sup><kbd>2</kbd></sup>for regressors. We can override this and specify different metrics to pick the best configuration.<br/></div>
        <h1 id="uuid-afd46b3f-7739-4be8-b480-542f2e179b9e">Using custom distances</h1>
        <p>The digits here are written in white pixels over a black background. I don't think anyone would have a problem with identifying a digit if it was written in black pixels over a white background instead. As for a computer algorithm, things are a little different. Let's train our classifier as usual and see whether it will have any issues if the colors are inverted. We will start by training the algorithm on the original images:</p>
        <pre>clf = KNeighborsClassifier(n_neighbors=3, metric='euclidean')<br/>clf.fit(x_train, y_train)<br/>y_train_pred = clf.predict(x_train)</pre>
        <p>We then create an inverted version of the data we have just used for training:</p>
        <pre>x_train_inv = x_train.max() - x_train </pre>
        <p>The nearest neighbors implementation has a method called <kbd>kneighbors</kbd>. When given a sample, it returns a list of the K-nearest samples to it from the training set, as well as their distances from the given sample. We are going to give this method one of the inverted samples and see which samples it will consider as its neighbors:</p>
        <pre class="mce-root">img_inv = x_train_inv[0]<br/><br/>fig, axs = plt.subplots(1, 8, figsize=(14, 5))<br/><br/>display_img(img_inv, y_train[0], axs[0])<br/><br/>_, kneighbors_index_inv = clf.kneighbors(<br/>    [x_train_inv[0]], <br/>    n_neighbors=7, <br/>    return_distance=True<br/>)<br/><br/>for i, neighbor_index in enumerate(kneighbors_index_inv[0], 1):<br/>    display_img(<br/>        x_train[neighbor_index], <br/>        y_train[neighbor_index], <br/>        axs[i]<br/>    )</pre>
        <p>Just to make things clearer, I ran the code twice—once with the original sample and its seven neighbors, and once with the inverted sample and its neighbors. The output of the two runs is displayed here. As you can see, unlike us humans, the algorithm got totally confused by the adversarial example where the colors were inverted:</p>
        <p class="CDPAlignCenter CDPAlign">
          <img src="assets/2d65bf56-335e-41e9-b2c0-7d5f06cdca14.png" style="width:56.58em;"/>
        </p>
        <p>If you think about it, according to the distance we use, a sample and its inverted version cannot be too much further from each other. Although we visually see the two as one, the model sees them as different as day and night. Having that said, it is clear that we need to come up with a different way to evaluate distances. Since pixels take values between <kbd>0</kbd> and <kbd>16</kbd>, in an inverted sample, all of the 16s are turned into 0s, the 15s are turned into 1s, and so on. Therefore, a distance that compares samples in relation to how far their pixels are from the midpoint between <kbd>0</kbd> and <kbd>16</kbd> (<kbd>8</kbd>) can help us solve our problem here. Here is how to create this custom distance. Let's call our new distance <kbd>contrast_distance</kbd><em><strong>:</strong></em></p>
        <pre>from sklearn.metrics.pairwise import euclidean_distances<br/><br/>def contrast_distance(x1, x2):<br/>    _x1, _x2 = np.abs(8 - x1), np.abs(8 - x2)<br/>    d = euclidean_distances([_x1], [_x2])<br/>    return d[0][0]</pre>
        <p>Once defined, we can use the custom metric in our classifier, as follows:</p>
        <pre>clf = KNeighborsClassifier(n_neighbors=3, metric=contrast_distance)<br/>clf.fit(x_train, y_train)</pre>
        <p>After this tweak, the inversion doesn't bother the model anymore. For the original and the inverted sets, we get the exact same accuracy of 89.3%. We can also print the seven nearest neighbors according to the new metric to validate the fact that the new model is alreadysmarter and no longer discriminates against the black digits:</p>
        <p class="CDPAlignCenter CDPAlign">
          <img src="assets/0182aaa3-96f7-4660-8d3a-813ef9a4b70a.png" style="width:53.25em;"/>
        </p>
        <p>One thing to keep in mind when writing your own custom distances is that they are not as optimized as the built-in ones, and running the algorithm will be more computationally expensive at prediction time.  </p>
        <h1 id="uuid-256fb87a-50f8-458b-9714-1c5672901555">Using nearest neighbors for regression</h1>
        <p>At the end of the day, the targets we predict in the MNIST dataset are just numbers between 0 and 9. So, we can alternatively use a regressor algorithm for the same problem. In this case, our predictions will not be integers anymore, but rather floats. Training the regressor isn't much different from training the classifier:</p>
        <pre>from sklearn.neighbors import KNeighborsRegressor<br/>clf = KNeighborsRegressor(n_neighbors=3, metric='euclidean')<br/>clf.fit(x_train, y_train)<br/>y_test_pred = clf.predict(x_test)</pre>
        <p>Here are some of the incorrectly made predictions:</p>
        <p class="CDPAlignCenter CDPAlign">
          <img src="assets/0d85cc59-f732-415d-8c35-6edd0eb53706.png" style="width:13.17em;"/>
        </p>
        <p>The first item's three nearest neighbors are <kbd>3</kbd>, <kbd>3</kbd>, and <kbd>5</kbd>. So, the regressor used their mean (<kbd>3.67</kbd>) as the prediction. The second and third items' neighbors are <kbd>8, 9, 8</kbd> and <kbd>7, 9, 7</kbd>, respectively. Remember to round these predictions and convert them into integers if you want to use a classifier's evaluation metric to evaluate this model. </p>
        <h1 id="uuid-c84f5473-b735-46e5-a4a4-c83c7724450f">More neighborhood algorithms</h1>
        <p>There are other variations of K-nearest neighbors that I'd like to quickly go through before moving on to the next section. These algorithms are less commonly used, although they have their merits as well as certain disadvantages.</p>
        <h2 id="uuid-2b1cd7f4-b28c-4351-84e2-333a0f209f42">Radius neighbors </h2>
        <p>Contrary to the K-nearest neighbors algorithm, where a certain number of neighbors are allowed to vote, in radius neighbors, all the neighbors within a certain radius participate in the voting process. By setting a predefined radius, the decisions in sparser neighborhoods are based on fewer neighbors than the ones made in denser neighborhoods. This can be useful when dealing with imbalanced classes. Furthermore, by using the haversine formula as our metric, we can use this algorithm to recommend nearby venues or gas stations on a map to the users. Both radius neighbors and K-nearest neighbors can give closer data points more voting power than distant ones by specifying the algorithm's <kbd>weights</kbd> parameter. </p>
        <h2 id="uuid-018d83a3-0ed6-4d55-a85a-d2adc2f4d664">Nearest centroid classifier</h2>
        <p>As we have seen, the K-nearest neighbors algorithm compares the test samples to all of the samples in the training set. This exhaustive search causes the model to become slower at prediction time. To deal with this, the nearest centroid classifier summarizes all the training samples from each class into a pseudo-sample that represents this class. This pseudo-sample is called the centroid as it is typically created by calculating the mean value for each of the features in a class. At prediction time, a test sample is compared to all the centroids and is classified based on the class whose centroid is closest to it.</p>
        <p>In the next section, we are going to use the centroid algorithm for training and prediction, but for now, we are going to use it to generate new digits just for fun. The algorithm is trained as follows:</p>
        <pre>from sklearn.neighbors import NearestCentroid<br/>clf = NearestCentroid(metric='euclidean')<br/>clf.fit(x_train, y_train)</pre>
        <p>The learned centroids are stored in <kbd>centroids_</kbd>. The following code displays these centroids, along with the class labels: </p>
        <pre>fig, axs = plt.subplots(1, len(clf.classes_), figsize=(15, 5))<br/><br/>for i, (centroid, label) in enumerate(zip(clf.centroids_, clf.classes_)):<br/>    display_img(centroid, label, axs[i])<br/><br/>fig.show()</pre>
        <p>The generated digits are shown here:</p>
        <p class="CDPAlignCenter CDPAlign">
          <img src="assets/d40db71c-3169-4c18-8545-9756abdc83a6.png" style="width:52.75em;"/>
        </p>
        <p>These digits do not exist in our dataset. They are just combinations of all the samples in each class. </p>
        <div class="packt_infobox">The nearest centroid classifier is fairly simple, and I am sure you can implement it from scratch using a few lines of code. Its accuracy is not as good as nearest neighbors for the MNIST dataset, though. The centroid algorithm is more commonly used in natural language processing, where it's better known as Rocchio (pronounced like "we will rock you"). </div>
        <p>Finally, the centroid algorithm also has a hyperparameter called <kbd>shrink_threshold</kbd>. When set, this can help to remove the irrelevant features. </p>
        <h1 id="uuid-0d8f701b-a5dc-47ae-92e9-7308fa5718a5">Reducing the dimensions of our image data</h1>
        <p>Earlier, we realized that the dimensionality of an image is equal to the number of pixels in it. So, there is no way to visualize our 43-dimensional MNIST dataset. It is true that we can display each digit separately, yet we cannot see where each image falls in our feature space. This is important to understand the classifier's decision boundaries. Furthermore, an estimator's memory requirements grow in proportion to the number of features in the training data. As a result, we need a way to reduce the number of features in our data to deal with the aforementioned issues. </p>
        <p>In this section, we are going to discover two dimensionality-reduction algorithms: <strong>Principal Component Analysis</strong> (<strong>PCA</strong>) and <strong>Neighborhood Component Analysis</strong> (<strong>NCA</strong>). After explaining them, we will use them to visualize the MNIST dataset and generate additional samples to add to our training set. Finally, we will also use <strong>feature selection</strong> algorithms to remove non-informative pixels from our images.</p>
        <h2 id="uuid-7cf0e29e-3476-4c75-bde6-581de9e0e0c6">Principal component analysis</h2>
        <div class="packt_quote">"A good photograph is knowing where to stand."</div>
        <div class="packt_quote CDPAlignRight CDPAlign">–Ansel Adams</div>
        <p>Imagine having the following set of data with two features—<kbd>x1</kbd> and <kbd>x2</kbd>:</p>
        <p class="CDPAlignCenter CDPAlign">
          <img src="assets/f7abe53f-e78e-4b77-a1e6-36a96a374ec7.png" style="width:13.58em;"/>
        </p>
        <p>You can generate a previous data frame by using the following code snippet, keeping in mind that the numbers may vary on your machine, given their randomness:</p>
        <pre>df = pd.DataFrame(<br/>    {<br/>        'x1': np.random.normal(loc=10.0, scale=5.0, size=8),<br/>        'noise': np.random.normal(loc=0.0, scale=1.0, size=8),<br/>    }<br/>)<br/><br/>df['x2'] = 3 * df['x1'] + df['noise'] </pre>
        <p>When we plot the data, we realize that <kbd>x1</kbd> and <kbd>x2</kbd> take the following form:</p>
        <p class="CDPAlignCenter CDPAlign">
          <img src="assets/c3c020b0-d3cd-4f75-b10b-9f3e2fefdb78.png" style="width:42.33em;"/>
        </p>
        <p>If you want, you can tilt your head to the left. Now, imagine we did not have the <kbd>x1</kbd> and <kbd>x2</kbd> axes, but instead had one diagonal axis that goes through the data. Wouldn't that axis be enough to represent our data? Then, we would have reduced it from a two-dimensional dataset into a one-dimensional dataset. That's exactly what PCA tries to achieve.</p>
        <p>This new axis has one main characteristic—the distances between the points on it are more than their distances on the <kbd>x1</kbd> or <kbd>x2</kbd> axes. Remember, the hypotenuse of a triangle is always bigger than any of the two other sides. In conclusion, PCA tries to find a set of new axes (principal components) where the data variance is maximized. </p>
        <p>Just like in the case of the correlation coefficient equation discussed in <a href="https://cdp.packtpub.com/hands_on_machine_learning_with_scikit_learn/wp-admin/post.php?post=27&amp;action=edit">Chapter 4</a>,<em> Preparing Your Data</em>, PCA also needs the data to be centered. For each column, we subtract the mean of the column from each value in it. We can use the<kbd>with_std =False</kbd> standard scaler to achieve this. Here is how to calculate the PCA and convert our data into the new dimensions:</p>
        <pre>from sklearn.preprocessing import StandardScaler<br/>from sklearn.decomposition import PCA<br/><br/>scaler = StandardScaler(with_std=False)<br/>x = scaler.fit_transform(df[['x1', 'x2']])<br/><br/>pca = PCA(n_components=1)<br/>x_new = pca.fit_transform(x)</pre>
        <p class="mce-root">The resulting <kbd>x_new</kbd> value is a single column data frame instead of two. We can also access the newly created component via <kbd>pca.components_</kbd>. Here, I plotted the new component over the original data:</p>
        <p class="CDPAlignCenter CDPAlign">
          <img src="assets/fc219789-a691-4219-8947-664a480ba334.png" style="width:46.75em;"/>
        </p>
        <p>As you can see, we were able to use the PCA algorithm to reduce the number of features here from two to one. Since the dots don't fall exactly on the line, some information is lost by only using one component. This information is stored in the second component that we did not retrieve. You can transform your data into any number of components from one up to the original number of features. The components are ordered descendingly according to the amount of information they carry. Therefore, ignoring the latter components may help to remove any noisy and less-useful information. Aftertransforming the data, it can also be transformed back (inverse transformation). The resulting data after the two operations only matches the original data if all the components are retained; otherwise, we can limit ourselves to the first few (principal) components to denoise the data.  </p>
        <div class="packt_tip">In the PCA assumption, the directions in the feature space with the highest variance are expected to carry more information than the directions with lower variance. This assumption may hold in some cases, but it is not guaranteed to always be true. Remember that in PCA, the target is not used, only the features. This makes it more suitable for unlabeled data.  </div>
        <h2 id="uuid-378a99b6-f59f-4070-86cd-51a4caf47e6e">Neighborhood component analysis</h2>
        <p>In the nearest neighbors algorithms, the choice of the distance measure is paramount, yet it is only set empirically. We used K-fold cross-validation earlier in this chapter to decide which distance metric is better for our problem. This can be time-consuming, which triggers many researchers to look for better solutions. The main aim of NCA is to learn the distance metric from the data using gradient descend. The distances it tries to learn are usually represented by a square matrix. For <em>N</em> samples, we have <img class="fm-editor-equation" src="assets/73d8334b-b8ad-4011-9da8-370f39c173c7.png" style="width:3.25em;height:0.92em;"/> sample pairs to compare, hence the square matrix. Nevertheless, this matrix can be restricted to become a rectangular one, <img class="fm-editor-equation" src="assets/64dcd70b-19c0-4a61-bf66-5ed6bc1db006.png" style="width:3.08em;"/>, where the small <em>n</em> is a lower number than <em>N</em> and represents the reduced components. These reduced components are the building blocks of NCA.</p>
        <div class="packt_tip packt_infobox">The nearest neighbors algorithms belong to a class of learners called instance-based learners. We use instances of the training set to make decisions. So, the matrix that carries the distances between the instances is an essential part of it. This matrix inspired many researchers to do research on it. For example, learning the distances from data is what NCA and large-margin nearest neighbors do; other researchers converted this matrix into a higher dimensional space—for example, with the kernel trick—and others tried to embed feature selection into the instance-based learners via regularization.</div>
        <p>In the next section, we will visually compare the two dimensionality-reduction methods by using them to plot the MNIST dataset onto a two-dimensional graph. </p>
        <h2 id="uuid-0f0f5e89-07ca-4727-84d2-fc7507c5eba2">Comparing PCA to NCA</h2>
        <p>We will reduce the dimensionality of the data by projecting it into a smaller space. We will use <strong>PCA</strong> and <strong>NCA</strong> in addition to random projection. We will start by importing the required models and putting the three algorithms into a Python dictionary to loop over them later on:</p>
        <pre>from sklearn.preprocessing import StandardScaler<br/>from sklearn.random_projection import SparseRandomProjection<br/>from sklearn.decomposition import PCA<br/>from sklearn.neighbors import NeighborhoodComponentsAnalysis<br/><br/>methods = {<br/>    'Rand': SparseRandomProjection(n_components=2),<br/>    'PCA': PCA(n_components=2),<br/>    'NCA': NeighborhoodComponentsAnalysis(n_components=2, init='random'),<br/>}</pre>
        <p>Then, we will create three plots side by side for the three algorithms, as follows:</p>
        <pre>fig, axs = plt.subplots(1, 3, figsize=(15, 5))<br/><br/>for i, (method_name, method_obj) in enumerate(methods.items()):<br/><br/>    scaler = StandardScaler(with_std=False)<br/>    x_train_scaled = scaler.fit_transform(x_train)<br/><br/>    method_obj.fit(x_train_scaled, y_train)<br/>    x_train_2d = method_obj.transform(x_train_scaled)<br/><br/>    for target in set(y_train):<br/>        pd.DataFrame(<br/>            x_train_2d[<br/>                y_train == target<br/>            ], columns=['y', 'x']<br/>        ).sample(n=20).plot(<br/>            kind='scatter', x='x', y='y', <br/>            marker=f'${target}$', s=64, ax=axs[i]<br/>        )<br/>        axs[i].set_title(f'{method_name} MNIST')</pre>
        <p>It is important to center your data before applying PCA. We used <kbd>StandardScaler</kbd> to do this. Other algorithms shouldn't mind the centering, anyway. Running the code gives us the following graphs:</p>
        <p class="CDPAlignCenter CDPAlign">
          <img src="assets/9930f6ed-2feb-47eb-87a5-b66b9d94f28d.png" style="width:53.50em;"/>
        </p>
        <p>PCA and NCA do a better job than random projection in clustering the same digits together. In addition to the visual analysis, we can run the nearest neighbors algorithm on the reduced data to judge which transformation represents the data better. We can use similar code to the preceding one and replace the part inside the <kbd>for</kbd> loop with the following two chunks of code:</p>
        <ol>
          <li>First, we need to scale and transform our data:</li>
        </ol>
        <pre style="padding-left: 60px">from sklearn.preprocessing import StandardScaler<br/>from sklearn.preprocessing import MinMaxScaler<br/><br/>scaler = StandardScaler(with_std=False)<br/><br/>x_train_scaled = scaler.fit_transform(x_train)<br/>x_test_scaled = scaler.fit_transform(x_test)<br/><br/>method_obj.fit(x_train_scaled, y_train)<br/>x_train_2d = method_obj.transform(x_train_scaled)<br/>x_test_2d = method_obj.transform(x_test_scaled)<br/><br/>scaler = MinMaxScaler()<br/>x_train_scaled = scaler.fit_transform(x_train_2d)<br/>x_test_scaled = scaler.transform(x_test_2d)</pre>
        <ol start="2">
          <li>Then, we use cross-validation to set the optimum hyperparameters:</li>
        </ol>
        <pre style="padding-left: 60px" class="mce-root">from sklearn.neighbors import KNeighborsClassifier <br/>from sklearn.model_selection import GridSearchCV <br/>from sklearn.metrics import accuracy_score<br/><br/>parameters = {'metric':('manhattan','euclidean'), 'n_neighbors': range(3, 9)}<br/><br/>knn = KNeighborsClassifier()<br/>clf = GridSearchCV(knn, param_grid=parameters, scoring='accuracy', cv=5)<br/><br/>clf.fit(x_train_scaled, y_train)<br/>y_test_pred = clf.predict(x_test_scaled)<br/><br/>print(<br/>    'MNIST test accuracy score: {:.1%} [k={}, metric={} - {}]'.format(<br/>        accuracy_score(y_test, y_test_pred), <br/>        clf.best_params_['n_neighbors'], <br/>        clf.best_params_['metric'], <br/>        method_name<br/>    )<br/>)</pre>
        <p>Since we do not need to visualize the data this time, we can set the number of components to <kbd>6</kbd>. This gives us the following accuracy scores. Keep in mind that your results may vary due to the random split of the data and the estimator's initial values:</p>
        <table style="border-collapse: collapse;width: 100%" border="1">
          <tbody>
            <tr>
              <td style="width: 62%">
                <strong>Projection</strong>
              </td>
              <td style="width: 14.3028%">
                <strong>Accuracy</strong>
              </td>
            </tr>
            <tr>
              <td style="width: 62%">Sparse random projection</td>
              <td style="width: 14.3028%">73%</td>
            </tr>
            <tr>
              <td style="width: 62%">PCA</td>
              <td style="width: 14.3028%">93%</td>
            </tr>
            <tr>
              <td style="width: 62%">NCA</td>
              <td style="width: 14.3028%">95%</td>
            </tr>
          </tbody>
        </table>
        <div class="packt_infobox">In PCA, the class labels are not needed. I just passed them in the preceding code for consistency, but they were simply ignored by the algorithm. In comparison, in NCA, the class labels are used by the algorithm. </div>
        <h3 id="uuid-b60ba13e-d130-4210-9ff7-bd0e3a486e68">Picking the most informative components </h3>
        <p>After fitting PCA, <kbd>explained_variance_ratio_</kbd> contains the percentage of variance explained by each of the selected components. According to the principal components hypothesis, higher ratios should reflect more information. We can put this information into a data frame, as follows:</p>
        <pre>df_explained_variance_ratio = pd.DataFrame(<br/>    [<br/>        (component, explained_variance_ratio) <br/>        for component, explained_variance_ratio in enumerate(pca.explained_variance_ratio_[:32], 1)<br/>    ], columns=['component', 'explained_variance_ratio']<br/>)</pre>
        <p>Then, plot it to get the following graph. I am sure plotting data via bar charts is becoming second nature to you by now:</p>
        <p class="CDPAlignCenter CDPAlign">
          <img src="assets/3abc98a2-6cd8-41d0-bc5a-c531ff4e8599.png" style="width:56.83em;"/>
        </p>
        <p>From the graph, we can tell that starting from the eighth component, the remaining components carry less than 5% of the information. </p>
        <p>We can also loop through different values for <kbd>n_components</kbd>, and then train a model on the reduced data and see how the accuracy changes with the number of components used. I'd trust this approach more than relying on the explained variance since it is independent of the principal components assumption and evaluates the feature reduction algorithm and the classifier as a single black box. This time, I am going to use a different algorithm: nearest centroid. </p>
        <h4 id="uuid-170d252f-adae-4dc7-84a1-e75cae9b26f6">Using the centroid classifier with PCA </h4>
        <p>In the following code, we will try the centroid algorithm with a different number of principal components each time. Please don't forget to scale and transform your features with each iteration, and remember to store the resulting <kbd>x</kbd> values in <kbd>x_train_embed</kbd> and <kbd>x_test_embed</kbd>. I used <kbd>StandardScaler</kbd> here, as well as the PCA's <kbd>transform</kbd> method, to transform the scaled data:</p>
        <pre>from sklearn.neighbors import NearestCentroid<br/><br/>scores = []<br/>for n_components in range(1, 33, 1):<br/><br/>    # Scale and transform the features as before <br/>    clf = NearestCentroid(shrink_threshold=0.01)<br/>    clf.fit(x_train_embed, y_train)<br/>    y_test_pred = clf.predict(x_test_embed)<br/><br/>scores.append([n_components, accuracy_score(y_test, y_test_pred)])</pre>
        <p>Plotting the scores gives us the following graph:</p>
        <p class="CDPAlignCenter CDPAlign">
          <img src="assets/16bc1d1b-3393-4ec8-ae8d-cdd7be36711b.png" style="width:57.08em;"/>
        </p>
        <p>When we use the centroid algorithm with this dataset, we can roughly see that anything above 15 components doesn't add much value. With the help of cross-validation, we can pick the exact number of components that gives the best results.</p>
        <h3 id="uuid-9a45703e-787a-4277-a9a6-e6731b52d937">Restoring the original image from its components </h3>
        <p>Once an image is reduced to its principal components, it can also be restored back, as follows.</p>
        <ol>
          <li>First, you have to scale your data before using PCA:</li>
        </ol>
        <pre style="padding-left: 60px">from sklearn.preprocessing import StandardScaler<br/>scaler = StandardScaler(with_std=False)<br/>x_train_scaled = scaler.fit_transform(x_train)<br/>x_test_scaled = scaler.transform(x_test)</pre>
        <p style="padding-left: 60px">Once scaled,  you can transform your data using 32 principal components, as follows.</p>
        <ol start="2">
          <li>Then, you can restore the original data after transformation by using the <kbd>inverse_transform</kbd> method:</li>
        </ol>
        <pre style="padding-left: 60px">from sklearn.decomposition import PCA<br/>embedder = PCA(n_components=32)<br/>embedder.fit(x_train, y_train)<br/><br/>x_train_embed = embedder.transform(x_train_scaled)<br/>x_test_embed = embedder.transform(x_test_scaled)<br/><br/>x_train_restored = embedder.inverse_transform(x_train_embed) <br/>x_test_restored = embedder.inverse_transform(x_test_embed)</pre>
        <ol start="3">
          <li>To keep the original images and the restored ones on the same scale, we can use <kbd>MinMaxScaler</kbd>, as follows:</li>
        </ol>
        <pre style="padding-left: 60px">iscaler = MinMaxScaler((x_train.min(), x_train.max()))<br/>x_train_restored = iscaler.fit_transform(x_train_restored) <br/>x_test_restored = iscaler.fit_transform(x_test_restored)</pre>
        <p style="padding-left: 60px">Here, you can see a comparison between some digits and themselves, with the less important components removed. These restored versions of the original data can be useful to the classifier, either by using them in place of the training and test sets, or by adding them as additional samples to the training set:</p>
        <p class="CDPAlignCenter CDPAlign">
          <img src="assets/2958362f-bb66-49ec-ba17-739dedb8d2be.png" style="width:51.00em;"/>
        </p>
        <ol start="4">
          <li>Finally, I used <kbd>x_train_embed</kbd> and <kbd>x_test_embed</kbd> in place of the original features in our nearest neighbors classifier. I tried a different number of PCA components each time. The darker bars in the following graph show the number of PCA components that resulted in the highest accuracy scores:</li>
        </ol>
        <p class="CDPAlignCenter CDPAlign">
          <img src="assets/b886c5c5-427e-4681-8a9d-50433541bb53.png" style="width:57.75em;"/>
        </p>
        <p>Not only did PCA help us reduce the number of features and the prediction time consequently, but it also helped us achieve a score of 98.9%. </p>
        <h2 id="uuid-78433421-e85c-4dd4-9311-83d1e619817d">Finding the most informative pixels </h2>
        <p>Since almost all of the digits are centered in the images, we can intuitively deduce that the pixels on the right and left edges of the images do not carry valuable information. To validate our intuition, we will let the feature selection algorithms from <a href="https://cdp.packtpub.com/hands_on_machine_learning_with_scikit_learn/wp-admin/post.php?post=27&amp;action=edit">Chapter 4</a>,<em> Preparing Your Data</em>, decide for us which pixels are most important. Here, we can use the mutual information algorithm to return a list of pixels and their corresponding importance:</p>
        <pre>from sklearn.feature_selection import mutual_info_classif<br/>mi = mutual_info_classif(x_train, y_train)</pre>
        <p>We then use the preceding information to remove 75% of the pixels:</p>
        <pre>percent_to_remove = 75<br/>mi_threshold = np.quantile(mi, 0.01 * percent_to_remove)<br/>informative_pixels = (mi &gt;= mi_threshold).reshape((8, 8))<br/><br/>plt.imshow(informative_pixels, cmap='Greys')<br/>plt.title(f'Pixels kept when {percent_to_remove}% removed')</pre>
        <p>In the following diagram, the pixels marked in black are the most informative ones, and the rest are the 75% of the pixels that are deemed less important by the mutual information algorithm:</p>
        <p class="CDPAlignCenter CDPAlign">
          <img src="assets/5e056b18-96ab-4f33-b93b-ef6891058f42.png" style="width:20.75em;"/>
        </p>
        <p>As expected, the pixels on the edges are less informative. Now that we have identified the less informative pixels, we can reduce the number of features in our data by removing the less informative pixels, as follows:</p>
        <pre>from sklearn.feature_selection import SelectPercentile<br/>percent_to_keep = 100 - percent_to_remove<br/>selector = SelectPercentile(mutual_info_classif, percentile=percent_to_keep)<br/><br/>x_train_mi = selector.fit_transform(x_train, y_train)<br/>x_test_mi = selector.transform(x_test)</pre>
        <p>Training a classifier on the reduced features gives us an accuracy score of 94%. Knowing that the complexity of the nearest neighbors algorithm and its prediction time grows with the number of features, we can understand the value of a slightly less accurate algorithm that only uses <strong>25%</strong> of the data. </p>
        <h1 id="uuid-dc558085-2239-477d-b215-627d5abddf83">Summary</h1>
        <p>Images are in abundance in our day-to-day life. Robots need computer vision to understand their surroundings. The majority of the posts on social media include pictures. Handwritten documents require image processing to make them consumable by machines. These and many more uses cases are the reason why image processing is an essential competency for machine learning practitioners to master. In this chapter, we learned how to load images and make sense of their pixels. We also learned how to classify images and reduce their dimensions for better visualization and further manipulation. </p>
        <p>We used the nearest neighbor algorithm for image classification and regression. This algorithm allowed us to plug our own metrics when needed. We also learned about other algorithms, such as radius neighbors and nearest centroid. The concepts behind these algorithms and their differences are omnipresent in the field of machine learning. Later on, we will see how the clustering and anomaly detection algorithms borrow ideas from the concepts discussed here. In addition to the main algorithms discussed here, concepts such as distance metrics and dimensionality reduction are also ubiquitous. </p>
        <p>Due to the importance of image processing, we will not stop here, as we are going to build on the knowledge acquired here in <a href="https://cdp.packtpub.com/hands_on_machine_learning_with_scikit_learn/wp-admin/post.php?post=33&amp;action=edit">Chapter 7</a>, <em>Neural Networks – Here Comes the Deep Learning</em>, where we will use artificial neural networks for image classification. </p>
      </article>
    </section>
  </body></html>