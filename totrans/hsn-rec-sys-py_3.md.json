["```py\nimport pandas as pd\nimport numpy as np\n\n#Load the dataset into a pandas dataframe\ndf = pd.read_csv('../data/movies_')\n\n#Display the first five movies in the dataframe\ndf.head()\n```", "```py\n#Calculate the number of votes garnered by the 80th percentile movie\nm = df['vote_count'].quantile(0.80)\nm\n\nOUTPUT: 50.0\n```", "```py\n#Only consider movies longer than 45 minutes and shorter than 300 minutes\nq_movies = df[(df['runtime'] >= 45) & (df['runtime'] <= 300)]\n\n#Only consider movies that have garnered more than m votes\nq_movies = q_movies[q_movies['vote_count'] >= m]\n\n#Inspect the number of movies that made the cut\nq_movies.shape\n\nOUTPUT:\n(8963, 24)\n```", "```py\n# Calculate C\nC = df['vote_average'].mean()\nC\n\nOUTPUT:\n5.6182072151341851\n```", "```py\n# Function to compute the IMDB weighted rating for each movie\ndef weighted_rating(x, m=m, C=C):\n    v = x['vote_count']\n    R = x['vote_average']\n    # Compute the weighted score\n    return (v/(v+m) * R) + (m/(m+v) * C)\n```", "```py\n# Compute the score using the weighted_rating function defined above\nq_movies['score'] = q_movies.apply(weighted_rating, axis=1)\n```", "```py\nimport pandas as pd\nimport numpy as np\n\ndf = pd.read_csv('../data/movies_metadata.csv')\n\n#Print all the features (or columns) of the DataFrame\ndf.columns\n\nOUTPUT:\nIndex(['adult', 'belongs_to_collection', 'budget', 'genres', 'homepage', 'id',\n       'imdb_id', 'original_language', 'original_title', 'overview',\n       'popularity', 'poster_path', 'production_companies',\n       'production_countries', 'release_date', 'revenue', 'runtime',\n       'spoken_languages', 'status', 'tagline', 'title', 'video',\n       'vote_average', 'vote_count'],\n      dtype='object')\n```", "```py\n#Only keep those features that we require \ndf = df[['title','genres', 'release_date', 'runtime', 'vote_average', 'vote_count']]\n\ndf.head()\n```", "```py\n#Convert release_date into pandas datetime format\ndf['release_date'] = pd.to_datetime(df['release_date'], errors='coerce')\n\n#Extract year from the datetime\ndf['year'] = df['release_date'].apply(lambda x: str(x).split('-')[0] if x != np.nan else np.nan)\n```", "```py\n#Helper function to convert NaT to 0 and all other years to integers.\ndef convert_int(x):\n    try:\n        return int(x)\n    except:\n        return 0\n\n#Apply convert_int to the year feature\ndf['year'] = df['year'].apply(convert_int)\n```", "```py\n#Drop the release_date column\ndf = df.drop('release_date', axis=1)\n\n#Display the dataframe\ndf.head()\n```", "```py\n#Print genres of the first movie\ndf.iloc[0]['genres']\n\nOUTPUT:\n\"[{'id': 16, 'name': 'Animation'}, {'id': 35, 'name': 'Comedy'}, {'id': 10751, 'name': 'Family'}]\"\n```", "```py\n#Import the literal_eval function from ast\nfrom ast import literal_eval\n\n#Define a stringified list and output its type\na = \"[1,2,3]\"\nprint(type(a))\n\n#Apply literal_eval and output type\nb = literal_eval(a)\nprint(type(b))\n\nOUTPUT:\n<class 'str'>\n<class 'list'>\n```", "```py\n#Convert all NaN into stringified empty lists\ndf['genres'] = df['genres'].fillna('[]')\n\n#Apply literal_eval to convert to the list object\ndf['genres'] = df['genres'].apply(literal_eval)\n\n#Convert list of dictionaries to a list of strings\ndf['genres'] = df['genres'].apply(lambda x: [i['name'] for i in x] if isinstance(x, list) else [])\n\ndf.head()\n```", "```py\n#Create a new feature by exploding genres\ns = df.apply(lambda x: pd.Series(x['genres']),axis=1).stack().reset_index(level=1, drop=True)\n\n#Name the new feature as 'genre'\ns.name = 'genre'\n\n#Create a new dataframe gen_df which by dropping the old 'genres' feature and adding the new 'genre'.\ngen_df = df.drop('genres', axis=1).join(s)\n\n#Print the head of the new gen_df\ngen_df.head()\n```", "```py\ndef build_chart(gen_df, percentile=0.8):\n    #Ask for preferred genres\n    print(\"Input preferred genre\")\n    genre = input()\n\n    #Ask for lower limit of duration\n    print(\"Input shortest duration\")\n    low_time = int(input())\n\n    #Ask for upper limit of duration\n    print(\"Input longest duration\")\n    high_time = int(input())\n\n    #Ask for lower limit of timeline\n    print(\"Input earliest year\")\n    low_year = int(input())\n\n    #Ask for upper limit of timeline\n    print(\"Input latest year\")\n    high_year = int(input())\n\n    #Define a new movies variable to store the preferred movies. Copy the contents of gen_df to movies\n    movies = gen_df.copy()\n\n    #Filter based on the condition\n    movies = movies[(movies['genre'] == genre) & \n                    (movies['runtime'] >= low_time) & \n                    (movies['runtime'] <= high_time) & \n                    (movies['year'] >= low_year) & \n                    (movies['year'] <= high_year)]\n\n    #Compute the values of C and m for the filtered movies\n    C = movies['vote_average'].mean()\n    m = movies['vote_count'].quantile(percentile)\n\n    #Only consider movies that have higher than m votes. Save this in a new dataframe q_movies\n    q_movies = movies.copy().loc[movies['vote_count'] >= m]\n\n    #Calculate score using the IMDB formula\n    q_movies['score'] = q_movies.apply(lambda x: (x['vote_count']/(x['vote_count']+m) * x['vote_average']) \n                                       + (m/(m+x['vote_count']) * C)\n                                       ,axis=1)\n\n    #Sort movies in descending order of their scores\n    q_movies = q_movies.sort_values('score', ascending=False)\n\n    return q_movies\n```"]