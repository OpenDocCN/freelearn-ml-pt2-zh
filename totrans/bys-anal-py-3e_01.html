<html><head></head><body>
<section id="chapter-2-programming-probabilistically" class="level2 chapterHead" data-number="1.6">&#13;
<h1 class="chapterHead" data-number="1.6">Chapter 2<br/>&#13;
<span id="x1-440002"/>Programming Probabilistically</h1>&#13;
<blockquote>&#13;
<p>Our golems rarely have a physical form, but they too are often made of clay living in silicon as computer code. – Richard McElreath</p>&#13;
</blockquote>&#13;
<p>Now that we have a very basic understanding of probability theory and Bayesian statistics, we are going to learn how to build probabilistic models using computational tools. Specifically, we are going to learn about probabilistic programming with PyMC [<a href="Bibliography.xhtml#Xpymc2023">Abril-Pla et al.</a>, <a href="Bibliography.xhtml#Xpymc2023">2023</a>]. The basic idea is that we use code to specify statistical models and then PyMC will solve those models for us. We will not need to write Bayes’ theorem in explicit form. This is a good strategy for two reasons. First, many models do not lead to an analytic closed form, and thus we can only solve those models using numerical techniques. Second, modern Bayesian statistics is mainly done by writing code. We will be able to see that probabilistic programming offers an effective way to build and solve complex models and allows us to focus more on model design, evaluation, and interpretation, and less on mathematical or computational details.</p>&#13;
<p>This chapter will cover the following topics:</p>&#13;
<ul>&#13;
<li><p>Probabilistic programming</p></li>&#13;
<li><p>A PyMC primer</p></li>&#13;
<li><p>The coin-flipping problem revisited</p></li>&#13;
<li><p>Summarizing the posterior</p></li>&#13;
<li><p>The Gaussian and Student t models</p></li>&#13;
<li><p>Comparing groups and the effect size</p></li>&#13;
</ul>&#13;
<p><span id="x1-44001r61"/></p>&#13;
<section id="probabilistic-programming" class="level3 sectionHead" data-number="1.6.1">&#13;
<h2 class="sectionHead" data-number="1.6.1">2.1 <span id="x1-450001"/>Probabilistic programming</h2>&#13;
<p><span id="dx1-45001"/> <span id="dx1-45002"/></p>&#13;
<p>Bayesian statistics is conceptually very simple. We have the <em>knowns</em> and the <em>unknowns</em>, and we use Bayes’ theorem to condition the latter on the former. If we are lucky, this process will reduce the uncertainty about the <em>unknowns</em>. Generally, we refer to the <em>knowns</em> as <strong>data</strong> and treat it like constants, and the <em>unknowns</em> as <strong>parameters</strong> and <span id="dx1-45003"/>treat them as <em>random variables</em>.</p>&#13;
<p>Although conceptually simple, fully probabilistic models often lead to analytically intractable expressions. For many years, this was a real problem and one of the main issues that hindered the adoption of Bayesian methods beyond some niche applications. The arrival of the computational era and the development of numerical methods that, at least in principle, can be used to solve any inference problem, have dramatically transformed the Bayesian data analysis practice. We can think of these numerical methods as <em>universal inference engines</em>. The possibility of automating the inference process has led to the development of <strong>probabilistic programming languages</strong> (<strong>PPLs</strong>), which allows a clear separation between model creation and inference. In the PPL framework, users specify a full probabilistic model by writing a few lines of code, and then inference follows automatically.</p>&#13;
<p>It is expected that probabilistic programming will have a major impact on data science and other disciplines by enabling practitioners to build complex probabilistic models in a less time-consuming and less error-prone way. I think one good analogy for the impact that programming languages can have on scientific computing is the introduction of the Fortran programming language more than six decades ago. While nowadays Fortran has lost its shine, at one time, it was considered revolutionary. For the first time, scientists moved away from computational details and began focusing on building numerical methods, models, and simulations more naturally. It is interesting to see that some folks are working on making Fortran cool again, if you are interested you can check their work at <a href="https://fortran-lang.org/en" class="url">https://fortran-lang.org/en</a>. <span id="x1-45004r57"/></p>&#13;
<section id="flipping-coins-the-pymc-way" class="level4 subsectionHead" data-number="1.6.1.1">&#13;
<h3 class="subsectionHead" data-number="1.6.1.1">2.1.1 <span id="x1-460001"/>Flipping coins the PyMC way</h3>&#13;
<p><span id="dx1-46001"/></p>&#13;
<p>Let’s revisit the coin-flipping problem from <em>Chapter <a href="CH01.xhtml#x1-160001">1</a></em>, but this time using PyMC. We will use the same synthetic data we used in that chapter. Since we are generating the data, we know the true value of <em>θ</em>, called <code>theta_real</code>, in the following block of code. Of course, for a real dataset, we will not have this knowledge:</p>&#13;
<p><span id="x1-46002r1"/> <span id="x1-46003"/><strong>Code 2.1</strong></p>&#13;
<pre id="listing-10" class="source-code"><code>np.random.seed(123) </code>&#13;
<code> </code>&#13;
<code>trials = 4 </code>&#13;
<code>theta_real = 0.35 # unknown value in a real experiment </code>&#13;
<code>data = pz.Binomial(n=1, p=theta_real).rvs(trials)</code></pre>&#13;
<p>Now that we have the data, we need to specify the model. Remember that this is done by specifying the likelihood and the prior. For the likelihood, we will use the Binomial distribution with parameters <em>n</em> = 1, <em>p</em> = <em>θ</em>, and for the prior, a Beta distribution with the parameters <em>α</em> = <em>β</em> = 1. A Beta distribution with such parameters is equivalent to a Uniform distribution on the interval [0, 1]. Using mathematical notation we can write the model as:</p>&#13;
<div class="math-display">&#13;
<img src="../media/file59.jpg" class="math-display" alt="θ ∼ Beta(𝛼 = 1,𝛽 = 1) Y ∼ Binomial(n = 1,p = θ) "/>&#13;
</div>&#13;
<p>This statistical model has an almost one-to-one translation to PyMC:</p>&#13;
<p><span id="x1-46009r2"/> <span id="x1-46010"/><strong>Code 2.2</strong></p>&#13;
<pre id="listing-11" class="source-code"><code>with pm.Model() as our_first_model: </code>&#13;
<code>    <em>θ</em> = pm.Beta('<em>θ</em>', alpha=1., beta=1.) </code>&#13;
<code>    y = pm.Bernoulli('y', p=<em>θ</em>, observed=data) </code>&#13;
<code>    idata = pm.sample(1000)</code></pre>&#13;
<p>The first line of the code creates a container for our model. Everything inside the <code>with </code>block will be automatically added to <code>our_first_model</code>. You can think of this as syntactic sugar to ease model specification as we do not need to manually assign variables to the model. The second line specifies the prior. As you can see, the syntax follows the mathematical notation closely. The third line specifies the likelihood; the syntax is almost the same as for the prior, except that we pass the data using the <code>observed </code>argument. The observed values can be passed as a Python list, a tuple, a NumPy array, or a pandas DataFrame. With that, we are finished with the model specification! Pretty neat, right?</p>&#13;
<p>We still have one more line of code to explain. The last line is where the magic happens. Behind this innocent line, PyMC has hundreds of <em>oompa loompas</em> singing and baking a delicious Bayesian inference just for you! Well, not exactly, but PyMC is automating a lot of tasks. For the time being, we are going to treat that line as a black box that will give us the correct result. What is important to understand is that under the hood we will be using numerical methods to compute the posterior distribution. In principle, these numerical methods are capable of solving any model we can write. The cost we pay for this generality is that the solution is going to take the form of samples from the posterior. Later, we will be able to corroborate that these samples come from a Beta distribution, as we learned from the previous chapter. Because the numerical methods are stochastic, the samples will vary every time we run them. However, if the inference process works as expected, the samples will be representative of the posterior distribution and thus we will obtain the same conclusion from any of those samples. The details of what happens under the hood and how to check if the samples are indeed trustworthy will be explained in <em>Chapter <a href="CH10.xhtml#x1-18900010">10</a></em>.</p>&#13;
<p>One more thing: the <code>idata </code>variable is an <code>InferenceData </code>object, which is a container for all the data generated by PyMC. We will learn more about this later in this chapter.</p>&#13;
<p>OK, so on the last line, we are asking for 1,000 samples from the posterior. If you run the code, you will get a message like this:</p>&#13;
<pre class="console"><code>Auto-assigning NUTS sampler... Initializing NUTS using jitter+adapt_diag... Multiprocess sampling (4 chains in 4 jobs)&#13;
NUTS: [<em>θ</em>]&#13;
Sampling 4 chains for 1_000 tune and 1_000 draw iterations (4_000 + 4_000 draws total) took 1 second.</code></pre>&#13;
<p>The first and second lines tell us that PyMC has automatically assigned the NUTS sampler (one inference engine that works very well for continuous variables), and has used a method to initialize that sampler (these methods need some initial guess of where to start sampling). The third line says that PyMC will run four chains in parallel, thus we will get four independent samples from the posterior. As PyMC attempts to parallelize these chains across the available processors in your machine, we will get the four for the price of one. The exact number of chains is computed taking into account the number of processors in your machine; you can change it using the <code>chains </code>argument for the <code>sample</code> function. The next line tells us which variables are being sampled by which sampler. For this particular case, this line is not adding new information because NUTS is used to sample the only variable we have, <em>θ</em>. However, this is not always the case because PyMC can assign different samplers to different variables. PyMC has rules to ensure that each variable is associated with the best possible sampler. Users can manually assign samplers using the <code>step </code>argument of the <code>sample </code>function, but you will hardly need to do that.</p>&#13;
<p>Finally, the last line is a progress bar, with several related metrics indicating how fast the sampler is working, including the number of iterations per second. If you run the code, you will see the progress bar get updated really fast. Here, we are seeing the last stage when the sampler has finished its work. You will notice that we have asked for 1,000 samples, but PyMC is computing 8,000 samples. We have 1,000 draws per chain to tune the sampling algorithm (NUTS, in this example). These draws will be discarded by default; PyMC uses them to increase the efficiency and reliability of the sampling method, which are both important to obtain a useful approximation to the posterior. We also have 1,000 productive draws per chain for a total of 4,000. These are the ones we are going to use as our posterior. We can change the number of tuning steps with the <code>tune</code> argument of the sample function and the number of draws with the <code>draw</code> argument.</p>&#13;
<div id="tcolobox-5" class="tcolorbox coolbox">&#13;
<div class="tcolorbox-title">&#13;
<p>Faster Sampling</p>&#13;
</div>&#13;
<div class="tcolorbox-content">&#13;
<span id="dx1-46015"/>&#13;
<p>Under the hood, PyMC uses PyTensor, a library that allows one to define, optimize, and efficiently evaluate mathematical expressions involving multi-dimensional arrays. PyTensor significantly enhances the speed and performance of PyMC. Despite the advantages, it’s worth noting that the samplers in PyMC are implemented in Python, which may result in slower execution at times. To address this limitation, PyMC allows external samplers. I recommend using nutpie, a sampler written in Rust. For more information on how to install and call nutpie from PyMC, please check <em>Chapter <a href="CH10.xhtml#x1-18900010">10</a></em>.</p>&#13;
</div>&#13;
</div>&#13;
<p><span id="x1-46016r64"/></p>&#13;
</section>&#13;
</section>&#13;
<section id="summarizing-the-posterior-1" class="level3 sectionHead" data-number="1.6.2">&#13;
<h2 class="sectionHead" data-number="1.6.2">2.2 <span id="x1-470002"/>Summarizing the posterior</h2>&#13;
<p><span id="dx1-47001"/></p>&#13;
<p>Generally, the first task we will perform after sampling from the posterior is to check what the results look like. The <code>plot_trace </code>function from ArviZ is ideally suited to this task:</p>&#13;
<p><span id="x1-47002r3"/> <span id="x1-47003"/><strong>Code 2.3</strong></p>&#13;
<pre id="listing-12" class="source-code"><code>az.plot_trace(idata)</code></pre>&#13;
<div class="IMG---Figure">&#13;
<img src="../media/file60.png" alt="PIC"/>&#13;
</div>&#13;
<p class="IMG---Caption"><span id="x1-47005r1"/><strong>Figure 2.1</strong>: A trace plot for the posterior of <code>our_first_model</code></p>&#13;
<p><em>Figure <a href="#x1-47005r1">2.1</a></em> shows the default result when calling <code>az.plot_trace</code>; we get two subplots for each unobserved variable. The only unobserved variable in our model is <em>θ</em>. Notice that <em>y</em> is an observed variable representing the data; we do not need to sample that because we already know those values. Thus we only get two subplots. On the left, we have a <strong>Kernel Density Estimation</strong> (<strong>KDE</strong>) plot; this is like the smooth version of the histogram. Ideally, we want all chains to have a very similar KDE, like in <em>Figure <a href="#x1-47005r1">2.1</a></em>. On the right, we get the individual values at each sampling step; we get as many lines as chains. Ideally, we want it to be something that looks noisy, with no clear pattern, and we should have a hard time identifying one chain from the others. In <em>Chapter <a href="CH10.xhtml#x1-18900010">10</a></em>, we give more details on how to interpret these plots. The gist is that if we ran many chains, we would expect them to be practically indistinguishable from each other. The sampler did a good job and we can trust the samples.</p>&#13;
<p>As with other ArviZ functions, <code>az.plot_trace </code>has many options. For instance, we can run this function with the <code>combined </code>argument set to <code>True </code>to get a single KDE plot for all chains and with <code>kind=rank_bars </code>to get a <strong>rank</strong> <strong>plot</strong>.</p>&#13;
<p><span id="x1-47006r4"/> <span id="x1-47007"/><strong>Code 2.4</strong>:</p>&#13;
<pre id="listing-13" class="source-code"><code>az.plot_trace(idata, kind="rank_bars", combined=True)</code></pre>&#13;
<div class="IMG---Figure">&#13;
<img src="../media/file61.png" alt="PIC"/>&#13;
</div>&#13;
<p class="IMG---Caption"><span id="x1-47009r2"/><strong>Figure 2.2</strong>: A trace plot for the posterior of <code>our_first_model</code>, using the options <code>kind="rank_bars"</code>, <code>combined=True</code></p>&#13;
<p>A <span id="dx1-47010"/>rank plot is another way to check if we can trust the samples; for this plot, we get one histogram per chain and we want all of them to be as uniform as possible, like in <em>Figure <a href="#x1-47009r2">2.2</a></em>. Some small deviations for uniformity are expected due to random sampling, but large deviations from uniformity are a signal that chains are exploring different regions of the posteriors. Ideally, we want all chains to explore the entire posterior. In <em>Chapter <a href="CH10.xhtml#x1-18900010">10</a></em>, we provide further details on how to interpret rank plots and how they are constructed.</p>&#13;
<p>ArviZ provides several other plots to help interpret the posterior, and we will see them in the following pages. We may also want to have a numerical summary of the posterior. We can get that using <code>az.summary</code>, which will return a pandas DataFrame as shown in <em>Table <a href="#x1-47014r1">2.1</a></em>.</p>&#13;
<p><span id="x1-47011r5"/> <span id="x1-47012"/><strong>Code 2.5</strong></p>&#13;
<pre id="listing-14" class="source-code"><code>az.summary(idata, kind="stats").round(2)</code></pre>&#13;
<table id="TBL-2" class="tabular">&#13;
<tbody>&#13;
<tr id="TBL-2-1-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-2-1-1" class="td11" style="text-align: center; white-space: nowrap;"/>&#13;
<td id="TBL-2-1-2" class="td11" style="text-align: center; white-space: nowrap;">mean</td>&#13;
<td id="TBL-2-1-3" class="td11" style="text-align: center; white-space: nowrap;">sd</td>&#13;
<td id="TBL-2-1-4" class="td11" style="text-align: center; white-space: nowrap;">hdi_3%</td>&#13;
<td id="TBL-2-1-5" class="td11" style="text-align: center; white-space: nowrap;">hdi_97%</td>&#13;
</tr>&#13;
<tr id="TBL-2-2-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-2-2-1" class="td11" style="text-align: center; white-space: nowrap;"><em>θ</em></td>&#13;
<td id="TBL-2-2-2" class="td11" style="text-align: center; white-space: nowrap;">0.34</td>&#13;
<td id="TBL-2-2-3" class="td11" style="text-align: center; white-space: nowrap;">0.18</td>&#13;
<td id="TBL-2-2-4" class="td11" style="text-align: center; white-space: nowrap;">0.03</td>&#13;
<td id="TBL-2-2-5" class="td11" style="text-align: center; white-space: nowrap;">0.66</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="IMG---Caption"><span id="x1-47014r1"/> <span id="x1-47015"/><strong>Table 2.1</strong>: Summary statistics</p>&#13;
<p>On the first column we have the name of the variable, the second column is the mean of the posterior, the third column is the standard deviation of the posterior, and the last two columns are the lower and upper boundaries of the 94% highest density interval. Thus, according to our model and data, we think the value of <em>θ</em> is likely to be 0.34 with a 94% probability that it is actually between 0.03 and 0.66. We can report a similar summary using the standard deviation. The advantage of the standard deviation over the HDI is that it is a more popular statistic. As a disadvantage, we have to be more careful interpreting it; otherwise, it can lead to meaningless results. For example, if we compute the mean <span class="cmsy-10x-x-109">± </span>2 standard deviations, we will get the intervals (-0.02, 0.7); the upper value is not that far from 0.66, which we got from the HDI, but the lower bound is actually outside the possible values of <em>θ</em>, which is between 0 and 1.</p>&#13;
<p>Another way to visually summarize the posterior is to use the <code>az.plot_posterior</code> function that comes with ArviZ (see <em>Figure <a href="#x1-47019r3">2.3</a></em>). We used this function in the previous chapter for a fake posterior. We are going to use it now for a real posterior.</p>&#13;
<p><span id="x1-47016r6"/> <span id="x1-47017"/><strong>Code 2.6</strong></p>&#13;
<pre id="listing-15" class="source-code"><code>az.plot_posterior(idata)</code></pre>&#13;
<div class="IMG---Figure">&#13;
<img src="../media/file62.png" alt="PIC"/>&#13;
</div>&#13;
<p class="IMG---Caption"><span id="x1-47019r3"/><strong>Figure 2.3</strong>: The plot shows the posterior distribution of <em>θ</em> and the 94% HDI</p>&#13;
<p>By default, <code>plot_posterior </code>shows a histogram for discrete variables and KDEs for continuous variables. We also get the mean of the distribution (we can ask for the median or mode using the <code>point_estimate </code>argument) and the 94% HDI as a black line at the bottom of the plot. Different interval values can be set for the HDI with the <code>hdi_prob </code>argument. This type of plot was introduced by John K. Kruschke in his great book Doing Bayesian Data Analysis [<a href="Bibliography.xhtml#Xkruschke_2014">Kruschke</a>, <a href="Bibliography.xhtml#Xkruschke_2014">2014</a>]. <span id="x1-47020r70"/></p>&#13;
</section>&#13;
<section id="posterior-based-decisions" class="level3 sectionHead" data-number="1.6.3">&#13;
<h2 class="sectionHead" data-number="1.6.3">2.3 <span id="x1-480003"/>Posterior-based decisions</h2>&#13;
<p><span id="dx1-48001"/></p>&#13;
<p>Sometimes, describing the posterior is not enough. We may need to make decisions based on our inferences and reduce a continuous estimation to a dichotomous one: yes-no, healthy-sick, contaminated-safe, and so on. For instance, is the coin fair? A fair coin is one with a <em>θ</em> value of exactly 0.5. We can compare the value of 0.5 against the HDI interval. From <em>Figure <a href="#x1-47019r3">2.3</a></em>, we can see that the HDI goes from 0.03 to 0.7 and hence 0.5 is included in the HDI. We can interpret this as an indication that the coin may be tail-biased, but we cannot completely rule out the possibility that the coin is actually fair. If we want a sharper decision, we will need to collect more data to reduce the spread of the posterior, or maybe we need to find out how to define a more informative prior. <span id="x1-48002r65"/></p>&#13;
<section id="savage-dickey-density-ratio" class="level4 subsectionHead" data-number="1.6.3.1">&#13;
<h3 class="subsectionHead" data-number="1.6.3.1">2.3.1 <span id="x1-490001"/>Savage-Dickey density ratio</h3>&#13;
<p><span id="dx1-49001"/> <span id="dx1-49002"/> <span id="dx1-49003"/></p>&#13;
<p>One way to evaluate how much support the posterior provides for a given value is to compare the ratio of the posterior and prior densities at that value. This is called the Savage-Dickey density ratio and we can compute it with ArviZ using the <code>az.plot_bf </code>function:</p>&#13;
<p><span id="x1-49004r7"/> <span id="x1-49005"/><strong>Code 2.7</strong></p>&#13;
<pre id="listing-16" class="source-code"><code>az.plot_bf(idata, var_name="<em>θ</em>", </code>&#13;
<code>           prior=np.random.uniform(0, 1, 10000), ref_val=0.5);</code></pre>&#13;
<div class="IMG---Figure">&#13;
<img src="../media/file63.png" alt="PIC"/>&#13;
</div>&#13;
<p class="IMG---Caption"><span id="x1-49008r4"/><strong>Figure 2.4</strong>: The plot shows the prior and posterior for <code>our_first_model</code>; the black dots represent their values evaluated at the reference value 0.5</p>&#13;
<p>From <em>Figure <a href="#x1-49008r4">2.4</a></em>, we can see that the value of <code>BF_01 </code>is 1.3, which means that the value of <em>θ</em> = 0<em>.</em>5 is 1.3 times more likely under the posterior distribution than under the prior distribution. To compute this value we just divided the height of the posterior at <em>θ</em> = 0<em>.</em>5 by the height of the prior at <em>θ</em> = 0<em>.</em>5. The value of <code>BF_10</code> is just the inverse <img src="../media/file64.jpg" class="frac" data-align="middle" alt="-1- 1.3"/> <span class="cmsy-10x-x-109">≈ </span>0<em>.</em>8. We can think of this as the value of <em><em>θ</em>≠</em>0<em>.</em>5 being 0.76 times more likely under the posterior than under the prior. How do we interpret these numbers? With a pinch of salt...the following table shows one possible interpretation originally proposed by <a href="Bibliography.xhtml#Xkass_1995">Kass and Raftery</a> [<a href="Bibliography.xhtml#Xkass_1995">1995</a>]:</p>&#13;
<table id="TBL-3" class="tabular">&#13;
<tbody>&#13;
&#13;
<tr id="TBL-3-1-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-3-1-1" class="td11" style="text-align: center; white-space: nowrap;">BF_01</td>&#13;
<td id="TBL-3-1-2" class="td11" style="text-align: center; white-space: nowrap;">Interpretation</td>&#13;
</tr>&#13;
&#13;
<tr id="TBL-3-2-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-3-2-1" class="td11" style="text-align: center; white-space: nowrap;">1 to 3.2</td>&#13;
<td id="TBL-3-2-2" class="td11" style="text-align: center; white-space: nowrap;">Not worth more than a bare mention</td>&#13;
</tr>&#13;
<tr id="TBL-3-3-" class="odd" style="vertical-align:baseline;">&#13;
<td id="TBL-3-3-1" class="td11" style="text-align: center; white-space: nowrap;">3.2 to 10</td>&#13;
<td id="TBL-3-3-2" class="td11" style="text-align: center; white-space: nowrap;">Substantial</td>&#13;
</tr>&#13;
<tr id="TBL-3-4-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-3-4-1" class="td11" style="text-align: center; white-space: nowrap;">10 to 100</td>&#13;
<td id="TBL-3-4-2" class="td11" style="text-align: center; white-space: nowrap;">Strong</td>&#13;
</tr>&#13;
<tr id="TBL-3-5-" class="odd" style="vertical-align:baseline;">&#13;
<td id="TBL-3-5-1" class="td11" style="text-align: center; white-space: nowrap;"><em>&gt;</em> 100</td>&#13;
<td id="TBL-3-5-2" class="td11" style="text-align: center; white-space: nowrap;">Decisive</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="IMG---Caption"><span id="x1-49009r2"/> <span id="x1-49010"/><strong>Table 2.2</strong>: Interpretation of Bayes Factors (BF_01)</p>&#13;
<p>The Savage-Dickey density ratio is a particular way to compute what is called the Bayes Factor. We will learn more about Bayes Factors, and their caveats, in <em>Chapter <a href="CH05.xhtml#x1-950005">5</a></em>. <span id="x1-49011r81"/></p>&#13;
</section>&#13;
<section id="region-of-practical-equivalence" class="level4 subsectionHead" data-number="1.6.3.2">&#13;
<h3 class="subsectionHead" data-number="1.6.3.2">2.3.2 <span id="x1-500002"/>Region Of Practical Equivalence</h3>&#13;
<p><span id="dx1-50001"/> <span id="dx1-50002"/></p>&#13;
<p>Strictly speaking, the chance of observing exactly 0.5 (that is, with infinite trailing zeros) is zero. Also, in practice, we generally do not care about exact results but results within a certain margin. Accordingly, in practice, we can relax the definition of fairness and we can say that a fair coin is one with a value of <em>around</em> 0.5. For example, we could say that any value in the interval [0.45, 0.55] will be, for our purposes, practically equivalent to 0.5. We call this interval a Region Of Practical Equivalence (ROPE). Once the ROPE is defined, we compare it with the HDI. We can get at least three scenarios:</p>&#13;
<ul>&#13;
<li><p>The ROPE does not overlap the HDI; we can say the coin is not fair</p></li>&#13;
<li><p>The ROPE contains the entire HDI; we can say the coin is fair</p></li>&#13;
<li><p>The ROPE partially overlaps HDI; we cannot say the coin is fair or unfair</p></li>&#13;
</ul>&#13;
<p>If we choose the ROPE to match the support of a parameter, like [0, 1] for the coin-flipping example, we will always say we have a fair coin. Notice that we do not need to collect data to perform any type of inference.</p>&#13;
<p>The choice of ROPE is completely arbitrary: we can choose any value we want. Some choices are not very useful. If, for the coin-flipping example, we choose the ROPE to be [0, 1], then we will always say the coin is fair. Even more, we don’t need to collect data or perform any analysis to reach this conclusion, this is a trivial example. More worrisome is to pick the ROPE after performing the analysis. This is problematic because we can accommodate the results to say whatever we want them to say. But why do we even bother to do an analysis, if we are going to accommodate the result to our expectations? The ROPE should be informed from domain knowledge.</p>&#13;
<p>We can use the <code>plot_posterior </code>function to plot the posterior with the HDI interval and the ROPE. The ROPE appears as a semi-transparent thick (gray) line:</p>&#13;
<p><span id="x1-50003r8"/> <span id="x1-50004"/><strong>Code 2.8</strong></p>&#13;
<pre id="listing-17" class="source-code"><code>az.plot_posterior(idata, rope=[0.45, .55])</code></pre>&#13;
<div class="IMG---Figure">&#13;
<img src="../media/file65.png" alt="PIC"/>&#13;
</div>&#13;
<p class="IMG---Caption"><span id="x1-50006r5"/><strong>Figure 2.5</strong>: The plot shows the posterior distribution of <em>θ</em> and the 94% HDI. The ROPE is shown as a thick light-gray line</p>&#13;
<p>Another tool we can use to help us make a decision is to compare the posterior against a reference value. We can do this using <code>plot_posterior</code>. As you can see in <em>Figure <a href="#x1-50011r6">2.6</a></em>, we get a vertical (gray) line and the <span id="dx1-50007"/>proportion of the posterior above and below our reference value:</p>&#13;
<p><span id="x1-50008r9"/> <span id="x1-50009"/><strong>Code 2.9</strong></p>&#13;
<pre id="listing-18" class="source-code"><code>az.plot_posterior(idata, ref_val=0.5)</code></pre>&#13;
<div class="IMG---Figure">&#13;
<img src="../media/file66.png" alt="PIC"/>&#13;
</div>&#13;
<p class="IMG---Caption"><span id="x1-50011r6"/><strong>Figure 2.6</strong>: The plot shows the posterior distribution of <em>θ</em> and the 94% HDI. The reference value is shown as a gray vertical line</p>&#13;
<p>For a more detailed discussion on the <span id="dx1-50012"/>use of the ROPE, you could read Chapter 12 of Doing Bayesian Data Analysis by <a href="Bibliography.xhtml#Xkruschke_2014">Kruschke</a> [<a href="Bibliography.xhtml#Xkruschke_2014">2014</a>]. That chapter also discusses how to perform hypothesis testing in a Bayesian framework and the caveats of hypothesis testing, whether in a Bayesian or non-Bayesian setting. <span id="x1-50013r85"/></p>&#13;
</section>&#13;
<section id="loss-functions" class="level4 subsectionHead" data-number="1.6.3.3">&#13;
<h3 class="subsectionHead" data-number="1.6.3.3">2.3.3 <span id="x1-510003"/>Loss functions</h3>&#13;
<p><span id="dx1-51001"/> <span id="dx1-51002"/></p>&#13;
<p>If you think these ROPE rules sound a little bit clunky and you want something more formal, loss functions are what you are looking for! To make a good decision, it is important to have the highest possible level of precision for the estimated value of the relevant parameters, but it is also important to take into account the cost of making a mistake. The cost/benefit trade-off can be mathematically formalized using loss functions. The names for loss functions or their inverses vary across different fields, and we could find names such as cost functions, objective functions, fitness functions, utility functions, and so on. No matter the name, the key idea is to use a function that captures how different the true value and the estimated value of a parameter are. The larger the value of the loss function, the worse the estimation is (according to the loss function). Some common examples of loss functions are:</p>&#13;
<ul>&#13;
<li><p>The absolute loss function, <span class="cmsy-10x-x-109">|</span><em>θ</em> <span class="cmsy-10x-x-109">− </span><img src="../media/hat_theta.png" style="width:0.50em;"/><span class="cmsy-10x-x-109">|</span></p></li>&#13;
<li><p>The quadratic loss function, (<em>θ</em> <span class="cmsy-10x-x-109">− </span><img src="../media/hat_theta.png" style="width:0.50em;"/>)<sup>2</sup></p></li>&#13;
<li><p>The 0-1 loss function, <span class="bbm-10x-x-109">1</span>(<em><em>θ </em>≠ </em><img src="../media/hat_theta.png" style="width:0.50em;"/>), where <img src="../media/one.PNG" style="width:0.50em;"/> is the indicator function</p></li>&#13;
</ul>&#13;
<p>In practice, we don’t know the value of the true parameter. Instead, we have an estimation in the form of a posterior distribution. Thus, what we can do is find out the value of <em>θ</em> that minimizes the expected loss function. By expected loss function, we mean the loss function averaged over the whole posterior distribution.</p>&#13;
<p>In the following block of code, we have two loss functions: the absolute loss (<code>lossf_a</code>) and the quadratic loss (<code>lossf_b</code>). We will explore the value of over a grid of 200 points. We will then plot those curves and we will also include the value of <em>θ</em> that minimizes each loss function. The following block shows the Python code without the plotting part:</p>&#13;
<p><span id="x1-51003r10"/> <span id="x1-51004"/><strong>Code 2.10</strong></p>&#13;
<pre id="listing-19" class="source-code"><code>grid = np.linspace(0, 1, 200) </code>&#13;
<code><em>θ</em>_pos = idata.posterior['<em>θ</em>'] </code>&#13;
<code>lossf_a = [np.mean(abs(i - <em>θ</em>_pos)) for i in grid] </code>&#13;
<code>lossf_b = [np.mean((i - <em>θ</em>_pos)**2) for i in grid] </code>&#13;
<code>for lossf, c in zip([lossf_a, lossf_b], ['C0', 'C1']): </code>&#13;
<code>    ...</code></pre>&#13;
<div class="IMG---Figure">&#13;
<img src="../media/file67.png" alt="PIC"/>&#13;
</div>&#13;
<p class="IMG---Caption"><span id="x1-51011r7"/><strong>Figure 2.7</strong>: The absolute (black) and quadratic (gray) loss functions applied to the posterior from <code>our_first_model</code></p>&#13;
<p>What is more interesting from <em>Figure <a href="#x1-51011r7">2.7</a></em> is that the value we got from the absolute loss is equal to the median of the posterior and the one we got from the quadratic loss is equal to the mean of the posterior. You can check this for yourself by computing <code>np.mean(</code><em>θ</em><code>_pos)</code>, <code>np.median(</code><em>θ</em><code>_pos)</code>. This is no coincidence: different loss functions are related to different point estimates. The mean is the point estimate that minimizes the quadratic loss, the median, the absolute loss, and the mode, the 1-0 loss.</p>&#13;
<p>If we want to be formal and we want to compute a single-point estimate, we must decide which loss function we want. Conversely, if we choose a point estimate, we are implicitly (and maybe unconsciously) choosing a loss function. The advantage of explicitly choosing a loss function is that we can tailor the function to our problem instead of using a predefined rule. It is very common to observe that the cost of making a decision is asymmetric; for example, vaccines can produce an overreaction of the immune system, but the benefit to the vaccinated persons and even non-vaccinated persons overcomes the risk, usually by many orders of magnitude. Thus, if our problem demands it, we can construct an asymmetric loss function. It is also important to notice that, as the posterior is in the form of numerical samples, we can compute complex loss functions that don’t need to be restricted by mathematical convenience or mere simplicity. The following code, and <em>Figure <a href="#x1-51021r8">2.8</a></em> generated from it, is just a silly example of this:</p>&#13;
<p><span id="x1-51012r11"/> <span id="x1-51013"/><strong>Code 2.11</strong></p>&#13;
<pre id="listing-20" class="source-code"><code>lossf = [] </code>&#13;
<code>for i in grid: </code>&#13;
<code>    if i &lt; 0.5: </code>&#13;
<code>        f = 1/np.median(<em>θ</em>_pos / np.abs(i**2 - <em>θ</em>_pos)) </code>&#13;
<code>    else: </code>&#13;
<code>        f = np.mean((i - <em>θ</em>_pos)**2 + np.exp(-i)) - 0.25 </code>&#13;
<code>    lossf.append(f)</code></pre>&#13;
<div class="IMG---Figure">&#13;
<img src="../media/file68.png" alt="PIC"/>&#13;
</div>&#13;
<p class="IMG---Caption"><span id="x1-51021r8"/><strong>Figure 2.8</strong>: A weird loss function applied to the posterior from <code>our_first_model</code></p>&#13;
<p>Up until now, we have been discussing the main notions of Bayesian statistics and probabilistic programming using the BetaBinomial model mainly because of its simplicity. In our path to build more complex models, we now shift our focus to delve into the realm of Gaussian inference. <span id="x1-51022r80"/></p>&#13;
</section>&#13;
</section>&#13;
<section id="gaussians-all-the-way-down" class="level3 sectionHead" data-number="1.6.4">&#13;
<h2 class="sectionHead" data-number="1.6.4">2.4 <span id="x1-520004"/>Gaussians all the way down</h2>&#13;
<p>Gaussians are very appealing from a mathematical point of view. Working with them is relatively easy, and many operations applied to Guassians return another Gaussian. Additionally, many natural phenomena can be nicely approximated using Gaussians; essentially, almost every time that we measure the average of something, using a <em>big enough</em> sample size, that average will be distributed as a Gaussian. The details of when this is true, when this is not true, and when this is more or less true, are elaborated in the <strong>central limit theorem</strong> (CLT); you may want to stop reading now and search about this really <em>central</em> statistical concept (terrible pun intended).</p>&#13;
<p>Well, we were saying that many phenomena are indeed averages. Just to follow a cliché, the height (and almost any other trait of a person, for that matter) is the result of many environmental factors and many genetic factors, and hence we get a nice Gaussian distribution for the height of adult people. Indeed, we get a mixture of two Gaussians, which is the result of overlapping the distribution of heights of women and men, but you get the idea. In summary, Gaussians are easy to work with and abundant in natural phenomena; hence, many of the statistical methods you may already know assume normality. Thus, it is important to learn how to build these models, and then it is equally important to learn how to relax the normality assumptions, something that is surprisingly easy in a Bayesian framework and with modern computational tools such as PyMC. <span id="x1-52001r90"/></p>&#13;
<section id="gaussian-inferences" class="level4 subsectionHead" data-number="1.6.4.1">&#13;
<h3 class="subsectionHead" data-number="1.6.4.1">2.4.1 <span id="x1-530001"/>Gaussian inferences</h3>&#13;
<p><span id="dx1-53001"/></p>&#13;
<p>Nuclear magnetic resonance (NMR) is a powerful technique used to study molecules and also living things such as humans, sunflowers, and yeast (because, after all, <em>we are just a bunch of molecules</em>). NMR allows you to <span id="dx1-53002"/>measure different kinds of observable quantities related to interesting unobservable molecular properties <a href="Bibliography.xhtml#Xarroyuelo_2021">Arroyuelo et al.</a> [<a href="Bibliography.xhtml#Xarroyuelo_2021">2021</a>]. One of these observables is known as <span id="dx1-53003"/>chemical shift, which we can only get for the nuclei of certain types of atoms. The details belong to quantum chemistry and they are irrelevant to this discussion. For all we care at the moment, we could have been measuring the height of a group of people, the average time to travel back home, or the weights of bags of oranges. In these examples the variables are continuous, and it makes sense to think of them as an average value plus a dispersion. Sometimes we can use a Gaussian model for discrete variables if the number of possible values is large enough; for example, bonobos are very promiscuous, so maybe we can model the number of sexual partners of our cousins with a Gaussian.</p>&#13;
<p>Going back to our example, we have 48 chemical shift values represented in a boxplot in <em>Figure <a href="#x1-53004r9">2.9</a></em>. We can see that the median (the line inside the box) is around 53 and the interquartile range (the box) is around 52 and 55. We can see that there are two values far away from the rest of the data (empty circles).</p>&#13;
<div class="IMG---Figure">&#13;
<img src="../media/file69.png" alt="PIC"/>&#13;
</div>&#13;
<p class="IMG---Caption"><span id="x1-53004r9"/><strong>Figure 2.9</strong>: Boxplot of the 48 chemical shift values. We observed two values above 60, far away from the rest of the data</p>&#13;
<p>Let’s forget about those two points for a moment and assume that a Gaussian distribution is a good description of the data. Since we do not know the mean or the standard deviation, we must set priors for both of them. Therefore, a reasonable model could be:</p>&#13;
<div class="math-display">&#13;
<img src="../media/file70.jpg" class="math-display" alt="μ ∼ 𝒰 (l,h ) σ ∼ ℋ 𝒩 (σσ) Y ∼ 𝒩 (μ, σ) "/>&#13;
</div>&#13;
<p><span class="cmsy-10x-x-109"><img src="../media/U.PNG" style="width:1.4em; vertical-align: -0.30em;"/></span>(<em>l,h</em>) is the Uniform distribution between <em>l</em>, and <em>h</em>, <span class="cmsy-10x-x-109"><img src="../media/HN.PNG" style="width:2.2em; vertical-align: -0.10em;"/></span>(<em>σ</em><sub><em>σ</em></sub>) is the HalfNormal distribution with scale <em>σ</em><sub><em>σ</em></sub>, and <span class="cmsy-10x-x-109"><img src="../media/N.PNG" style="width:1.4em; vertical-align: -0.30em;"/></span>(<em>μ,σ</em>) is the Gaussian distribution with mean <em>μ</em> and standard deviation <em>σ</em>. A HalfNormal distribution considers the absolute values of Normal distribution centered around zero. <em>Figure <a href="#x1-53005r10">2.10</a></em> shows the graphical representation of this model.</p>&#13;
<div class="IMG---Figure">&#13;
<img src="../media/file71.png" alt="PIC"/>&#13;
</div>&#13;
<p class="IMG---Caption"><span id="x1-53005r10"/><strong>Figure 2.10</strong>: Graphical representation of <code>model_g</code></p>&#13;
<p>If we do not know the possible values of <em>μ</em> and <em>σ</em>, we can set priors reflecting our ignorance. One option is to set the boundaries of the Uniform distribution to be <em>l</em> = 40, <em>h</em> = 75, which is a range that is larger than the range of the data. Alternatively, we can choose a range based on our previous knowledge. For instance, we may know that this is not physically possible to have values below 0 or above 100 for this type of measurement and thus use those values as the boundaries of the Uniform distribution. For the HalfNormal, and in the absence of more information, we can choose a large value compared to the scale of the data. The PyMC code for the model represented in <em>Figure <a href="#x1-53005r10">2.10</a></em> is:</p>&#13;
<p><span id="x1-53006r12"/> <span id="x1-53007"/><strong>Code 2.12</strong></p>&#13;
<pre id="listing-21" class="source-code"><code>with pm.Model() as model_g: </code>&#13;
<code>    μ = pm.Uniform('μ', lower=40, upper=70) </code>&#13;
<code>    σ = pm.HalfNormal('σ', sigma=5) </code>&#13;
<code>    Y = pm.Normal('Y', mu=μ, sigma=σ, observed=data) </code>&#13;
<code>    idata_g = pm.sample()</code></pre>&#13;
<p>Let’s see what the posterior looks like. <em>Figure <a href="#x1-53013r11">2.11</a></em> was generated with the ArviZ function <code>plot_trace</code>. It has one row for each parameter. For this model, the posterior is bidimensional, so each row shows one marginal distribution.</p>&#13;
<div class="IMG---Figure">&#13;
<img src="../media/file72.png" alt="PIC"/>&#13;
</div>&#13;
<p class="IMG---Caption"><span id="x1-53013r11"/><strong>Figure 2.11</strong>: Posterior from <code>model_g </code>ploted using <code>az.plot_trace(idata_g)</code></p>&#13;
<p>We can use the <code>plot_pair </code>function from ArviZ to see what the bi-dimensional posterior looks like, together with the marginal distributions for <em>μ</em> and <em>σ</em>. See <em>Figure <a href="#x1-53014r12">2.12</a></em>:</p>&#13;
<div class="IMG---Figure">&#13;
<img src="../media/file73.png" alt="PIC"/>&#13;
</div>&#13;
<p class="IMG---Caption"><span id="x1-53014r12"/><strong>Figure 2.12</strong>: Posterior from <code>model_g </code>ploted using <code>az.plot_pair(idata_g, kind=’kde’, marginals=True)</code></p>&#13;
<p>We are going to print the summary for later use (see <em>Table <a href="#x1-53018r3">2.3</a></em>). We use the following code:</p>&#13;
<p><span id="x1-53015r13"/> <span id="x1-53016"/><strong>Code 2.13</strong></p>&#13;
<pre id="listing-22" class="source-code"><code>az.summary(idata_g, kind="stats").round(2)</code></pre>&#13;
<table id="TBL-4" class="tabular">&#13;
<tbody>&#13;
<tr id="TBL-4-1-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-4-1-1" class="td11" style="text-align: center; white-space: nowrap;"/>&#13;
<td id="TBL-4-1-2" class="td11" style="text-align: center; white-space: nowrap;">mean</td>&#13;
<td id="TBL-4-1-3" class="td11" style="text-align: center; white-space: nowrap;">sd</td>&#13;
<td id="TBL-4-1-4" class="td11" style="text-align: center; white-space: nowrap;">hdi_3%</td>&#13;
<td id="TBL-4-1-5" class="td11" style="text-align: center; white-space: nowrap;">hdi_97%</td>&#13;
</tr>&#13;
<tr id="TBL-4-2-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-4-2-1" class="td11" style="text-align: center; white-space: nowrap;"><em>μ</em></td>&#13;
<td id="TBL-4-2-2" class="td11" style="text-align: center; white-space: nowrap;">53.50</td>&#13;
<td id="TBL-4-2-3" class="td11" style="text-align: center; white-space: nowrap;">0.52</td>&#13;
<td id="TBL-4-2-4" class="td11" style="text-align: center; white-space: nowrap;">52.51</td>&#13;
<td id="TBL-4-2-5" class="td11" style="text-align: center; white-space: nowrap;">54.44</td>&#13;
</tr>&#13;
<tr id="TBL-4-3-" class="odd" style="vertical-align:baseline;">&#13;
<td id="TBL-4-3-1" class="td11" style="text-align: center; white-space: nowrap;"><em>σ</em></td>&#13;
<td id="TBL-4-3-2" class="td11" style="text-align: center; white-space: nowrap;">3.52</td>&#13;
<td id="TBL-4-3-3" class="td11" style="text-align: center; white-space: nowrap;">0.38</td>&#13;
<td id="TBL-4-3-4" class="td11" style="text-align: center; white-space: nowrap;">2.86</td>&#13;
<td id="TBL-4-3-5" class="td11" style="text-align: center; white-space: nowrap;">4.25</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="IMG---Caption"><span id="x1-53018r3"/> <span id="x1-53019"/><strong>Table 2.3</strong>: Summary statistics for <em>μ</em> and <em>σ</em></p>&#13;
<p><span id="x1-53020r95"/></p>&#13;
</section>&#13;
</section>&#13;
<section id="posterior-predictive-checks" class="level3 sectionHead" data-number="1.6.5">&#13;
<h2 class="sectionHead" data-number="1.6.5">2.5 <span id="x1-540005"/>Posterior predictive checks</h2>&#13;
<p><span id="dx1-54001"/></p>&#13;
<p>One of the nice elements of the Bayesian toolkit is that once we have a posterior <em>p</em>(<em>θ</em><span class="cmsy-10x-x-109">|</span><em>Y</em> ), it is possible to use it to generate predictions <em>p</em>(<em>Ỹ</em>). Mathematically, this can be done by computing:</p>&#13;
<div class="math-display">&#13;
<img src="../media/file74.jpg" class="math-display" alt=" ∫ p(˜Y | Y ) = p(˜Y | θ) p(θ | Y )dθ "/>&#13;
</div>&#13;
<p>This distribution is known as the <strong>posterior predictive distribution</strong>. It is <em>predictive</em> because it is used to make predictions, and <em>posterior</em> because it is computed using the posterior distribution. So we can think of this as the distribution of future data given the model, and observed data.</p>&#13;
<p>Using PyMC is easy to get posterior predictive samples; we don’t need to compute any integral. We just need to call the <code>sample_posterior_predictive</code> function and pass the <code>InferenceData </code>object as the first argument. We also need to pass the <code>model </code>object, and we can use the <code>extend_inferencedata </code>argument to add the posterior predictive samples to the <code>InferenceData </code>object. The code is:</p>&#13;
<p><span id="x1-54002r14"/> <span id="x1-54003"/><strong>Code 2.14</strong></p>&#13;
<pre id="listing-23" class="source-code"><code>pm.sample_posterior_predictive(idata_g, model=model_g, </code>&#13;
<code>                              extend_inferencedata=True)</code></pre>&#13;
<p>One common use of the posterior predictive distribution is to perform posterior predictive checks. These are a set of tests that can be used to check if the model is a good fit for the data. We can use the <code>plot_ppc </code>function from ArviZ to visualize the posterior predictive distribution and the observed data. The code is:</p>&#13;
<p><span id="x1-54006r15"/> <span id="x1-54007"/><strong>Code 2.15</strong></p>&#13;
<pre id="listing-24" class="source-code"><code>az.plot_ppc(idata_g, num_pp_samples=100)</code></pre>&#13;
<div class="IMG---Figure">&#13;
<img src="../media/file75.png" alt="PIC"/>&#13;
</div>&#13;
<p class="IMG---Caption"><span id="x1-54009r13"/><strong>Figure 2.13</strong>: Posterior predictive check for <code>model_g </code>ploted using <code>az.plot_ppc</code></p>&#13;
<p>In <em>Figure <a href="#x1-54009r13">2.13</a></em>, the black line is a KDE of the data and the gray lines are KDEs computed from each one of the 100 posterior predictive samples. The gray lines reflect the uncertainty we have about the distribution of the predicted data. The plots look <em>hairy</em> or <em>wonky</em>; this will happen when you have very few data points. By default, the KDEs in ArviZ are estimated within the actual range of the data and assumed to be zero outside. While some might consider this a bug, I think it’s a feature, since it’s reflecting a property of the data instead of over-smoothing it.</p>&#13;
<p>From <em>Figure <a href="#x1-54009r13">2.13</a></em>, we can see that the mean of the simulated data is slightly displaced to the right and that the variance seems to be larger for the simulated data than for the actual data. The source of this discrepancy can be attributed to the combination of our choice of likelihood and the two observations away from the bulk of the data (the empty dots in <em>Figure <a href="#x1-53004r9">2.9</a></em>). How can we interpret this plot? Is the model wrong or right? Can we use it or do we need a different model? Well, it depends. The interpretation of a model and its evaluation and criticism are always context-dependent. Based on my experience with this kind of measurement, I would say this model is a reasonable enough representation of the data and a useful one for most of my analysis. Nevertheless, it is important to keep in mind that we could find other models that better accommodate the whole dataset, including the two observations that are far from the bulk of the data. Let’s see how we can do that. <span id="x1-54010r102"/></p>&#13;
</section>&#13;
<section id="robust-inferences" class="level3 sectionHead" data-number="1.6.6">&#13;
<h2 class="sectionHead" data-number="1.6.6">2.6 <span id="x1-550006"/>Robust inferences</h2>&#13;
<p><span id="dx1-55001"/></p>&#13;
<p>One objection we may have with <code>model_g </code>is that we are assuming a Normal distribution, but we have two data points away from the bulk of the data. By using a Normal distribution for the likelihood, we are indirectly assuming that we are not expecting to see a lot of data points far away from the bulk. <em>Figure <a href="#x1-54009r13">2.13</a></em> shows the result of combining these assumptions with the data. Since the tails of the Normal distribution fall quickly as we move away from the mean, the Normal distribution (at least an anthropomorphized one) is <em>surprised by seeing</em> those two points and <em>reacts</em> in two ways, moving its mean towards those points and increasing its standard deviation. Another intuitive way of interpreting this is by saying that those points have an excessive weight in determining the parameters of the Normal distribution.</p>&#13;
<p>So, what can we do? One option is to check for errors in the data. If we retrace our steps we may find an error in the code while cleaning or preprocessing the data, or we can relate the putative anomalous values to the malfunction of the measuring equipment. Unfortunately, this is not always an option. Many times, the data was collected by others and we don’t have a good register of how it was collected, measured or processed. Anyway, inspecting the data before modeling is always a good idea, that’s a good practice in general.</p>&#13;
<p>Another option is to declare those points outliers and remove them from the data. Two common rules of thumb for identifying outliers in a dataset are:</p>&#13;
<ul>&#13;
<li><p>Using the interquartile range (IQR): Any data point that falls below 1.5 times the IQR from the lower quartile, or above 1.5 times the IQR from the upper quartile, is considered an outlier.</p></li>&#13;
<li><p>Using the standard deviation: Any data point that falls below or above <em>N</em> times the standard deviation of the data is considered an outlier. With <em>N</em> usually being 2 or 3.</p></li>&#13;
</ul>&#13;
<p>However, it’s important to note that, like any automatic method, these rules of thumb are not perfect and may result in discarding valid data points.</p>&#13;
<p>From a modeling perspective, instead of blaming the data we can blame the model and change it, as explained in the next section. As a general rule, Bayesians prefer to encode assumptions directly into the model by using different priors and likelihoods rather than through ad hoc heuristics such as outlier removal rules. <span id="x1-55002r96"/></p>&#13;
<section id="degrees-of-normality" class="level4 subsectionHead" data-number="1.6.6.1">&#13;
<h3 class="subsectionHead" data-number="1.6.6.1">2.6.1 <span id="x1-560001"/>Degrees of normality</h3>&#13;
<p><span id="dx1-56001"/></p>&#13;
<p>There is one distribution that looks very similar to a Normal distribution. It has three parameters: a location parameter <em>μ</em>, a scale parameter <em>σ</em>, and a normality parameter <em>ν</em>. This distribution’s name is Student’s t-distribution. <em>Figure <a href="#x1-56002r14">2.14</a></em> shows members of this family. When <em>ν</em> = <span class="cmsy-10x-x-109">∞ </span>the distribution is the Normal distribution, <em>μ</em> is the mean and <em>σ</em> is the standard deviation. When <em>ν</em> = 1, we get the Cauchy or Lorentz distribution. <em>ν</em> can go from 0 to <span class="cmsy-10x-x-109">∞</span>. The lower this number, the heavier their tails. We can also say that the lower the value of <em>ν</em>, the higher the kurtosis. The kurtosis is the fourth moment, as you may remember from the previous chapter. By heavy tails, we mean that it is more probable to find values away from the mean compared to a Normal, or in other words, values are not as concentrated around the mean as in a lighter tail distribution like the Normal. For example, 95% of the values from a Student’s t (<em>μ</em> = 0<em>,σ</em> = 1<em>,ν</em> = 1) are found between -12.7 and 12.7. Instead, for a Normal (<em>μ</em> = 0<em>,σ</em> = 1<em>,ν</em> = <span class="cmsy-10x-x-109">∞</span>), this occurs between -1.96 and 1.96.</p>&#13;
<div class="IMG---Figure">&#13;
<img src="../media/file76.png" alt="PIC"/>&#13;
</div>&#13;
<p class="IMG---Caption"><span id="x1-56002r14"/><strong>Figure 2.14</strong>: The Student’s t-distribution</p>&#13;
<p>A very curious feature of the Student’s t-distribution is that it has no defined mean value when <em>ν</em> <span class="cmsy-10x-x-109">≤ </span>1. While any finite sample from a Student’s t-distribution is just a bunch of numbers from which it is always possible to compute an empirical mean, the theoretical distribution itself is the one without a defined value for the mean. Intuitively, this can be understood as follows: the tails of the distribution are so heavy that at any moment we might get a sampled value from almost anywhere from the real line, so if we keep getting numbers, we will never approach a fixed value. Instead, the estimate will keep wandering around.</p>&#13;
<div id="tcolobox-6" class="tcolorbox coolbox">&#13;
<div class="tcolorbox-title">&#13;
<p>Degrees of what?</p>&#13;
</div>&#13;
<div class="tcolorbox-content">&#13;
<p>In most textbooks, the parameter <em>ν</em> from the Student’s t-distribution is referred to as the degrees of freedom parameter. However, I prefer to follow Kruschke’s suggestion and call it the normality parameter. This name is more descriptive of the parameter’s role in the distribution, especially as used for robust regression.</p>&#13;
</div>&#13;
</div>&#13;
<p>Similarly, the variance of this distribution is only defined for values of <em>ν &gt;</em> 2. So, it’s important to note that the scale of the Student’s t-distribution isn’t the same as its standard deviation. The scale and the standard deviation become closer and closer as <em>ν</em> approaches infinity. <span id="x1-56003r108"/></p>&#13;
</section>&#13;
<section id="a-robust-version-of-the-normal-model" class="level4 subsectionHead" data-number="1.6.6.2">&#13;
<h3 class="subsectionHead" data-number="1.6.6.2">2.6.2 <span id="x1-570002"/>A robust version of the Normal model</h3>&#13;
<p><span id="dx1-57001"/></p>&#13;
<p>We are going to rewrite the previous model (<code>model_g</code>) by replacing the Gaussian distribution with the Student’s t-distribution. Because the Student’s t-distribution has one more parameter, <em>ν</em>, than the Gaussian, we need to specify one more prior, for this model we decided to use the exponential distribution, but other distributions restricted to the positive interval could also work.</p>&#13;
<div class="math-display">&#13;
<img src="../media/file77.jpg" class="math-display" alt="μ ∼ 𝒰(l,h) σ ∼ ℋ 𝒩 (σ ) σ ν ∼ Exp (λ ) Y ∼ 𝒯 (ν,μ, σ) "/>&#13;
</div>&#13;
<p><em>Figure <a href="#x1-57002r15">2.15</a></em> shows the graphical representation of this model</p>&#13;
<div class="IMG---Figure">&#13;
<img src="../media/file78.png" alt="PIC"/>&#13;
</div>&#13;
<p class="IMG---Caption"><span id="x1-57002r15"/><strong>Figure 2.15</strong>: Graphical representation of <code>model_t</code></p>&#13;
<p>Let’s write this model in PyMC; as usual, we can (re)write models by specifying a few lines. The only cautionary word here is that by default the Exponential distribution in PyMC is parameterized with the inverse of the mean. We are going to set <em>ν</em> as an Exponential distribution with a mean of 30. From <em>Figure <a href="#x1-56002r14">2.14</a></em>, we can see that a Student’s t-distribution with <em>ν</em> = 30 looks pretty similar to a Gaussian (even when it is not). In fact, from the same diagram, we can see that <em>most of the action</em> happens for relatively small values of <em>ν</em>. Hence, we can say that the Exponential prior with a mean of 30 is a weakly informative prior telling the model we more or less think should be around 30 but can move to smaller and larger values with ease. In many problems, estimating <em>ν</em> is of no direct interest.</p>&#13;
<p><span id="x1-57003r16"/> <span id="x1-57004"/><strong>Code 2.16</strong></p>&#13;
<pre id="listing-25" class="source-code"><code>with pm.Model() as model_t: </code>&#13;
<code>    μ = pm.Uniform('μ', 40, 75) </code>&#13;
<code>    σ = pm.HalfNormal('σ', sigma=10) </code>&#13;
<code>    ν = pm.Exponential('ν', 1/30) </code>&#13;
<code>    y = pm.StudentT('y', nu=ν, mu=μ, sigma=σ, observed=data) </code>&#13;
<code>    idata_t = pm.sample()</code></pre>&#13;
<p>Compare the trace from <code>model_g </code>(<em>Figure <a href="#x1-53013r11">2.11</a></em>) with the trace of <code>model_t </code>(<em>Figure <a href="#x1-57011r16">2.16</a></em>):</p>&#13;
<div class="IMG---Figure">&#13;
<img src="../media/file79.png" alt="PIC"/>&#13;
</div>&#13;
<p class="IMG---Caption"><span id="x1-57011r16"/><strong>Figure 2.16</strong>: Posterior from <code>model_t </code>plotted using <code>az.plot_trace(idata_t)</code></p>&#13;
<p>Now, print the summary of <code>model_t</code>. You should get something like <em>Table <a href="#x1-57012r4">2.4</a></em>. Compare the results with those from <code>model_g</code>.</p>&#13;
<table id="TBL-5" class="tabular">&#13;
<tbody>&#13;
<tr id="TBL-5-1-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-5-1-1" class="td11" style="text-align: center; white-space: nowrap;"/>&#13;
<td id="TBL-5-1-2" class="td11" style="text-align: center; white-space: nowrap;">mean</td>&#13;
<td id="TBL-5-1-3" class="td11" style="text-align: center; white-space: nowrap;">sd</td>&#13;
<td id="TBL-5-1-4" class="td11" style="text-align: center; white-space: nowrap;">hdi_3%</td>&#13;
<td id="TBL-5-1-5" class="td11" style="text-align: center; white-space: nowrap;">hdi_97%</td>&#13;
</tr>&#13;
<tr id="TBL-5-2-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-5-2-1" class="td11" style="text-align: center; white-space: nowrap;"><em>μ</em></td>&#13;
<td id="TBL-5-2-2" class="td11" style="text-align: center; white-space: nowrap;">53.02</td>&#13;
<td id="TBL-5-2-3" class="td11" style="text-align: center; white-space: nowrap;">0.39</td>&#13;
<td id="TBL-5-2-4" class="td11" style="text-align: center; white-space: nowrap;">52.27</td>&#13;
<td id="TBL-5-2-5" class="td11" style="text-align: center; white-space: nowrap;">53.71</td>&#13;
</tr>&#13;
<tr id="TBL-5-3-" class="odd" style="vertical-align:baseline;">&#13;
<td id="TBL-5-3-1" class="td11" style="text-align: center; white-space: nowrap;"><em>σ</em></td>&#13;
<td id="TBL-5-3-2" class="td11" style="text-align: center; white-space: nowrap;">2.21</td>&#13;
<td id="TBL-5-3-3" class="td11" style="text-align: center; white-space: nowrap;">0.42</td>&#13;
<td id="TBL-5-3-4" class="td11" style="text-align: center; white-space: nowrap;">1.46</td>&#13;
<td id="TBL-5-3-5" class="td11" style="text-align: center; white-space: nowrap;">3.01</td>&#13;
</tr>&#13;
<tr id="TBL-5-4-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-5-4-1" class="td11" style="text-align: center; white-space: nowrap;"><em>ν</em></td>&#13;
<td id="TBL-5-4-2" class="td11" style="text-align: center; white-space: nowrap;">4.94</td>&#13;
<td id="TBL-5-4-3" class="td11" style="text-align: center; white-space: nowrap;">5.45</td>&#13;
<td id="TBL-5-4-4" class="td11" style="text-align: center; white-space: nowrap;">1.07</td>&#13;
<td id="TBL-5-4-5" class="td11" style="text-align: center; white-space: nowrap;">10.10</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="IMG---Caption"><span id="x1-57012r4"/> <span id="x1-57013"/><strong>Table 2.4</strong>: Summary statistics for <em>μ</em>, <em>σ</em>, and <em>ν</em></p>&#13;
<p>Before you keep reading, take a moment to compare the preceding results with those from <code>model_g </code>and spot the difference between both results. Did you notice something interesting?</p>&#13;
<p>The estimation of <em>μ</em> between both models is similar, with a difference of <span class="cmsy-10x-x-109">≈ </span>0<em>.</em>5. The estimation of <em>σ</em> is <span class="cmsy-10x-x-109">≈ </span>3<em>.</em>5 for <code>model_g </code>and <span class="cmsy-10x-x-109">≈ </span>2<em>.</em>2 for <code>model_t</code>. This is a consequence of the Student’s t-distribution allocating less weight to values away from the mean. Loosely speaking, the Student’s t-distribution is <em>less surprised</em> by values away from the mean. We can also see that the mean of <em>ν</em> is <span class="cmsy-10x-x-109">≈ </span>5, meaning that we have a heavy-tailed distribution and not a Gaussian-like distribution.</p>&#13;
<p><em>Figure <a href="#x1-57014r17">2.17</a></em> shows a posterior predictive check for <code>model_t</code>. Let’s compare it with the one from <code>model_g </code>(<em>Figure <a href="#x1-54009r13">2.13</a></em>). Using the Student’s t-distribution in our model leads to predictive samples that seem to better fit the data in terms of the location of the peak of the distribution and also its spread. Notice how the samples extend far away from the bulk of the data, and how a few of the predictive samples look very flat. This is a direct consequence of the Student’s t-distribution expecting to see data points far away from the mean or bulk of the data. If you check the code used to generate <em>Figure <a href="#x1-57014r17">2.17</a></em> you will see that we have used <code>ax.set_xlim(40, 70)</code>.</p>&#13;
<div class="IMG---Figure">&#13;
<img src="../media/file80.png" alt="PIC"/>&#13;
</div>&#13;
<p class="IMG---Caption"><span id="x1-57014r17"/><strong>Figure 2.17</strong>: Posterior predictive check for <code>model_t</code></p>&#13;
<p>The Student’s t-distribution allows us to have a more <strong>robust estimation</strong> of the mean and standard deviation because the outliers have the effect of decreasing <em>ν</em> instead of pulling the mean or increasing the standard deviation. Thus, the mean and the scale are estimated by weighting the data points close to the bulk more than those apart from it. As a rule of thumb, for values of <em>ν &gt;</em> 2 and <em>not too small</em>, we can consider the scale of a Student’s t-distribution as a reasonable practical proxy for the standard deviation of the data after removing outliers. This is a rule of thumb because we know that the scale is not the standard deviation. <span id="x1-57015r107"/></p>&#13;
</section>&#13;
</section>&#13;
<section id="inferencedata" class="level3 sectionHead" data-number="1.6.7">&#13;
<h2 class="sectionHead" data-number="1.6.7">2.7 <span id="x1-580007"/>InferenceData</h2>&#13;
<p><span id="dx1-58001"/></p>&#13;
<p>InferenceData is a rich container for the results of Bayesian inference. A modern Bayesian analysis potentially generates many sets of data including posterior samples and posterior predictive samples. But we also have observed data, samples from the prior, and even statistics generated by the sampler. All this data, and more, can be stored in an InferenceData object. To help keep all this information organized, each one of these sets of data has its own group. For instance, the posterior samples are stored in the <code>posterior </code>group. The observed data is stored in the <code>observed_data</code> group.</p>&#13;
<p><em>Figure <a href="#x1-58002r18">2.18</a></em> shows an HTML representation of the InferenceData for <code>model_g</code>. We can see 4 groups: <code>posterior</code>, <code>posterior_predictive</code>, <code>sample_stats</code>, and <code>observed_data</code>. All of them are collapsed except for the <code>posterior </code>group. We can see we have two coordinates <code>chain </code>and <code>draw</code> of dimensions 4 and 1000 respectively. We also have 2 variables <em>μ</em> and <em>σ</em>.</p>&#13;
<div class="IMG---Figure">&#13;
<img src="../media/file81.png" alt="PIC"/>&#13;
</div>&#13;
<p class="IMG---Caption"><span id="x1-58002r18"/><strong>Figure 2.18</strong>: InferenceData object for <code>model_g</code></p>&#13;
<p>So far, PyMC has generated an InferenceData object and ArviZ has used that to generate plots or numerical summaries. But we can also manipulate an InferenceData object. Some common operations are to access specific groups. For instance, to access the posterior group we can write:</p>&#13;
<p><span id="x1-58003r17"/> <span id="x1-58004"/><strong>Code 2.17</strong></p>&#13;
<pre id="listing-26" class="source-code"><code>posterior = idata_g.posterior</code></pre>&#13;
<p>This will return an xarray dataset. If you are not familiar with xarray [<a href="Bibliography.xhtml#Xxarray_2017">Hoyer and Hamman</a>, <a href="Bibliography.xhtml#Xxarray_2017">2017</a>] ( <a href="https://docs.xarray.dev/en/stable/" class="url">https://docs.xarray.dev/en/stable/</a>), imagine NumPy multidimensional arrays but with labels! This makes many operations easier as you don’t have to remember the order of the dimensions. For example, the following code will return the first draw from chain 0 and chain 2:</p>&#13;
<p><span id="x1-58006r18"/> <span id="x1-58007"/><strong>Code 2.18</strong></p>&#13;
<pre id="listing-27" class="source-code"><code>posterior.sel(draw=0, chain=[0, 2])</code></pre>&#13;
<p>We use the <code>sel </code>method to select a range of values, like the first 100 draws from all chains:</p>&#13;
<p><span id="x1-58009r19"/> <span id="x1-58010"/><strong>Code 2.19</strong></p>&#13;
<pre id="listing-28" class="source-code"><code>posterior.sel(draw=slice(0, 100))</code></pre>&#13;
<p>Additionally, the following returns the mean for <em>μ</em> and <em>σ</em> computed over all draws and chains:</p>&#13;
<p><span id="x1-58012r20"/> <span id="x1-58013"/><strong>Code 2.20</strong></p>&#13;
<pre id="listing-29" class="source-code"><code>posterior.mean()</code></pre>&#13;
<p>Meanwhile, the following code returns the mean over the draws, i.e., this returns four values for <em>μ</em> and four values for <em>σ</em>, one per chain:</p>&#13;
<p><span id="x1-58015r21"/> <span id="x1-58016"/><strong>Code 2.21</strong></p>&#13;
<pre id="listing-30" class="source-code"><code>posterior.mean("draw")</code></pre>&#13;
<p>More often than not, we don’t care about chains and draws, we just want to get the posterior samples. In those cases, we can use the <code>az.extract</code> function:</p>&#13;
<p><span id="x1-58018r22"/> <span id="x1-58019"/><strong>Code 2.22</strong></p>&#13;
<pre id="listing-31" class="source-code"><code>stacked = az.extract(idata_g)</code></pre>&#13;
<p>This combines the <code>chain </code>and <code>draw </code>into a <code>sample </code>coordinate which can make further operations easier. By default, <code>az.extract </code>works on the posterior, but you can specify other groups with the <code>group </code>argument. You can also use <code>az.extract </code>to get a random sample of the posterior:</p>&#13;
<p><span id="x1-58021r23"/> <span id="x1-58022"/><strong>Code 2.23</strong></p>&#13;
<pre id="listing-32" class="source-code"><code>az.extract(idata_g, num_samples=100)</code></pre>&#13;
<p>We are going to use the InferenceData object all the time in this book, so you will have the time to get familiar with it and learn more about it in the coming pages. <span id="x1-58024r113"/></p>&#13;
</section>&#13;
<section id="groups-comparison" class="level3 sectionHead" data-number="1.6.8">&#13;
<h2 class="sectionHead" data-number="1.6.8">2.8 <span id="x1-590008"/>Groups comparison</h2>&#13;
<p><span id="dx1-59001"/></p>&#13;
<p>One pretty common statistical analysis is group comparison. We may be interested in how well patients respond to a certain drug, the reduction of car accidents by the introduction of new traffic regulations, student performance under different teaching approaches, and so on. Sometimes, this type of question is framed under the hypothesis testing scenario and the goal is to declare a result <em>statistically significant</em>. Relying only on statistical significance can be problematic for many reasons: on the one hand, statistical significance is not equivalent to practical significance; on the other hand, a really small effect can be declared significant just by collecting enough data.</p>&#13;
<p>The idea of hypothesis testing is connected to the concept of p-values. This is not a fundamental connection but a cultural one; people are used to thinking that way mostly because that’s what they learn in most introductory statistical courses. There is a long record of studies and essays showing that, more often than not, p-values are used and interpreted the wrong way, even by people who are using them daily. Instead of doing hypothesis testing, we are going to take a different route and we are going to focus on estimating the effect size, that is, quantifying the difference between two groups. One advantage of thinking in terms of effect size is that we move away from yes-no questions like ”Does it work?” or ”Is there any effect?” and into the more nuanced type of questions like ”How well does it work?” or ”How large is the effect?”.</p>&#13;
<p>Sometimes, when comparing groups, people talk about a control group and a treatment group. For example, when we want to test a new drug, we want to compare the new drug (the treatment) against a placebo (the control group). The placebo effect is a psychological phenomenon where a patient experiences perceived improvements in their symptoms or condition after receiving an inactive substance or treatment. By comparing the effects of the drug with a placebo group in clinical trials, researchers can discern whether the drug is genuinely effective. The placebo effect is an example of the broader challenge in experimental design and statistical analysis of the difficulty of accounting for all factors in an experiment.</p>&#13;
<p>One interesting alternative to this design is to compare the new drug with the commercially available most popular or efficient drug to treat that illness. In such a case, the control group cannot be a placebo; it should be the other drug. Bogus control groups are a splendid way to lie using statistics.</p>&#13;
<p>For example, imagine you work for a dairy product company that wants to sell overly sugared yogurts to kids by telling their dads and moms that this particular yogurt boosts the immune system or helps their kids grow stronger. One way to cheat with data is by using milk or even water as a control group, instead of another cheaper, less sugary, less marketed yogurt. It may sound silly when I put it this way, but I am describing actual experiments published in actual scientific journals. When someone says something is harder, better, faster, or stronger, remember to ask what the baseline used for the comparison was. <span id="x1-59002r109"/></p>&#13;
<section id="the-tips-dataset" class="level4 subsectionHead" data-number="1.6.8.1">&#13;
<h3 class="subsectionHead" data-number="1.6.8.1">2.8.1 <span id="x1-600001"/>The tips dataset</h3>&#13;
<p><span id="dx1-60001"/> <span id="dx1-60002"/></p>&#13;
<p>To explore the subject matter of this section, we are going to use the tips dataset [<a href="Bibliography.xhtml#Xbryant_1995">Bryant and Smith</a>, <a href="Bibliography.xhtml#Xbryant_1995">1995</a>]. We want to study the effect of the day of the week on the tips earned at a restaurant. For this example, the different groups are the days. Notice there is no control group or treatment group. If we wish, we can arbitrarily establish one day (for example, Thursday) as the reference or control. For now, let’s start the analysis by loading the dataset as a pandas DataFrame using just one line of code. If you are not familiar with pandas, the <code>tail </code>command is used to show the last rows of a DataFrame (see <em>Table <a href="#x1-60007r5">2.5</a></em>), you may want to try using <code>head</code>:</p>&#13;
<p><span id="x1-60003r24"/> <span id="x1-60004"/><strong>Code 2.24</strong></p>&#13;
<pre id="listing-33" class="source-code"><code>tips = pd.read_csv("data/tips.csv") </code>&#13;
<code>tips.tail()</code></pre>&#13;
<table id="TBL-6" class="tabular">&#13;
<tbody>&#13;
<tr id="TBL-6-1-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-6-1-1" class="td11" style="text-align: center; white-space: nowrap;"/>&#13;
<td id="TBL-6-1-2" class="td11" style="text-align: center; white-space: nowrap;">total_bill</td>&#13;
<td id="TBL-6-1-3" class="td11" style="text-align: center; white-space: nowrap;">tip</td>&#13;
<td id="TBL-6-1-4" class="td11" style="text-align: center; white-space: nowrap;">sex</td>&#13;
<td id="TBL-6-1-5" class="td11" style="text-align: center; white-space: nowrap;">smoker</td>&#13;
<td id="TBL-6-1-6" class="td11" style="text-align: center; white-space: nowrap;">day</td>&#13;
<td id="TBL-6-1-7" class="td11" style="text-align: center; white-space: nowrap;">time</td>&#13;
<td id="TBL-6-1-8" class="td11" style="text-align: center; white-space: nowrap;">size</td>&#13;
</tr>&#13;
<tr id="TBL-6-2-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-6-2-1" class="td11" style="text-align: center; white-space: nowrap;">239</td>&#13;
<td id="TBL-6-2-2" class="td11" style="text-align: center; white-space: nowrap;">29.03</td>&#13;
<td id="TBL-6-2-3" class="td11" style="text-align: center; white-space: nowrap;">5.92</td>&#13;
<td id="TBL-6-2-4" class="td11" style="text-align: center; white-space: nowrap;">Male</td>&#13;
<td id="TBL-6-2-5" class="td11" style="text-align: center; white-space: nowrap;">No</td>&#13;
<td id="TBL-6-2-6" class="td11" style="text-align: center; white-space: nowrap;">Sat</td>&#13;
<td id="TBL-6-2-7" class="td11" style="text-align: center; white-space: nowrap;">Dinner</td>&#13;
<td id="TBL-6-2-8" class="td11" style="text-align: center; white-space: nowrap;">3</td>&#13;
</tr>&#13;
<tr id="TBL-6-3-" class="odd" style="vertical-align:baseline;">&#13;
<td id="TBL-6-3-1" class="td11" style="text-align: center; white-space: nowrap;">240</td>&#13;
<td id="TBL-6-3-2" class="td11" style="text-align: center; white-space: nowrap;">27.18</td>&#13;
<td id="TBL-6-3-3" class="td11" style="text-align: center; white-space: nowrap;">2.00</td>&#13;
<td id="TBL-6-3-4" class="td11" style="text-align: center; white-space: nowrap;">Female</td>&#13;
<td id="TBL-6-3-5" class="td11" style="text-align: center; white-space: nowrap;">Yes</td>&#13;
<td id="TBL-6-3-6" class="td11" style="text-align: center; white-space: nowrap;">Sat</td>&#13;
<td id="TBL-6-3-7" class="td11" style="text-align: center; white-space: nowrap;">Dinner</td>&#13;
<td id="TBL-6-3-8" class="td11" style="text-align: center; white-space: nowrap;">2</td>&#13;
</tr>&#13;
<tr id="TBL-6-4-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-6-4-1" class="td11" style="text-align: center; white-space: nowrap;">241</td>&#13;
<td id="TBL-6-4-2" class="td11" style="text-align: center; white-space: nowrap;">22.67</td>&#13;
<td id="TBL-6-4-3" class="td11" style="text-align: center; white-space: nowrap;">2.00</td>&#13;
<td id="TBL-6-4-4" class="td11" style="text-align: center; white-space: nowrap;">Male</td>&#13;
<td id="TBL-6-4-5" class="td11" style="text-align: center; white-space: nowrap;">Yes</td>&#13;
<td id="TBL-6-4-6" class="td11" style="text-align: center; white-space: nowrap;">Sat</td>&#13;
<td id="TBL-6-4-7" class="td11" style="text-align: center; white-space: nowrap;">Dinner</td>&#13;
<td id="TBL-6-4-8" class="td11" style="text-align: center; white-space: nowrap;">2</td>&#13;
</tr>&#13;
<tr id="TBL-6-5-" class="odd" style="vertical-align:baseline;">&#13;
<td id="TBL-6-5-1" class="td11" style="text-align: center; white-space: nowrap;">242</td>&#13;
<td id="TBL-6-5-2" class="td11" style="text-align: center; white-space: nowrap;">17.82</td>&#13;
<td id="TBL-6-5-3" class="td11" style="text-align: center; white-space: nowrap;">1.75</td>&#13;
<td id="TBL-6-5-4" class="td11" style="text-align: center; white-space: nowrap;">Male</td>&#13;
<td id="TBL-6-5-5" class="td11" style="text-align: center; white-space: nowrap;">No</td>&#13;
<td id="TBL-6-5-6" class="td11" style="text-align: center; white-space: nowrap;">Sat</td>&#13;
<td id="TBL-6-5-7" class="td11" style="text-align: center; white-space: nowrap;">Dinner</td>&#13;
<td id="TBL-6-5-8" class="td11" style="text-align: center; white-space: nowrap;">2</td>&#13;
</tr>&#13;
<tr id="TBL-6-6-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-6-6-1" class="td11" style="text-align: center; white-space: nowrap;">243</td>&#13;
<td id="TBL-6-6-2" class="td11" style="text-align: center; white-space: nowrap;">18.78</td>&#13;
<td id="TBL-6-6-3" class="td11" style="text-align: center; white-space: nowrap;">3.00</td>&#13;
<td id="TBL-6-6-4" class="td11" style="text-align: center; white-space: nowrap;">Female</td>&#13;
<td id="TBL-6-6-5" class="td11" style="text-align: center; white-space: nowrap;">No</td>&#13;
<td id="TBL-6-6-6" class="td11" style="text-align: center; white-space: nowrap;">Thurs</td>&#13;
<td id="TBL-6-6-7" class="td11" style="text-align: center; white-space: nowrap;">Dinner</td>&#13;
<td id="TBL-6-6-8" class="td11" style="text-align: center; white-space: nowrap;">2</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="IMG---Caption"><span id="x1-60007r5"/> <span id="x1-60008"/><strong>Table 2.5</strong>: Sample data from a restaurant</p>&#13;
<p>From this DataFrame, we are only going to use the day and tip columns. <em>Figure <a href="#x1-60009r19">2.19</a></em> shows the distributions of this data using ridge plots. This figure was done with ArviZ. Even though ArviZ is designed for Bayesian model analysis, some of its functions can be useful for data analysis.</p>&#13;
<div class="IMG---Figure">&#13;
<img src="../media/file82.png" alt="PIC"/>&#13;
</div>&#13;
<p class="IMG---Caption"><span id="x1-60009r19"/><strong>Figure 2.19</strong>: Distribution of tips by day</p>&#13;
<p>We are going to do some small preprocessing of the data. First, we are going to create the <code>tip </code>variable representing the tips in dollars. Then we create the <code>idx </code>variable, a categorical dummy variable encoding the days with numbers, that is, <code>[0, 1, 2, 3] </code>instead of <code>[’Thur’, ’Fri’, ’Sat’, ’Sun’]</code>.</p>&#13;
<p><span id="x1-60010r25"/> <span id="x1-60011"/><strong>Code 2.25</strong></p>&#13;
<pre id="listing-34" class="source-code"><code>categories = np.array(["Thur", "Fri", "Sat", "Sun"]) </code>&#13;
<code>tip = tips["tip"].values </code>&#13;
<code>idx = pd.Categorical(tips["day"], categories=categories).codes</code></pre>&#13;
<p>The model for this problem is almost the same as <code>model_g</code>; the only difference is that now <em>μ</em> and <em>σ</em> are going to be vectors instead of scalars. PyMC syntax is extremely helpful for this situation: instead of writing for loops, we can write our model in a vectorized way.</p>&#13;
<p><span id="x1-60015r26"/> <span id="x1-60016"/><strong>Code 2.26</strong></p>&#13;
<pre id="listing-35" class="source-code"><code>with pm.Model() as comparing_groups: </code>&#13;
<code>    μ = pm.Normal("μ", mu=0, sigma=10, shape=4) </code>&#13;
<code>    σ = pm.HalfNormal("σ", sigma=10, shape=4) </code>&#13;
<code> </code>&#13;
<code>    y = pm.Normal("y", mu=μ[idx], sigma=σ[idx], observed=tip)</code></pre>&#13;
<p>Notice how we passed a <code>shape </code>argument for the prior distribution. For <em>μ</em>, this means that we are specifying four independent <span class="cmsy-10x-x-109"><img src="../media/N.PNG" style="width:1.4em; vertical-align: -0.30em;"/></span>(0<em>,</em>10) and for <em>σ</em> four independent <span class="cmsy-10x-x-109"><img src="../media/HN.PNG" style="width:2.2em; vertical-align: -0.10em"/></span>(10). Also, notice how we use the <code>idx </code>variable to properly index the values of <em>μ</em> and <em>σ</em> we pass to the likelihood.</p>&#13;
<p>PyMC provides an alternative syntax, which consists of specifying coordinates and dimensions. The advantage of this alternative is that it allows better integration with ArviZ.</p>&#13;
<p>In this example, we have 4 values for the means and 4 for the standard deviations, and that’s why we use <code>shape=4</code>. The InferenceData will have 4 indices <code>0, 1, 2, 3 </code>mapping to each of the 4 days. However, it is the user’s job to associate those numerical indices with the days. By using coordinates and dimensions we, and ArviZ, can use the labels <code>"Thur", "Fri", "Sat", "Sun" </code>to easily map parameters to their associated days.</p>&#13;
<p>We are going to specify two coordinates; <code>"days"</code>, with the dimensions <code>"Thur", "Fri", "Sat", "Sun"</code>; and <code>"days_flat"</code>, which will contain the same labels but repeated according to the order and length that corresponds to each observation. <code>"days_flat" </code>will be useful later for posterior predictive tests.</p>&#13;
<p><span id="x1-60022r27"/> <span id="x1-60023"/><strong>Code 2.27</strong></p>&#13;
<pre id="listing-36" class="source-code"><code>coords = {"days": categories, "days_flat":categories[idx]} </code>&#13;
<code> </code>&#13;
<code>with pm.Model(coords=coords) as comparing_groups: </code>&#13;
<code>    μ = pm.HalfNormal("μ", sigma=5, dims="days") </code>&#13;
<code>    σ = pm.HalfNormal("σ", sigma=1, dims="days") </code>&#13;
<code> </code>&#13;
<code>    y = pm.Gamma("y", mu=μ[idx], sigma=σ[idx], observed=tip, dims="days_flat") </code>&#13;
<code> </code>&#13;
<code>    idata_cg = pm.sample() </code>&#13;
<code>    idata_cg.extend(pm.sample_posterior_predictive(idata_cg))</code></pre>&#13;
<p>Once the posterior distribution is computed, we can do all the analyses that we believe are pertinent. For instance, we can do a posterior predictive test. With the help of ArviZ, we can do it by calling <code>az.plot_ppc</code>. We use the <code>coords </code>and <code>flatten </code>parameters to get one subplot per day.</p>&#13;
<p><span id="x1-60034r28"/> <span id="x1-60035"/><strong>Code 2.28</strong></p>&#13;
<pre id="listing-37" class="source-code"><code>_, axes = plt.subplots(2, 2) </code>&#13;
<code>az.plot_ppc(idata_cg, num_pp_samples=100, </code>&#13;
<code>            coords={"days_flat":[categories]}, flatten=[], ax=axes)</code></pre>&#13;
<p>From the following figure, we can see that the model can capture the general shape of the distributions, but still, some details are elusive. This may be due to the relatively small sample size, factors other than day influencing the tips, or a combination of both.</p>&#13;
<div class="IMG---Figure">&#13;
<img src="../media/file83.png" alt="PIC"/>&#13;
</div>&#13;
<p class="IMG---Caption"><span id="x1-60039r20"/><strong>Figure 2.20</strong>: Posterior predictive checks for the tips dataset</p>&#13;
<p>For now, we are going to consider that the model is good enough for us and move to explore the posterior. We can explain the results in terms of their average values and then find for which days that average is higher. But there are other alternatives; for instance, we may want to express the results in terms of differences in posterior means. In addition, we might want to use some measure of effect size that is popular with our audiences, such as the probability of superiority or Cohen’s d. In the next sections, we explain these alternatives. <span id="x1-60040r129"/></p>&#13;
</section>&#13;
<section id="cohens-d" class="level4 subsectionHead" data-number="1.6.8.2">&#13;
<h3 class="subsectionHead" data-number="1.6.8.2">2.8.2 <span id="x1-610002"/>Cohen’s d</h3>&#13;
<p><span id="dx1-61001"/> <span id="dx1-61002"/></p>&#13;
<p>A common way to measure the effect size is Cohen’s d, which is defined as follows:</p>&#13;
<div class="math-display">&#13;
<img src="../media/file84.jpg" class="math-display" alt="-μ2 −-μ1 ∘ σ21+σ22- --2-- "/>&#13;
</div>&#13;
<p>Because we have a posterior distribution we can compute a distribution of Cohen’s d, and if we want a single value we can compute the mean or median of that distribution.</p>&#13;
<p>This expression tells us that the effect size is the difference between the means scaled by the pooled standard deviation of both groups. By taking the pooled standard deviation, we are standardizing the differences of means. This is important because when you have a difference of 1 and a standard deviation of 0.1, the effect size is larger than the same difference when the standard deviation is 10. A Cohen’s d can be interpreted as a Z-score (a standard score). A Z-score is the signed number of standard deviations by which a value differs from the mean value of what is being observed or measured. Thus, a value of 0.5 Cohen’s d could be interpreted as a difference of 0.5 standard deviations from one group to the other.</p>&#13;
<p>Even when the differences of means are standardized, we may still need to calibrate ourselves based on the context of a given problem to be able to say if a given value is big, small, medium, and so on. For instance, if we are used to performing several analyses for the same or similar problems, we can get used to a Cohen’s d of say 1. So when we get a Cohen’s d of say 2, we know that we have something important (or someone made a mistake somewhere!). If you do not have this practice yet, you can ask a domain expert for their valuable input.</p>&#13;
<p>A very nice web page to explore what different values of Cohen’s d look like is <a href="http://rpsychologist.com/d3/cohend" class="url">http://rpsychologist.com/d3/cohend</a>. On that page, you will also find other ways to express an effect size; some of them could be more intuitive, such as the probability of superiority, which we will discuss next. <span id="x1-61003r141"/></p>&#13;
</section>&#13;
<section id="probability-of-superiority" class="level4 subsectionHead" data-number="1.6.8.3">&#13;
<h3 class="subsectionHead" data-number="1.6.8.3">2.8.3 <span id="x1-620003"/>Probability of superiority</h3>&#13;
<p><span id="dx1-62001"/> <span id="dx1-62002"/></p>&#13;
<p>This is another way to report the effect size, and this is defined as the probability that a data point taken at random from one group has a larger value than one also taken at random from the other group. If we assume that the data we are using is normally distributed, we can compute the probability of superiority from Cohen’s d using the following expression:</p>&#13;
<div class="math-display">&#13;
<img src="../media/file85.jpg" class="math-display" alt=" ( δ ) ps = Φ √--- 2 "/>&#13;
</div>&#13;
<p>Φ is the cumulative Normal distribution and <em>δ</em> is the Cohen’s d.</p>&#13;
<p>If we are OK with the normality assumption, we can use this formula to get the probability of superiority from the value of Cohen’s d. Otherwise, we can compute the probability of superiority directly from the posterior samples just by taking random samples from two groups and counting how many times one value is larger than the other. To do that we don’t need Cohen’s d or assume normality (see the Exercises section). This is an example of an advantage of using <strong>Markov Chain Monte Carlo</strong> (<strong>MCMC</strong>) methods; once we get samples from the posterior, we can compute many quantities from it often in ways that are easier than with other methods. <span id="x1-62003r142"/></p>&#13;
</section>&#13;
<section id="posterior-analysis-of-mean-differences" class="level4 subsectionHead" data-number="1.6.8.4">&#13;
<h3 class="subsectionHead" data-number="1.6.8.4">2.8.4 <span id="x1-630004"/>Posterior analysis of mean differences</h3>&#13;
<p><span id="dx1-63001"/> <span id="dx1-63002"/></p>&#13;
<p>To conclude our previous discussions, let’s compute the posterior distributions for differences in means, Cohen’s d, and the probability of superiority, and integrate them into a single plot. <em>Figure <a href="#x1-63003r21">2.21</a></em> has a lot of information. Depending on the audience, the plot may be overloaded, or too crowded. Perhaps it is useful for a discussion within your team, but for the general public, it may be convenient to remove elements or distribute the information between a figure and a table or two figures. Anyway, here we show it precisely so you can compare different ways of presenting the same information, so take some time to ponder this figure.</p>&#13;
<div class="IMG---Figure">&#13;
<img src="../media/file86.png" alt="PIC"/>&#13;
</div>&#13;
<p class="IMG---Caption"><span id="x1-63003r21"/><strong>Figure 2.21</strong>: Posterior distributions of the differences of means, Cohen’s d, and the probability of superiority for the tips dataset</p>&#13;
<p>One way to read <em>Figure <a href="#x1-63003r21">2.21</a></em> is to compare the reference value, of zero difference, with the HDI interval. We have only one case when the 94% HDI excludes the reference value, that is, the difference in tips between Thursday and Sunday. For all the other comparisons, we cannot rule out a difference of zero, at least according to the HDI-reference-value-overlap criteria. But even for that case, the average difference is <span class="cmsy-10x-x-109">≈ </span>0<em>.</em>5 dollars. Is that difference large enough? Is that difference enough to accept working on Sunday and missing the opportunity to spend time with family or friends? Is that difference enough to justify averaging the tips over the four days and giving every waitress and waiter the same amount of tip money?</p>&#13;
<p>The short answer is that those kinds of questions cannot be answered by statistics; they can only be informed by statistics. I hope you don’t feel cheated by that answer, but we cannot get automatic answers unless we include in the analysis all the values that are important to the stakeholders. Formally, that requires the definition of a loss function or at least the definition of some threshold value for the effect size, which should be informed by those values. <span id="x1-63004r128"/></p>&#13;
</section>&#13;
</section>&#13;
<section id="summary-1" class="level3 sectionHead" data-number="1.6.9">&#13;
<h2 class="sectionHead" data-number="1.6.9">2.9 <span id="x1-640009"/>Summary</h2>&#13;
<p>Although Bayesian statistics is conceptually simple, fully probabilistic models often lead to analytically intractable expressions. For many years, this was a huge barrier, hindering the wide adoption of Bayesian methods. Fortunately, maths, statistics, physics, and computer science came to the rescue in the form of numerical methods that are capable—at least in principle—of solving any inference problem. The possibility of automating the inference process has led to the development of probabilistic programming languages, allowing a clear separation between model definition and inference. PyMC is a Python library for probabilistic programming with a very simple, intuitive, and easy-to-read syntax that is also very close to the statistical syntax used to describe probabilistic models.</p>&#13;
<p>We introduced the PyMC library by revisiting the coin-flip model from <em>Chapter <a href="CH01.xhtml#x1-160001">1</a></em>, this time without analytically deriving the posterior. PyMC models are defined inside a context manager. To add a probability distribution to a model, we just need to write a single line of code. Distributions can be combined and can be used as priors (unobserved variables) or likelihoods (observed variables). If we pass data to a distribution, it becomes a likelihood. Sampling can be achieved with a single line as well. PyMC allows us to get samples from the posterior distribution. If everything goes right, these samples will be representative of the correct posterior distribution and thus they will be a representation of the logical consequences of our model and data. We can explore the posterior generated by PyMC using ArviZ, a Python library that works hand-in-hand with PyMC and can be used, among other tasks, to help us interpret and visualize posterior distributions. One way of using a posterior to help us make inference-driven decisions is by comparing the ROPE against the HDI interval. We also briefly mentioned the notion of loss functions, a formal way to quantify the trade-offs and costs associated with making decisions in the presence of uncertainty. We learned that loss functions and point estimates are intimately associated.</p>&#13;
<p>Up to this point, the discussion was restricted to a simple one-parameter model. Generalizing to an arbitrary number of parameters is trivial with PyMC; we exemplify how to do this with the Gaussian and Student’s t models. The Gaussian distribution is a special case of the Student’s t-distribution and we showed you how to use the latter to perform robust inferences in the presence of outliers. In the next chapters, we will look at how these models can be used as part of linear regression models. We used a Gaussian model to compare groups. While this is sometimes framed in the context of hypothesis testing, we take another route and frame this task as a problem of inferring the effect size, an approach we generally consider to be richer and more productive. We also explored different ways to interpret and report effect sizes.</p>&#13;
<p>With all that we have learned in this and the previous chapter, we are ready to study one of the most important concepts in this book, hierarchical models. That will be the topic of the next chapter. <span id="x1-64001r144"/></p>&#13;
</section>&#13;
<section id="exercises-1" class="level3 sectionHead" data-number="1.6.10">&#13;
<h2 class="sectionHead" data-number="1.6.10">2.10 <span id="x1-6500010"/>Exercises</h2>&#13;
<ol>&#13;
<li><div id="x1-65002x1">&#13;
<p>Using PyMC, change the parameters of the prior Beta distribution in <code>our_first_model </code>to match those of the previous chapter. Compare the results to the previous chapter.</p>&#13;
</div></li>&#13;
<li><div id="x1-65004x2">&#13;
<p>Compare the model <code>our_first_model </code>with prior <em>θ</em> <span class="cmsy-10x-x-109">∼</span> Beta(1<em>,</em>1) with a model with prior <em>θ</em> <span class="cmsy-10x-x-109">∼<img src="../media/U.PNG" style="width:1.4em; vertical-align: -0.30em;"/></span>(0<em>,</em>1). Are the posteriors similar or different? Is the sampling slower, faster, or the same? What about using a Uniform over a different interval such as [-1, 2]? Does the model run? What errors do you get?</p>&#13;
</div></li>&#13;
<li><div id="x1-65006x3">&#13;
<p>PyMC has a function <code>pm.model_to_graphviz  </code>that can be used to visualize the model. Use it to visualize the model <code>our_first_model</code>. Compare the result with the Kruschke diagram. Use <code>pm.model_to_graphviz </code>to visualize model <code>comparing_groups</code>.</p>&#13;
</div></li>&#13;
<li><div id="x1-65008x4">&#13;
<p>Read about the coal mining disaster model that is part of the PyMC documentation ( <a href="https://shorturl.at/hyCX2" class="url">https://shorturl.at/hyCX2</a>). Try to implement and run this model by yourself.</p>&#13;
</div></li>&#13;
<li><div id="x1-65010x5">&#13;
<p>Modify <code>model_g</code>, change the prior for the mean to a Gaussian distribution centered at the empirical mean, and play with a couple of reasonable values for the standard deviation of this prior. How robust/sensitive are the inferences to these changes? What do you think of using a Gaussian, which is an unbounded distribution (goes from <span class="cmsy-10x-x-109">−</span>inf to inf), to model bounded data such as this? Remember that we said it is not possible to observe values below 0 or above 100.</p>&#13;
</div></li>&#13;
<li><div id="x1-65012x6">&#13;
<p>Using the data from the <code>chemical_shifts.csv </code>file, compute the empirical mean and the standard deviation with and without outliers. Compare those results to the Bayesian estimation using the Gaussian and Student’s t-distribution. What do you observe?</p>&#13;
</div></li>&#13;
<li><div id="x1-65014x7">&#13;
<p>Repeat the previous exercise by adding more outliers to <code>chemical_shifts.csv</code>, and compute new posteriors for <code>model_g </code>and <code>model_t </code>using this new data. What do you observe?</p>&#13;
</div></li>&#13;
<li><div id="x1-65016x8">&#13;
<p>Explore the InferenceData object <code>idata_cg</code>.</p>&#13;
<ul>&#13;
<li><p>How many groups does it contain?</p></li>&#13;
<li><p>Inspect the posterior distribution of the parameter <em>μ</em> for a specific day using the <code>sel </code>method.</p></li>&#13;
<li><p>Compute the distributions of mean differences between Thursday and Sunday. What are the coordinates and dimensions of the resulting DataArray?</p></li>&#13;
</ul>&#13;
</div></li>&#13;
<li><div id="x1-65018x9">&#13;
<p>For the tips example compute the probability of superiority directly from the posterior (without computing Cohen’s d first). You can use the <code>pm.sample_posterior_predictive() </code>function to take a sample from each group. Is it different from the calculation assuming normality? Can you explain the result?</p>&#13;
</div></li>&#13;
</ol>&#13;
</section>&#13;
<section id="join-our-community-discord-space-2" class="level3 likesectionHead" data-number="1.6.11">&#13;
<h2 class="likesectionHead" data-number="1.6.11"><span id="x1-6600010"/>Join our community Discord space</h2>&#13;
<p>Join our Discord community to meet like-minded people and learn alongside more than 5000 members at: <a href="https://packt.link/bayesian">https://packt.link/bayesian</a></p>&#13;
<p><img src="../media/file1.png" alt="PIC"/> <span id="x1-66001r63"/></p>&#13;
</section>&#13;
</section>&#13;
</body></html>