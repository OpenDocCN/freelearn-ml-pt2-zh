["```py\ndef posterior_grid(grid_points=50, heads=6, tails=9): \n    \"\"\" \n    A grid implementation for the coin-flipping problem \n    \"\"\" \n    grid = np.linspace(0, 1, grid_points) \n    prior = np.repeat(1/grid_points, grid_points)  # uniform prior \n    likelihood = pz.Binomial(n=heads+tails, p=grid).pdf(heads) \n    posterior = likelihood * prior \n    posterior /= posterior.sum() * (1/grid_points) \n    return grid, posterior\n```", "```py\ndata = pd.DataFrame(data, columns=[\"w\"]) \npriors = {\"Intercept\": bmb.Prior(\"Uniform\", lower=0, upper=1)} \nmodel = bmb.Model(\"w ∼ 1\", data=data, family=\"bernoulli\", priors=priors, \n                  link=\"identity\") \nresults = model.fit(draws=4000, inference_method=\"laplace\")\n```", "```py\ndef metropolis(dist, draws=1000): \n    \"\"\"A very simple Metropolis implementation\"\"\" \n    trace = np.zeros(draws) \n    old_x = 0.5 \n    old_prob = dist.pdf(old_x) \n\n    delta = np.random.normal(0, 0.5, draws) \n    for i in range(draws): \n        new_x = old_x + delta[i] \n        new_prob = dist.pdf(new_x) \n        acceptance = new_prob / old_prob \n        if acceptance >= np.random.random(): \n            trace[i] = new_x \n            old_x = new_x \n            old_prob = new_prob \n        else: \n            trace[i] = old_x \n    return trace\n```", "```py\nwith pm.Model() as model_c: \n    a = pm.HalfNormal('a', 10) \n    b = pm.Normal('b', 0, a, shape=10) \n    idata_cm = pm.sample(tune=2000) \n\nwith pm.Model() as model_nc: \n    a = pm.HalfNormal('a', 10) \n\n    b_offset = pm.Normal('b_offset', mu=0, sigma=1, shape=10) \n    b = pm.Deterministic('b', 0 + b_offset * a) \n    idata_ncm = pm.sample(tune=2000)\n```"]