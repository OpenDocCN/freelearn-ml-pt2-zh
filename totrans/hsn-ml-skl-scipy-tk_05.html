<html><head></head><body>
    <section>
      <header class="header-title chapter-title">
                    Preparing Your Data
                </header>
      <article>
        <p>In the previous chapter, we dealt with clean data, where all the values were available to us, all the columns had numeric values, and when faced with too many features, we had a regularization technique on our side. In real life, it will often be the case that the data is not as clean as you would like it to be. Sometimes, even clean data can still be preprocessed in ways to make things easier for our machine learning algorithm. In this chapter, we will learn about the following data preprocessing techniques:</p>
        <ul>
          <li>Imputing missing values</li>
          <li>Encoding non-numerical columns</li>
          <li>Changing the data distribution</li>
          <li>Reducing the number of features via selection</li>
          <li>Projecting data into new dimensions</li>
        </ul>
        <h1 id="uuid-313197f3-6357-4d8e-be64-90b3ff5a233a">Imputing missing values</h1>
        <div class="packt_quote">"It is a capital mistake to theorize before one has data."</div>
        <div class="packt_quote CDPAlignRight CDPAlign">– Sherlock Holmes</div>
        <p>To simulate a real-life scenario where the data has missing values, we will create a dataset with people's weights as a function of their height. Then, we will randomly remove 75% of the values in the <kbd>height</kbd> column and set them to <kbd>NaN</kbd>:</p>
        <pre>df = pd.DataFrame(<br/>    {<br/>        'gender': np.random.binomial(1, .6, 100),<br/>        'height': np.random.normal(0, 10, 100), <br/>        'noise': np.random.normal(0, 2, 100), <br/>    }<br/>)<br/><br/>df['height'] = df['height'] + df['gender'].apply(<br/>    lambda g: 150 if g else 180<br/>)<br/>df['height (with 75% NaN)'] = df['height'].apply(<br/>    lambda x: x if np.random.binomial(1, .25, 1)[0] else np.nan<br/>)<br/>df['weight'] = df['height'] + df['noise'] - 110</pre>
        <p>We used a random number generator with an underlying <strong>bino</strong><strong>mial</strong>/<strong>Bernoulli</strong><em><strong/></em>distribution here to decide whether each sample will be removed. The distribution's <em>n</em> value is set to <kbd>1</kbd>—that is, it is a Bernoulli distribution—and its <em>p</em> value is set to <kbd>0.25</kbd>—that is, each sample has a 25% chance of staying. Whenever the returned value of the generator is <kbd>0</kbd>, the sample is set to <kbd>NaN</kbd>. As you can see, due to the nature of the random generator, the final percentage of <kbd>NaN</kbd> values may be slightly more or less than 75%. </p>
        <p>Here are the first four rows of the DataFrame that we have just created. Only the <kbd>height</kbd> column, with the missing values, and the weights are shown here:</p>
        <p class="CDPAlignCenter CDPAlign">
          <img src="assets/f0490c7d-9a69-48d0-a630-f9ff69a63fcd.png" style="width:14.08em;"/>
        </p>
        <p>We can also check what percentage of each column has missing values by using the following code:</p>
        <pre>df.isnull().mean()</pre>
        <p>When I ran the previous line, 77% of the values were missing. Note that you may get a different ratio of missing values than the ones I've got here, thanks to the random number generator used. </p>
        <p>None of the regressors we have seen so far will accept this data with all the <kbd>NaN</kbd> values in it. Therefore, we need to convert those missing values into something. Deciding on which values to fill in place of the missing values is the job of the data imputation process.</p>
        <p>There are different kinds of imputation techniques. We are going to try them here and observe their effect on our weight estimations. Keep in mind that we happen to know the original <kbd>height</kbd> data without any missing values, and we know that using a ridge regressor on the original data gives us an MSE value of <kbd>3.4</kbd>. Let's keep this piece of information as a reference for now.</p>
        <h2 id="uuid-09e3e130-77c2-4fed-a9db-3e83a75249c4">Setting missing values to 0</h2>
        <p>One simple approach would be to set all the missing values to <kbd>0</kbd>. The following code will make our data usable once more:</p>
        <pre>df['height (75% zero imputed)'] = df['height (with 75% NaN)'].fillna(0)</pre>
        <p>Fitting a ridge regressor on the newly imputed column will give us an MSE value of <kbd>365</kbd>:</p>
        <pre>from sklearn.linear_model import Ridge<br/>from sklearn.metrics import mean_squared_error<br/><br/>reg = Ridge()<br/>x, y = df[['height (75% zero imputed)']], df['weight']<br/>reg.fit(x, y)<br/>mean_squared_error(y, reg.predict(x))</pre>
        <p>Although we were able to use the regressor, its error is huge compared to our reference scenario. To understand the effect of zero imputation, let's plot the imputed data and use the regressor's coefficients to see what kind of line it created after training. Let's also plot the original data for comparison. I am sure the code for generating the following graph is straightforward to you by now, so I'll skip it:</p>
        <p class="CDPAlignCenter CDPAlign">
          <img src="assets/695556d0-4d87-40c0-9bfa-cc6047a03ddd.png" style="width:47.92em;"/>
        </p>
        <p>We already know by now that a linear model is only capable of fitting a continuous straight line onto the data (or a hyperplane, in the case of higher dimensions). We also know that <kbd>0</kbd> is not a reasonable height for anyone. Nevertheless, with zero imputation, we introduced a bunch of values where the heights are <kbd>0</kbd> and the weights range between <kbd>10</kbd> and <kbd>90</kbd> or so. This obviously confused our regressor, as we can see in the right-hand side graph.</p>
        <div class="packt_tip">A non-linear regressor, such as a decision tree, will be able to deal with this problem much better than its linear counterpart. Actually, for tree-based models, I'd suggest you try replacing the missing values in <em>x</em> with values that don't exist in your data. For example, you may experiment with setting the height to <kbd>-1</kbd>, in this case. </div>
        <h2 id="uuid-d12ad89b-8d22-4071-a638-e216323a837f">Setting missing values to the mean</h2>
        <p>Another name for statistical mean is <em>expected value</em>. That's because the mean serves as a biased estimation of the data. Having that said, replacing missing values with the column's mean values sounds like a plausible idea.</p>
        <div class="packt_infobox">In this chapter, I am fitting a regressor on the entire dataset. I am not concerned about splitting the data into training and test sets here since I am mainly bothered with how the regressor behaves with imputation. Nevertheless, in real life, you will just want to learn the mean value of the training set and use it to impute the missing values for both the training and test sets.</div>
        <p>scikit-learn's <kbd>SimpleImputer</kbd> feature makes it possible to find out the mean value from the training set and use it to impute both the training and test sets. It does so by using our favorite <kbd>fit()</kbd> and <kbd>transform()</kbd> methods. But let's stick to a one-step <kbd>fit_transform()</kbd> function here since we only have one set:</p>
        <pre>from sklearn.impute import SimpleImputer<br/>imp = SimpleImputer(missing_values=np.nan, strategy='mean')<br/>df['height (75% mean imputed)'] = imp.fit_transform(<br/>    df[['height (with 75% NaN)']]<br/>)[:, 0]</pre>
        <p>We have a single column to impute here, which is why I used <kbd>[:, 0]</kbd> to access its values after imputation.</p>
        <p>A ridge regressor will give us an MSE value of <kbd>302</kbd>. To understand where this improvement came from, let's plot the model's decision and compare it to the previous one with zero imputation:</p>
        <p class="CDPAlignCenter CDPAlign">
          <img src="assets/98dbc89a-dd22-4eef-b614-ef2a182e3f81.png" style="width:51.00em;"/>
        </p>
        <p>Clearly, the model's decisions make more sense now. You can see how the dotted line coincides with the actual non-imputed data points.</p>
        <div class="packt_tip">In addition to using <strong>mean</strong> as a strategy, the algorithm can also find the <strong>median</strong> of the training data. The median is usually a better option if your data has outliers. In the case of non-numerical features, you should instead use the <kbd>most_frequent</kbd> option as your strategy. </div>
        <h2 id="uuid-4a0e9ed4-e321-4b59-8c7d-fb444b0235df">Using informed estimations for missing values</h2>
        <p>Using a single value for all missing values may not be ideal. For example, we know here that our data includes male and female samples and each sub-sample has a different average height. The <kbd>IterativeImputer()</kbd> method is an algorithm that can use neighboring features to estimate the missing values in a certain feature. Here, we use the gender information to infer values to use when imputing the missing heights:</p>
        <pre># We need to enable the module first since it is an experimental one <br/>from sklearn.experimental import enable_iterative_imputer<br/>from sklearn.impute import IterativeImputer<br/>imp = IterativeImputer(missing_values=np.nan)<br/>df['height (75% iterative imputed)'] = imp.fit_transform(<br/>    df[['height (with 75% NaN)', 'gender']]<br/>)[:, 0]</pre>
        <p>We now have two values to be used for imputation:</p>
        <p class="CDPAlignCenter CDPAlign">
          <img src="assets/2605aa12-8ccd-478a-9c1a-a2de70a0a91d.png" style="width:22.67em;"/>
        </p>
        <p>The MSE value is <kbd>96</kbd> this time. This strategy is the clear winner here.</p>
        <p>We only had one feature with missing values here. In the case of multiple features, the <kbd>IterativeImputer()</kbd> method loops over all the features. It uses all the features but one to predict the missing values of the remaining one via regression. Once it is done looping over all the features, it may repeat the entire process more than once until the values converge. There are parameters to decide which regression algorithm to use, what order to use when looping over the features, and what the maximum number of iterations allowed is. Clearly, this strategy may be computationally expensive with bigger datasets and a higher number of incomplete features. Furthermore, the<kbd>IterativeImputer()</kbd> implementation is still experimental, and its API might change in the future.</p>
        <div class="packt_tip">A column with too many missing values carries too little information for our estimate to use. We can try our best to impute those missing values; but nevertheless, dropping the entire column and not using it at all is sometimes the best option, especially if the majority of the values are missing.</div>
        <h1 id="uuid-b99706ef-103f-4c57-a36b-36ebb7dc243b">Encoding non-numerical columns</h1>
        <div class="packt_quote">"Every decoding is another encoding."</div>
        <div class="packt_quote CDPAlignRight CDPAlign">– <span class="authorOrTitle">David Lodge</span></div>
        <p>Non-numeric data is another issue that algorithm implementations cannot deal with. In addition to the core scikit-learn implementation, <kbd>scikit-learn-contrib</kbd> has a list of satellite projects. These projects provide additional tools to our data arsenal, and here is how they describe themselves:</p>
        <div class="packt_quote">"scikit-learn-contrib is a GitHub organization for gathering high-quality, scikit-learn - compatibleprojects. It also provides a template for establishing new scikit-learn compatible projects."</div>
        <p>We are going to use one of these projects here—<kbd>category_encoders</kbd>. This allows us to encode non-numerical data into different forms. First, we will install the library using the <kbd>pip</kbd> installer, as follows:</p>
        <pre>
          <strong>pip install category_encoders</strong>
        </pre>
        <p>Before jumping into the different encoding strategies, let's first create a fictional dataset to play with:</p>
        <pre>df = pd.DataFrame({<br/>    'Size': np.random.choice(['XS', 'S', 'M', 'L', 'XL', 'XXL'], 10),<br/>    'Brand': np.random.choice(['Nike', 'Puma', 'Adidas', 'Le Coq', 'Reebok'], 10),<br/>})</pre>
        <p>We will then split it into two equal halves:</p>
        <pre>from sklearn.model_selection import train_test_split<br/>df_train, df_test = train_test_split(df, test_size=0.5)</pre>
        <div class="packt_infobox">Keep in mind that the core scikit-learn library implements two of the encoders we are going to see here—<kbd>preprocessing.OneHotEncoder</kbd> and <kbd>preprocessing.OrdinalEncoder</kbd>. Nevertheless, I prefer the <kbd>category_encoders</kbd> implementation for its richness and versatility. </div>
        <p>Now, on to our first, and most popular, encoding strategy—one-hot encoding.</p>
        <h2 id="uuid-8aa410da-7953-4bd2-83c8-33734341804f">One-hot encoding</h2>
        <p><strong>One-hot encoding</strong>, also known as dummy encoding, is the most common method for dealing with categorical features. If you have a column containing the <kbd>red</kbd>, <kbd>green</kbd>, and <kbd>blue</kbd> values, it sounds logical to convert them into three columns—<kbd>is_red</kbd>, <kbd>is_green</kbd>, and <kbd>is_blue</kbd>—and fill these columns with ones and zeroes, accordingly. </p>
        <p>Here is the code for decoding our datasets using <kbd>OneHotEncoder</kbd>:</p>
        <pre>from category_encoders.one_hot import OneHotEncoder<br/>encoder = OneHotEncoder(use_cat_names=True, handle_unknown='return_nan')<br/>x_train = encoder.fit_transform(df_train)<br/>x_test = encoder.transform(df_test)</pre>
        <p>I set <kbd>use_cat_names=True</kbd> to use the encoded values when assigning column names. The <kbd>handle_unknown</kbd> parameter tells the encoder how to deal with values in the test set that don't exist in the training set. For example, we have no clothing of the <kbd>XS</kbd> or <kbd>S</kbd>sizesin our training set. We also don't have any <kbd>Adidas</kbd> clothing in there. That's why these records in the test set are converted to<kbd>NaN</kbd>:</p>
        <p class="CDPAlignCenter CDPAlign">
          <img src="assets/6bd386a2-a300-4117-b707-13c8a1482737.png" style="width:41.83em;"/>
        </p>
        <p>You still have to impute those <kbd>NaN</kbd> values. Otherwise, we can just set those values to <kbd>0</kbd> by setting <kbd>handle_unknown</kbd> to <kbd>value</kbd>.</p>
        <div class="packt_tip">One-hot encoding is recommended for linear models and <strong>K-Nearest Neighbor</strong> (<strong>KNN</strong>) algorithms. Nevertheless, due to the fact that one column may be expanded into too many columns and some of them may be inter-dependent, regularization or feature selection are recommended here. We will look further at feature selection later in this chapter, and the KNN algorithm will be discussed later in this book. </div>
        <h2 id="uuid-a4fcc620-6bbb-42cb-8d7f-66657942443e">Ordinal encoding</h2>
        <p>Depending on your use case, you may need to encode your categorical values in a way that reflects their order. If I am going to use this data to predict the level of demand for the items, then I know that it isn't the case that the larger the item's size, the higher the demand for it. So, one-hot encoding may still be apt for the sizes here. However, if we are to predict the amount of material needed to create each item of clothing, then we need to encode the sizes in a way that implies that <kbd>XL</kbd> needs more material than <kbd>L</kbd>. In this case, we are concerned with the order of those values and so we use <kbd>OrdinalEncoder</kbd>, as follows:</p>
        <pre>from category_encoders.ordinal import OrdinalEncoder<br/><br/>oencoder = OrdinalEncoder(<br/>  mapping= [<br/>    {<br/>      'col': 'Size', <br/>      'mapping': {'XS': 1, 'S': 2, 'M': 3, 'L': 4, 'XL': 5}<br/>    }<br/>  ]<br/>)<br/><br/>df_train.loc[<br/>  :, 'Size [Ordinal Encoded]'<br/>] = oencoder.fit_transform(<br/>  df_train['Size']<br/>)['Size'].values<br/>df_test.loc[<br/>  :, 'Size [Ordinal Encoded]'<br/>] = oencoder.transform(<br/>  df_test['Size']<br/>)['Size'].values</pre>
        <p>Note that we have to specify the mapping by hand. We want <kbd>XS</kbd> to be encoded as <kbd>1</kbd>, <kbd>S</kbd> as <kbd>2</kbd>, and so on. As a result, we get the following DataFrame:</p>
        <p class="CDPAlignCenter CDPAlign">
          <img src="assets/5eacc447-36d8-47b3-a376-2a656401341c.png" style="width:18.08em;"/>
        </p>
        <p>This time, the encoded data fits into just one column, and the values missing from the training set are encoded as <kbd>-1</kbd>.</p>
        <div class="packt_tip">This encoding method is recommended for non-linear models, such as decision trees. As for linear models, they may interpret <kbd>XL</kbd> (encoded as <kbd>5</kbd>) to be five times the size of <kbd>XS</kbd> (encoded as <kbd>1</kbd>). That's why one-hot encoding is still preferred for linear models. Furthermore, coming up with meaningful mappings and setting it by hand can be time-consuming. </div>
        <h2 id="uuid-b92c6b40-2e83-4d40-86eb-b90aa98a20c5">Target encoding</h2>
        <p>One obvious way to encode categorical features, in a supervised learning scenario, is to base the encoding on the target values. Say we want to estimate the price of an item of clothing. We can replace the brand names with the average price for all items of the same brand in our training dataset. Nevertheless, there is one obvious problem here. Say one brand happens to appear only once or twice in our training set. There is no guarantee that these few appearances are good representations of the brand's price. In another world, using the target values just like that may result in overfitting, and the resulting model may not generalize well when dealing with new data. That's why the <kbd>category_encoders</kbd> library has multiple variations of target encoding; they all have the same underlying objective, but each of them has a different method for dealing with the aforementioned overfitting issue. Here are some examples of these implementations:</p>
        <ul>
          <li>Leave-one-out cross-validation</li>
          <li>The target encoder</li>
          <li>The catboost encoder</li>
          <li>The M-estimator</li>
        </ul>
        <p>Leave-one-out is probably the most well-known implementation of the ones listed. In the training data, it replaces the categorical value in raw data with the mean of the corresponding target values of all the rows with the same categorical value except for this particular raw data. For the test data, it just uses the mean of the corresponding targets of each category value learned from the training data. Furthermore, the encoder also has a parameter called <kbd>sigma</kbd>, which allows you to add noise to the learned mean to prevent even moreoverfitting.</p>
        <h1 id="uuid-e21ad932-2571-406c-b9e0-5dc9430187b8">Homogenizing the columns' scale</h1>
        <p>Different numerical columns may have different scales. One column's age is in the tens, while its salary is typically in the thousands. As we saw earlier, putting different columns into a similar scale helps in some cases. Here are some of the cases where scaling is recommended:</p>
        <ul>
          <li>It allows gradient-descent solvers to converge quicker.</li>
          <li>It is needed for algorithms such as KNN and <strong>Principle Component Analysis</strong> (<strong>PCA</strong>)</li>
          <li>When training an estimator, it puts the features on a comparable scale, which helps when juxtaposing their learned coefficients.</li>
        </ul>
        <p>In the next sections, we are going to examine the most commonly used scalers.</p>
        <h2 id="uuid-a7ec3bcd-d813-4c07-8da0-d205c8e57770">The standard scaler</h2>
        <p>This converts the features into normal distribution by setting their mean to <kbd>0</kbd> and their standard deviation to <kbd>1</kbd>. This is done using the following operation, where a column's mean value is subtracted from each value in it, and then the result is divided by the column'sstandard deviation value:</p>
        <p class="CDPAlignCenter CDPAlign">
          <img class="fm-editor-equation" src="assets/03fc9e7e-443a-43d5-a663-7d920b2f9413.png" style="width:12.83em;"/>
        </p>
        <p>The scaler's implementation can be used as follows:</p>
        <pre>from sklearn.preprocessing import StandardScaler<br/><br/>scaler = StandardScaler()<br/>x_train_scaled = scaler.fit_transform(x_train)<br/>x_test_scaled = scaler.transform(x_test)</pre>
        <p>Once fitted, you can also find out the mean and variance for each column in the training data via the <kbd>mean_</kbd> and <kbd>var_</kbd> attributes. In the presence of outliers, the standard scaler does not guarantee balanced feature scales. </p>
        <h2 id="uuid-2786ec3c-e2a6-40aa-a7b2-ab62c1a0c22c">The MinMax scaler</h2>
        <p>This squeezes the features into a certain range, typically between <kbd>0</kbd> and <kbd>1</kbd>. If you need to use a different range, you can set it using the <kbd>feature_range</kbd> parameter. This scaler works as follows:</p>
        <pre>from sklearn.preprocessing import MinMaxScaler<br/><br/>scaler = MinMaxScaler(feature_range=(0,1))<br/>x_train_scaled = scaler.fit_transform(x_train)<br/>x_test_scaled = scaler.transform(x_test)</pre>
        <p>Once fitted, you can also find out the minimum and maximum values for each column in the training data with the <kbd>data_min_</kbd><strong/>and <kbd>data_max_</kbd>attributes. Since all samples are limited to a predefined range, outliers may force inliers to be squeezed into a small subset of this range.</p>
        <h2 id="uuid-0babbd2a-d6b4-49d3-aee8-47850bc1bbb4">RobustScaler</h2>
        <p>This is similar to the standard scaler, but uses the data quantiles instead to be more robust to the outliers' effect on the mean and standard deviation. It's advised that you use this if your data has outliers, and it can be used as follows:</p>
        <pre>from sklearn.preprocessing import RobustScaler<br/><br/>scaler = RobustScaler()<br/>x_train_scaled = scaler.fit_transform(x_train)<br/>x_test_scaled = scaler.transform(x_test)</pre>
        <p>Other scalers also exist; however, I have covered the most commonly used scalers here. Throughout this book, we will be using the aforementioned scalers. All scalers have an <kbd>inverse_transform()</kbd> method, so you can restore a feature's original scales if needed. Furthermore, if you cannot load all training data into memory at once, or if the data comes in batches, you can then call the scaler's <kbd>partial_fit()</kbd> method with each batch instead of calling the <kbd>fit()</kbd> method for the entire dataset once.</p>
        <h1 id="uuid-a4f6511d-ca10-4eee-b689-0e235b629571">Selecting the most useful features</h1>
        <div class="packt_quote">"More data, such as paying attention to the eye colors of the people around when crossing the street, can make you miss the big truck."</div>
        <div class="packt_quote CDPAlignRight CDPAlign">– Nassim Nicholas Taleb</div>
        <p>We have seen, in previous chapters, that too many features can degrade the performance of our models. What is known as the curse of dimensionality may negatively impact an algorithm's accuracy, especially if there aren't enough training samples. Furthermore, it can also lead to more training time and higher computational requirements. Luckily, we have also learned how to regularize our linear models or limit the growth of our decision trees to combat the effect of feature abundance. Nevertheless, we may sometimes end up using models where regularization is not an option. Additionally, we may still need to get rid of some pointless features to reduce the algorithm's training time and computational needs. In these situations, feature selection is wise to use as a first step.</p>
        <p>Depending on whether we are dealing with labeled or unlabeled data, we can choose different methods for feature selection. Furthermore, some methods are more computationally expensive than others, and some lead to more accurate results. In the following sections, we are going to see how those different methods can be used and, to demonstrate that, we will load scikit-learn's <kbd>wine</kbd> dataset:</p>
        <pre>from sklearn import datasets<br/><br/>wine = datasets.load_wine()<br/>df = pd.DataFrame(<br/>    wine.data,<br/>    columns=wine.feature_names<br/>)<br/>df['target'] = pd.Series(<br/>    wine.target<br/>)</pre>
        <p>We then split the data as we usually do:</p>
        <pre>from sklearn.model_selection import train_test_split<br/>df_train, df_test = train_test_split(df, test_size=0.4)<br/><br/>x_train = df_train[wine.feature_names]<br/>x_test = df_test[wine.feature_names]<br/><br/>y_train = df_train['target']<br/>y_test = df_test['target']</pre>
        <p>The <kbd>wine</kbd> dataset has 13 features and is used for classification tasks. In the following sections, we are going to discover which features are less important than the others. </p>
        <h2 id="uuid-d87868e0-88eb-465e-a8d4-bb31c1457d91">VarianceThreshold</h2>
        <p>If you recall, when we used the <kbd>PolynomialFeatures</kbd> transformer, it added a column where all the values were set to <kbd>1</kbd>. Additionally, categorical encoders, such as one-hot encoding, can result in columns where almost all of the values are <kbd>0</kbd>. It's also common,in real-life scenarios, to have columns where all the data in it is identical or almost identical. Variance is the most obvious way to measure the amount of variation in a dataset, so <kbd>VarianceThreshold</kbd>allows us to set a minimum threshold for an accepted variance in each feature. In the following code, we will set the variance threshold to <kbd>0</kbd>. It then goes through the training set to learn which features deserve to stay:</p>
        <pre>from sklearn.feature_selection import VarianceThreshold<br/>vt = VarianceThreshold(threshold=0)<br/>vt.fit(x_train)</pre>
        <p>Like all of our other modules, this one also provides the usual <kbd>fit()</kbd>, <kbd>transform()</kbd>, and <kbd>fit_transform()</kbd> methods. However, I prefer not to use them here since we already gave our columns names, and the <kbd>transform()</kbd> functions don't honor the names we have given. That's why I prefer to use another method called <kbd>get_support()</kbd>. This method returns a list of Booleans, where any <kbd>False</kbd> values correspond to columns that ought to be removed based on the threshold we set. Here is how I remove unnecessary features using the <kbd>pandas</kbd> library's <kbd>iloc</kbd> function:</p>
        <pre>x_train = x_train.iloc[:, vt.get_support()]<br/>x_test = x_test.iloc[:, vt.get_support()]</pre>
        <p>We can also print the feature names and sort them according to their variance, as follows:</p>
        <pre>pd.DataFrame(<br/>    {<br/>        'Feature': wine.feature_names,<br/>        'Variance': vt.variances_,<br/>    }<br/>).sort_values(<br/>    'Variance', ascending=True<br/>)</pre>
        <p>This gives us the following table:</p>
        <p class="CDPAlignCenter CDPAlign">
          <img src="assets/7529285b-b8e7-4bdd-a5f7-f57ee42d0707.png" style="width:21.00em;"/>
        </p>
        <p>We can see that none of our features have zero variance; therefore, none of them are removed. You may decide to use a higher threshold—for example, setting the threshold to <kbd>0.05</kbd> will get rid of <kbd>nonflavanoid_phenols</kbd>. However, let me list the key advantages and disadvantages of this module to help you decide when and how to use it:</p>
        <ul>
          <li>Unlike the other feature selection methods we are going to see in a bit, this one does not use data labels when selecting features. This is useful when dealing with unlabeled data, as in unsupervised learning scenarios.  </li>
          <li>The fact that it is label-agnostic also means that a low variance feature might still correlate well with our labels and removing it is a mistake.</li>
          <li>The variance, just like the mean, is scale-dependent. A list of numbers from <kbd>1</kbd> to <kbd>10</kbd> has a variance of <kbd>8.25</kbd>, while the list of <kbd>10, 20, 30,...100</kbd> has a variance of <kbd>825.0</kbd>. We can clearly see this in the variance of <kbd>proline</kbd>. This makes the numbers in our table incomparable and makes it hard to pick a correct threshold. One idea may be to scale your data before calculating its variance. However, keep in mind that you cannot use <kbd>StandardScaler</kbd> since it deliberately unifies the variance of all features. So, I would find <kbd>MinMaxScaler</kbd> more meaningful here.</li>
        </ul>
        <p>In summary, I find the variance threshold handy in removing zero-variance features. As for the remaining features, I'd let the next feature selection algorithms deal with them, especially when dealing with labeled data.</p>
        <h2 id="uuid-bf5002b6-9d27-4749-a22d-0b89be19bc21">Filters</h2>
        <p>Now that our data comes with labels, it makes sense to use the correlation between each feature and the labels to decide which features are more useful for our model. This category of feature-selection algorithms deals with each individual feature and measures its usefulness in relation to the label; this algorithm is called <em>filters</em>. In other words, the algorithm takes each column in <em>x</em> and uses some measure to evaluate how useful it is in predicting <em>y</em>. Useful columns stay, while the rest are removed. The way that usefulness is measured is what differentiates one filter selector from the other. For the sake of clarity, I am going to focus on two selectors here since each one has its roots in a different scientific field, and understanding them both serves as a good foundation for future concepts. The two concepts are <strong>ANOVA (F-values)</strong> and <strong>mutual information</strong>.</p>
        <h3 id="uuid-3a2941b5-2929-484a-b8b2-c0ce507ba49d">f-regression and f-classif</h3>
        <p>As its name suggests, <kbd>f_regression</kbd>is used for feature selection in regression tasks. <kbd>f_classif</kbd> is its classification cousin. <kbd>f_regression</kbd> has its roots in the field of statistics. Its scikit-learn implementation uses the Pearson correlation coefficient to calculate the correlation between each column in <em>x</em> and <em>y</em>. The results are then converted into F-values and P-values, but let's keep that conversion aside since the correlation coefficient is the key here. We start by subtracting the mean values for each column from all the values in the same column, which is similar to what we did in <kbd>StandardScaler</kbd>, but without dividing the values by their standard deviation. Then, we calculate the correlation coefficient using the following formula:</p>
        <p class="CDPAlignCenter CDPAlign">
          <img class="fm-editor-equation" src="assets/df560025-dd75-46a6-bf25-99321f67aadf.png" style="width:9.75em;"/>
        </p>
        <p>Since the mean is subtracted, the values for the <em>x</em> and <em>y</em> values are positive when an instance is above its column's mean value, and negative when it is below. So, this equation is maximized so that every time <em>x</em> is above average, <em>y</em> is also above average, and whenever <em>x</em> is below average, <em>y</em> follows suit. The maximum value for this equation is <kbd>1</kbd>. We canthen say that <em>x</em> and <em>y</em> are perfectly correlated. The equation is <kbd>-1</kbd> when <em>x</em> and <em>y</em> stubbornly go opposite ways, in other words negatively correlated. A zero result means that <em>x</em> and <em>y</em> are uncorrelated (that is, independent or orthogonal).</p>
        <p>Usually, statisticians write this equation differently. The fact that the mean is subtracted from <em>x</em> and <em>y</em> is usually written down as a part of the equation. Then, the numerator is clearly the covariance and the denominator is the product of the two variances. Nevertheless, I deliberately chose not to follow the statistical convention here so that our natural language processing friends feel at home once they realize that this is the exact same equation as for cosine similarity. There, <em>x</em> and <em>y</em> are seen as vectors, the numerator is their dot product, and the denominator is the product of their magnitudes. Consequently, the two vectors are perfectly correlated (go in the same direction) when the angle between them is <kbd>0</kbd> (cosine <kbd>0</kbd> = <kbd>1</kbd>). Conversely, they are independent when they are perpendicular to each other, hence the term <em>orthogonal</em>. One takeaway from this visual interpretation is that this metric only considers the linear relationship between <em>x</em> and <em>y</em>. </p>
        <div class="packt_infobox">For the case of classification, a one-way ANOVA test is performed. This compares the variance between the different class labels to the variance within each class. Just like its regression cousin, it measures the linear dependence between the features and the class labels.</div>
        <p>Enough theory for now; let's use <kbd>f_classif</kbd> to pick the most useful features in our dataset:</p>
        <pre>from sklearn.feature_selection import f_classif<br/>f, p = f_classif(x_train, y_train)</pre>
        <p>Let's keep the resulting <em>f</em> and <em>p</em> values to one side for now. After explaining the mutual information approach for feature selection, we will use these values to contrast the two approaches.</p>
        <h3 id="uuid-17ccdd0a-3d1b-4171-9e4e-662c34b5b1db">Mutual information</h3>
        <p>This approach has its roots in a different scientific field called <strong>inf</strong><strong>ormation</strong><strong>theory</strong>. This field was introduced by Claude Shannon to solve issues relating to signal processing and data compression. When we send a message made up of zeros and ones, we may know the exact content of this message, but can we actually quantify the amount of information this very message carries? Shannon solved this problem by borrowing the concept of <strong>entropy</strong> from thermodynamics. Further down the line comes the concept of <strong>mutual</strong><strong>in</strong><strong>formation</strong>. It quantifies the amount of information obtained about one variable when observing another variable. The formula for mutual information is as follows:</p>
        <p class="CDPAlignCenter CDPAlign">
          <img class="fm-editor-equation" src="assets/2ffde4a4-87ac-413b-bfd6-51ccaad381c0.png" style="width:16.83em;"/>
        </p>
        <p>Before dissecting this equation, keep the following in mind:</p>
        <ul>
          <li><em>P(x)</em> is the probability of <em>x</em> taking a certain value, as is <em>P(y)</em> for <em>y</em>.</li>
          <li><em>P(x, y)</em> is known as joint probability, which is the probability of both <em>x</em> and <em>y</em> taking a specific pair of values.</li>
          <li><em>P(x, y) </em>only equals the product of <em>P(x)</em> * <em>P(y)</em>if <em>x</em> and <em>y</em> are independent. Otherwise, its value is more or less than their product, depending on whether <em>x</em> and <em>y</em> are positively or negatively correlated.</li>
        </ul>
        <p>The double summation and the first part of the equation, <em>P(x, y)</em>, are our way of calculating a weighted average for all possible values of <em>x</em> and <em>y</em>. The logarithmic part is what we care about, and it is known as point-wise mutual information. If <em>x</em> and <em>y</em> are independent, the fraction is equal to <kbd>1</kbd> and its logarithm is <kbd>0</kbd>. In other words, we get <kbd>0</kbd> when the two variables are uncorrelated. Otherwise, the sign of the outcome points to whether <em>x</em> and <em>y</em> are positively or negatively correlated.</p>
        <p>Here is how we get the mutual information coefficient for each feature:</p>
        <pre>from sklearn.feature_selection import mutual_info_classif<br/>mi = mutual_info_classif(x_train, y_train)</pre>
        <p>Unlike Pearson's correlation coefficient, mutual information captures any kind of correlation, whether it is linear or not.</p>
        <h3 id="uuid-7c332ec6-5c1b-45ab-b53e-30ee297deda4">Comparing and using the different filters</h3>
        <p>Let's now compare our mutual information scores to the F-values. To do so, we will put them both into one DataFrame and use the <kbd>pandas</kbd> styling feature to plot bar charts within the DataFrame, as follows:</p>
        <pre>pd.DataFrame(<br/>  {<br/>    'Feature': wine.feature_names,<br/>    'F': f,<br/>    'MI': mi,<br/>  }<br/>).sort_values(<br/>  'MI', ascending=False<br/>).style.bar(<br/>  subset=['F', 'MI'], color='grey'<br/>)</pre>
        <p>This gives us the following DataFrame:</p>
        <p class="CDPAlignCenter CDPAlign">
          <img src="assets/fa99ed07-b716-49d6-96b8-5772ea9a0914.png" style="width:34.58em;"/>
        </p>
        <p>As you can see, they mostly agree on the order of feature importance, yet they still disagree sometimes. I used each of the two methods to select the top four features, then compared the accuracy of a <strong>logistic regression</strong> classifier to that of a decision tree classifier with each feature selection method. Here are the results of the training set:</p>
        <p class="CDPAlignCenter CDPAlign">
          <img src="assets/3a966549-afc2-4938-8c62-46d178946711.png" style="width:36.50em;"/>
        </p>
        <p>As you can tell, each of the two selection methods worked better for one of the two classifiers here. It seems that <kbd>f_classif</kbd> served the linear model better due to its linear nature, while the non-linear model favored an algorithm that captures non-linear correlations. I have not found any literature confirming the generality of this speculation, however. </p>
        <div class="packt_tip">It is hard not to see the underlying theme that links the two measures. The numerator calculates some intra-variable information—the covariance, dot product, or join probability. The denominator calculates the product of inter-variable information—the variance, norms, or probability. This very theme will continue to appear in different topics in the future. One day, we might use cosine similarity to compare two documents; another day, we might use mutual information to evaluate a clustering algorithm.</div>
        <h2 id="uuid-3d734baf-7904-4fb1-aa66-2fde3b8a7fe7">Evaluating multiple features at a time</h2>
        <p>The feature selection methods shownin the <em>Filters</em> section of this chapter are also regarded as univariate feature selection methods since they check each feature separately before deciding whether to keep it. This can result in any of the two following issues:</p>
        <ul>
          <li>If two features are highly correlated, we only want to keep one of them. However, due to the nature of the univariate feature selection, they will both still be selected.</li>
          <li>If two features are not very useful on their own, yet their combination is useful. They will still be removed due to the way the univariate feature selection methods work.</li>
        </ul>
        <p>To deal with these issues, we may decide to use one of the following solutions:</p>
        <ul>
          <li><strong>Using estimators for feature selection</strong>: Typically, regressors and classifiers assign values to the features used after training, signifying their importance. So, we can use an estimator's coefficients (or feature importance) to add or remove features from our initial feature set. scikit-learn's <strong>Recursive Feature Elimination</strong> (<strong>RFE</strong>) algorithm starts with an initial set of features. Then, it iteratively removes features with each iteration using the trained model's coefficients. The <kbd>SelectFromModel</kbd> algorithm is a meta-transformer that can make use of a regularized model to remove features with zero or near-zero coefficients. </li>
          <li><strong>Using estimators with built-in feature selection</strong>: In other words, this means using a regularized estimator such as lasso, where feature selection is part of the estimator's objectives. </li>
        </ul>
        <p>In summary, methods such as using variance thresholds and filters are quick to perform but have their drawbacks when it comes to feature correlation and interaction. More computationally expensive methods, such as wrappers, deal with these issues but are prone to overfitting.</p>
        <div class="packt_tip">If you ask me about my recommendations for feature selection, personally, my go-to method would be regularization after removing the zero-variance features, unless I am dealing with a huge amount of features where training on the entire set is unfeasible. In these cases, I'd use a univariate feature selection method while being careful about removing features that might end up being useful. I'd still use a regularized model afterward to deal with any multicollinearity.</div>
        <p>In the end, the proof of the pudding is in the eating, and empirical results via trial and error may trump my recommendations. Furthermore, besides improving the final model's accuracy, feature selection can still be used to understand the data at hand. The feature importance scores can still be used to inform business decisions. For example, if our label states whether a user is going to churn, we can come up with a hypothesis that the top-scoring features affect the churn rate the most. Then, we can run experiments by changing the relevant parts of our product to see whether we can decrease the churn rate. </p>
        <h1 id="uuid-2feb677e-4705-426f-835b-497b08255272">Summary</h1>
        <p>Pursuing a data-related career requires a tendency to deal with imperfections. Dealing with missing values is one step that we cannot progress without. So, we started this chapter by learning about different data imputation methods. Additionally, suitable data for one task may not be perfect for another. That's why we learned about feature encoding and how to change categorical and ordinal data to fit into our machine learning needs. Helping algorithms to perform better can require rescaling the numerical features. Therefore, we learned about three scaling methods. Finally, data abundance can be a curse on our models, so feature selection is one prescribed way to deal with the curse of dimensionality, along with regularization.</p>
        <p>One main theme that ran through this entire chapter is the trade-off between simple and quick methods versus more informed and computationally expensive methods that may result in overfitting. Knowing which methods to use requires an understanding of their underlying theories, in addition to a willingness to experiment and use iterations. So, I decided to go a bit deeper into the theoretical background where needed, not only so that it helps you pick your methods wisely, but also so that it allows you to come up with your own methods in the future. </p>
        <p>Now that we have the main data preprocessing tools on our side, we are ready to move on to our next algorithm—KNN.</p>
      </article>
    </section>
  </body></html>