<html><head></head><body>
    <section>
      <header class="header-title chapter-title">
                    Recommender System – Getting to Know Their Taste
                </header>
      <article>
        <p class="mce-root">A layperson might not know about the sophisticated machine learning algorithms controlling the high-frequency transactions taking place in the stock exchange. They may also not know about the algorithms detecting online crimes and controlling missions to outer space. Yet, they interact with recommendation engines every day. They are daily witnesses of the recommendation engines picking books for them to read on Amazon, selecting which movies they should watch next on Netflix, and influencing the news articles they read every day. The prevalence of recommendation engines in many businesses requires different flavors of recommendation algorithms. </p>
        <p>In this chapter, we will learn about the different approaches used by recommender systems. We will mainly use a sister library to scikit-learn called Surprise. Surprise is a toolkit that implements different collaborative filtering algorithms. So, we will start by learning the differences between the <em>c</em><em>ollaborative filtering</em> algorithms and the <em>content-based filtering</em> algorithms used in a recommendation engine. We will also learn how to package our trained models to be used by other software without the need for retraining. The following topics will be discussed here:</p>
        <ul>
          <li>The different recommendation paradigms  </li>
          <li>Downloading Surprise and the dataset</li>
          <li>Using KNN-inspired algorithms</li>
          <li>Using baseline algorithms</li>
          <li>Using singular value decomposition</li>
          <li>Deploying machine learning models in production</li>
        </ul>
        <h1 id="uuid-c719c6e2-0aeb-4bd3-b7c8-65d91e5a0aaa">The different recommendation paradigms</h1>
        <p>In a recommendation task, you have a set of users interacting with a set of items and your job is to figure out which items are suitable for which users. You may know a thing or two about each user: where they live, how much they earn, whether they are logged in via their phone or their tablet, and more. Similarly, for an item—say, a movie—you know its genre, its production year, and how many Academy Awards it has won. Clearly, this looks like a classification problem. You can combine the user features with the item features and build a classifier for each user-item pair, and then try to predict whether the user will like the item or not. This approach is known as <strong>content-based filtering</strong>. As its name suggests, it is as good as the content or the features extracted from each user and each item. In practice, you may only know basic information about each user. A user's location or gender may reveal enough about their tastes. This approach is also hard to generalize. Say we decided to expand our recommendation engine to recommend TV series as well. The number of Academy Awards may not be relevant, then, and we may need to replace this feature with the number of Golden Globe nominations instead. What if we expand it to music later? It makes sense to think of a different approach that is content-agnostic instead.</p>
        <p><strong>Collaborative filtering</strong>, on the other hand, doesn't care much about the user or the item features. Rather, it assumes that users who are already interested in some items will probably have the same interests in the future. To make a recommendation for you, it basically recruits other users who are similar to you and uses the decisions they make to suggest items to you in the future. One obvious problem here is the cold-start problem. When a new user joins, it is hard to know which users are similar to them right away. Also, for a new item, it will take a while for some users to discover it, and only then will the system be able to recommend it to other users. </p>
        <p>Since each approach has its shortcomings, a hybrid approach of the two can be used. In its simplest form, we can just recommend to the new users the most popular items on the platform. Once these new users consume enough items for us to know their taste, we can start incorporating a more collaborative filtering approach to tailor their recommendations for them.</p>
        <p>In this chapter, we are going to focus on the <em>collaborative filtering</em> paradigm. It is the more common approach, and we already learned in previous chapters how to build the classifiers needed for the <em>content-based filtering</em> approach. We will be using a library called Surprise to demonstrate the differentcollaborative filtering algorithms. In the next section, we are going to install Surprise and download the data needed for the rest of the chapter. </p>
        <h1 id="uuid-cd35ffd7-ccb3-4525-9d79-81cede8565a2">Downloading surprise and the dataset </h1>
        <p>Nicolas Hug created Surprise [<a href="http://surpriselib.com">http://surpriselib.com</a>], which implements a number of the<em/>collaborative filtering algorithms we will use here. I am using version 1.1.0 of the library. To download the same version of the library via <kbd>pip</kbd>, you can run the following command in your terminal:</p>
        <pre>
          <strong>pip install -U scikit-surprise==1.1.0</strong>
        </pre>
        <p>Before using the library, we also need to download the dataset used in this chapter.</p>
        <h2 id="uuid-f44afbb8-86ca-4911-92e4-25d10201f974">Downloading the KDD Cup 2012 dataset</h2>
        <p>We are going to use the same dataset that we used in <a href="https://cdp.packtpub.com/hands_on_machine_learning_with_scikit_learn/wp-admin/post.php?post=32&amp;action=edit">Chapter 10</a><em>, Imbalanced Learning – Not Even 1% Win the Lottery</em>. The data is published on the <strong>OpenML</strong> platform. It contains a list of records. In each record, a user has seen an online advertisement, and there is an additional column stating whether the user clicked on the advertisement. In the aforementioned chapter, we built a classifier to predict whether the user clicked on the advertisement. We used the provided features for the advertisements and the visiting users in our classifier. In this chapter, we are going to frame the problem as a collaborative filtering problem. So, we will only use the IDs of the users and the advertisements. All the other features will be ignored, and this time, the target label will be the user rating. Here, we will download the data and put it into a data frame: </p>
        <pre>from sklearn.datasets import fetch_openml<br/><br/>data = fetch_openml(data_id=1220)<br/><br/>df = pd.DataFrame(<br/>    data['data'],<br/>    columns=data['feature_names']<br/>)[['user_id', 'ad_id']].astype(int)<br/><br/><br/>df['user_rating'] = pd.Series(data['target']).astype(int)</pre>
        <p>We converted all the columns into integers. The rating column takes binary values, where <kbd>1</kbd> indicates a click or a positive rating. We can see that only<kbd>16.8%</kbd>of the records lead to a positive rating. We can check this by printing the mean of the <kbd>user_rating</kbd>column, as follows:</p>
        <pre>df['user_rating'].mean()</pre>
        <p>We can also display the first four rows of the dataset. Here, you can see the IDs of the users and the advertisements, as well as the given ratings:</p>
        <p class="CDPAlignCenter CDPAlign">
          <img src="assets/6206c67f-cdb9-4636-ba2a-63dc3c8bc68e.png" style="width:19.25em;"/>
        </p>
        <p>The Surprise library expects the data columns to be in this exact order. So, no more data manipulations are required for now. In the next section, we are going to see how to load this data frame into the library and split it into training and test sets. </p>
        <h2 id="uuid-0ee33565-672e-4491-be62-d9dbc483954a">Processing and splitting the dataset</h2>
        <p>In its simplest form, two users are similar, from acollaborative filtering point of view, if they give the same ratings to the same items. It is hard to see this in the current data format. It would be better to put the data into a user-item rating matrix. Each row in this matrix represents a user, each column represents an item, and the values in each cell represent the rating given by each user to the corresponding item. We can use the<kbd>pivot</kbd>method in <kbd>pandas</kbd> to create this matrix. Here, I have created the matrix for the first 10 records of our dataset:</p>
        <pre>df.head(10).groupby(<br/>    ['user_id', 'ad_id']<br/>).max().reset_index().pivot(<br/>    'user_id', 'ad_id', 'user_rating'<br/>).fillna(0).astype(int)</pre>
        <p>Here is the resulting <kbd>10</kbd> users by <kbd>10</kbd> items matrix:</p>
        <p class="CDPAlignCenter CDPAlign">
          <img src="assets/8d73ec36-11fd-47a7-9d7b-2d3c5acd48a5.png" style="width:54.42em;"/>
        </p>
        <p>Doing this ourselves using data frames is not the most efficient approach. The Surprise library stores the data in a more efficient way. So, we will use the library's <kbd>Dataset</kbd> module instead. Before loading the data, we need to specify the scale of the ratings given. Here, we will use the<kbd>Reader</kbd>module to specify that our ratings take binary values. Then, we will load the data frame using the  <kbd>load_from_df</kbd> method of the dataset. This method takes our data frame as well as an instance of the aforementioned reader: </p>
        <pre>from surprise.dataset import Dataset<br/>from surprise import Reader<br/><br/>reader = Reader(rating_scale=(0, 1))<br/>dataset = Dataset.load_from_df(df, reader)</pre>
        <p>The collaborative filtering algorithm is not considered a supervised learning algorithm due to the absence of concepts such as features and targets. Nevertheless, users give ratings to the item and we try to predict those ratings. This means that we can still evaluate our algorithm by comparing the actual ratings to the predicted ones. That's why it is common to split the data into training and test sets and use metrics to evaluate our predictions. Surprise has a similar function to scikit-learn's <kbd>train_test_split</kbd> function. We will use it here to split the data into 75% training versus 25% test sets: </p>
        <pre>from surprise.model_selection import train_test_split<br/>trainset, testset = train_test_split(dataset, test_size=0.25)</pre>
        <p>In addition to the train-test split, we can also perform <strong>K-Fold cross-validation</strong>. We will use the<strong>Mean Absolute Error</strong> (<strong>MAE</strong>) and the <strong>Root Mean Squared Error</strong> (<strong>RMSE</strong>) to compare the predicted ratings to the actual ones. The following code uses 4-fold cross-validation and prints the average MAE and RMSE for the four folds. To make it easier to apply to different algorithms, I created a <kbd>predict_evaluate</kbd>function, which takes an instance of the algorithm we want to use. It also takes the entire dataset, and the name of the algorithm is used to print it alongside the results at the end. It then uses the<kbd>cross_validate</kbd><em><strong/></em>module od <kbd>surprise</kbd> to calculate the expected errors and print their averages:</p>
        <pre>from surprise.model_selection import cross_validate<br/><br/>def predict_evaluate(recsys, dataset, name='Algorithm'):<br/>    scores = cross_validate(<br/>        recsys, dataset, measures=['RMSE', 'MAE'], cv=4<br/>    )<br/>    print(<br/>        'Testset Avg. MAE: {:.2f} &amp; Avg. RMSE: {:.2f} [{}]'.format(<br/>            scores['test_mae'].mean(),<br/>            scores['test_rmse'].mean(),<br/>            name<br/>        )<br/>    )</pre>
        <p>We will be using this function in the following sections. Before learning about the different algorithms, we need to create a reference algorithm—a line in the sand with which to compare the remaining algorithms. In the next section, we are going to create a recommendation system that gives random results. This will be our reference algorithm further down the road. </p>
        <h2 id="uuid-2bc6bc26-bf69-41eb-8cc6-9a2d92b7a57a">Creating a random recommender</h2>
        <p>We know that 16.8% of the records lead to positive ratings. Thus, a recommender that randomly gives positive ratings to 16.8% of the cases seems like a good reference to compare the other algorithms. By the way, I am deliberately avoiding the term <em>baseline</em> here and using terms such as <em>reference</em> instead, since one of the algorithms used here is called <em>baseline</em>. Anyway, we can create our reference algorithm by creating a <kbd>RandomRating</kbd>classthat inherits from the Surprise library's<kbd>AlgoBase</kbd>class. All the algorithms in the library are driven from the <kbd>AlgoBase</kbd> base class and they are expected to implement an estimate method.</p>
        <p>This method is called with each user-item pair and it is expected to return the predicted rating for this particular user-item pair. Since we are returning random ratings here, we will use NumPy's <kbd>random</kbd> module. Here, we set <kbd>n=1</kbd> in the binomial method, which turns it into a Bernoulli distribution. The value given to <kbd>p</kbd> during the class initialization specifies the probability of returning ones. By default, 50% of the user-item pairs will get a rating of <kbd>1</kbd> and 50% of them will get a rating of <kbd>0</kbd>. We will override this default and set it to 16.8% when using the class later on. Here is the code for the newly created method:</p>
        <pre>from surprise import AlgoBase<br/><br/>class RandomRating(AlgoBase):<br/><br/>    def __init__(self, p=0.5):<br/>        self.p = p<br/>        AlgoBase.__init__(self)<br/><br/>    def estimate(self, u, i):<br/>        return np.random.binomial(n=1, p=self.p, size=1)[0]</pre>
        <p>We need to change the default value of <kbd>p</kbd> to <kbd>16.8%</kbd>. We can then pass the  <kbd>RandomRating</kbd> instance to <kbd>predict_evaluate</kbd> to get the estimated errors:</p>
        <pre>recsys = RandomRating(p=0.168)<br/>predict_evaluate(recsys, dataset, 'RandomRating')</pre>
        <p>The previous code gives us an average MAE of <kbd>0.28</kbd> and an average RMSE of <kbd>0.53</kbd>. Remember, we are using K-fold cross-validation. So, we calculate the average of the average errors returned for each fold. Keep these error numbers in mind as we expect more advanced algorithms to give lower errors. In the next section, we will meet the most basic family of the collaborative filtering algorithms, inspired by the<strong>K-Nearest Neighbors</strong> (<strong>KNN</strong>) algorithms. </p>
        <h1 id="uuid-c84ae693-43d9-459d-a0e6-a6a342da73b2">Using KNN-inspired algorithms</h1>
        <p>We have encountered enough variants of the KNN<strong/>algorithm for it be our first choice for solving the recommendation problem. In the user-item rating matrix from the previous section, each row represents a user and each column represents an item. Thus, similar rows represent users who have similar tastes and identical columns represent items liked by the same users. Therefore, if we want to estimate the rating (<em>r<sub>u,i</sub></em>),<strong><sub/></strong>given by the user (<em>u</em>) to the item (<em>i</em>), we can get the KNNs to the user (<em>u</em>), find their ratings for the item (<em>i</em>), and calculate the average of their rating as an estimate for (<em>r<sub>u,i</sub></em>). Nevertheless, since some of these neighbors are more similar to the user (<em>u</em>) than others, we may need to use a weighted average instead. Ratings given by more similar users should be given more weight than the others. Here is a formula where a similarity score is used to weigh the ratings given by the user's neighbors:  </p>
        <p class="CDPAlignCenter CDPAlign">
          <img class="fm-editor-equation" src="assets/f8c3f918-d8f1-4121-9414-2c2e147ba36e.png" style="width:22.58em;"/>
        </p>
        <p>We refer to the neighbors of <em>u</em> with the term <em>v</em>. Therefore, <em>r<sub>v,i</sub></em><strong><sub/></strong>is the rating given by each of them to the item (<em>i</em>). Conversely, we can base our estimation on <em>item similarities</em> rather than <em>user similarities.</em> Then, the expected rating (<em>r<sub>u,i</sub></em>) would be the weighted average of the ratings given by the user (<em>u</em>) to their most similar items (<em>i</em>). </p>
        <p>You may be wondering whether we can nowset the number of neighbors and whether there are multiple similarity metrics to choose from. The answer to both questions is yes. We will dig deeper into the algorithm's hyperparameters in a bit, but for now, let's use it with its default values. Once <kbd>KNNBasic</kbd> is initialized, we can pass it to the <kbd>predict_evaluate</kbd> function, the same way we passed the <kbd>RandomRating</kbd> estimator to it in the previous section. Make sure you have enough memory on your computer before running the following code:</p>
        <pre>from surprise.prediction_algorithms.knns import KNNBasic<br/>recsys = KNNBasic()<br/>predict_evaluate(recsys, dataset, 'KNNBasic')</pre>
        <p>We get an average MAE of <kbd>0.28</kbd> and an average RMSE of <kbd>0.38</kbd> this time. The improvement in the squared error is expected, given that the <kbd>RandomRating</kbd> estimator was blindly making random predictions, while<kbd>KNNBasic</kbd>bases its decision on users' similarities. </p>
        <div class="packt_infobox">The ratings in the dataset used here are binary values. In some other scenarios, users may be allowed to give 5-star ratings, or even give scores from 0 to 100. In those scenarios, one user may be more generous with their numbers than another. We both may have the same taste, but for me, a 5-star rating signals the movie is great, while you never give a 5-star rating yourself, and your favorite movies get 4-star rating tops. The <kbd>KNNWithMeans</kbd>algorithm deals with this problem. It is an almost identical algorithm to<kbd>KNNBasic</kbd>, except for the fact that it initially normalizes the ratings given by each user to make them comparable.</div>
        <p>As stated earlier, we can choose the number for <kbd>K</kbd>, as well as the similarity score used. Additionally, we can decide whether we want to base our estimation on user similarities or on item similarities. Here, we set the number of neighbors to <kbd>20</kbd>, use cosine similarity, and base our estimation on item similarities: </p>
        <pre>from surprise.prediction_algorithms.knns import KNNBasic<br/><br/>sim_options = {<br/>    'name': 'cosine', 'user_based': False<br/>}<br/>recsys = KNNBasic(k=20, sim_options=sim_options, verbose=False)<br/>predict_evaluate(recsys, dataset, 'KNNBasic')</pre>
        <p>The resulting errors are worse than before. We get an average MAE of <kbd>0.29</kbd> and an average RMSE of <kbd>0.39</kbd>. Clearly, we need to try different hyperparameters until we get the best results. Luckily, Surprise provides a <kbd>GridSearchCV</kbd> helper for tuning the algorithm's hyperparameters. We basically provide a list of the hyperparameter values and specify the measures we need to use to evaluate the algorithms. In the following code snippet, we set the measures to <kbd>rmse</kbd> and <kbd>mae</kbd>. We use 4-fold cross-validation and use all the available processors in our machines when running the grid search. You probably know by now that KNN algorithms are slow with their prediction time. So, to speed up this process, I only ran the search on a subset of our dataset, as follows:</p>
        <pre>from surprise.model_selection import GridSearchCV<br/>from surprise.prediction_algorithms.knns import KNNBasic<br/><br/>param_grid = {<br/>    'sim_options': {<br/>        'name':['cosine', 'pearson'],<br/>    },<br/>    'k': [5, 10, 20, 40],<br/>    'verbose': [True],<br/>}<br/><br/>dataset_subset = Dataset.load_from_df(<br/>    df.sample(frac=0.25, random_state=0), reader<br/>)<br/>gscv = GridSearchCV(<br/>    KNNBasic, param_grid, measures=['rmse', 'mae'], <br/>    cv=4, n_jobs=-1<br/>)<br/>gscv.fit(dataset_subset)<br/><br/>print('Best MAE:', gscv.best_score['mae'].round(2))<br/>print('Best RMSE:', gscv.best_score['rmse'].round(2))<br/>print('Best Params', gscv.best_params['rmse'])</pre>
        <p>We get an average MAE of <kbd>0.28</kbd> and an average RMSE of <kbd>0.38</kbd>. These are the same results as with the default hyperparameters. However,<kbd>GridSearchCV</kbd>chose a <kbd>K</kbd> value of <kbd>20</kbd> versus the default of <kbd>40</kbd>. It also chose the <strong>Pearson correlation coefficien</strong>t as its similarity measure. </p>
        <p>The KNN algorithm is slow and did not give the best performance for our dataset. Therefore, in the next section, we are going to try a non-instance-based learner instead.</p>
        <h1 id="uuid-cd4f402a-25e6-42e5-8aab-fed96cdb1afa">Using baseline algorithms</h1>
        <p>The simplicity of the nearest neighbors algorithm is a double-edged sword. On the one hand, it is easier to grasp, but on the other hand, it lacks an objective function that we can optimize during training. This also means that the majority of its computation is performed during prediction time. To overcome these problems, Yehuda Koren formulated the recommendation problem in terms of an optimization task. Still, for each user-item pair, we need to estimate a rating (<em>r<sub>u,i</sub></em>). The expected rating this time is the summation of the following triplet:</p>
        <ul>
          <li><img class="fm-editor-equation" src="assets/a8e42ccd-0aab-45e7-9757-acf0bea746cb.png" style="width:0.83em;"/>: The overall average rating given by all users to all items</li>
          <li><em>b<sub>u</sub></em>: A term for how the user (<em>u</em>) deviates from the overall average rating</li>
          <li><em>b<sub>i</sub></em>: A term for how the item (<em>i</em>) deviates from the average rating</li>
        </ul>
        <p>Here is the formula for the expected ratings: </p>
        <p class="CDPAlignCenter CDPAlign">
          <img class="fm-editor-equation" src="assets/3804eba7-13fb-4efc-9233-ebc145f874b5.png" style="width:15.83em;"/>
        </p>
        <p>For each user-item pair in our training set, we know its actual rating (<em>r<sub>u,i</sub></em>), and all we need to do now is to figure out the optimal values of <em>b<sub>u</sub></em> and <em>b<sub>i</sub></em>. We are after values that minimize the difference between the actual rating (<em>r<sub>u,i</sub></em>) and the <em>expected rating </em>(<em>r<sub>u,i</sub></em>) from the aforementioned formula. In other words, we need a solver to learn the values of the terms when given the training data. In practice, the baseline algorithm tries to minimize the average squared difference between the actual and the expected ratings. It also adds a regularization term that penalizes (<em>b<sub>u</sub></em>) and (<em>b<sub>i</sub></em>) to avoid overfitting. Please refer to <a href="https://cdp.packtpub.com/hands_on_machine_learning_with_scikit_learn/wp-admin/post.php?post=26&amp;action=edit">Chapter 3</a><em>, Making Decisions with Linear Equations</em>, for a better understanding of the concept of regularization. </p>
        <p>The learned coefficients (<em>b<sub>u</sub></em> and <em>b<sub>i</sub></em>)<strong><sub/></strong>are vectors describing each user and each item. At prediction time, if a new user is encountered, <em>b<sub>u</sub></em> is set to <kbd>0</kbd>. Similarly, if a new item that wasn't seen in the training set is encountered, <em>b<sub>i</sub></em> is set to <kbd>0</kbd>.</p>
        <div class="packt_infobox">Two solvers are available for solving this optimization problem: <strong>Stochastic Gradient Descent</strong> (<strong>SGD</strong>) and <strong>Alternating Least Squares</strong> (<strong>ALS</strong>). ALS is used by default. Each of the two solvers has its own settings, such as the maximum number of epochs and the learning rate. Moreover, you can also tune the regularization parameters. </div>
        <p>Here is how the model is used with its default hyperparameters:</p>
        <pre>from surprise.prediction_algorithms.baseline_only import BaselineOnly<br/>recsys = BaselineOnly(verbose=False)<br/>predict_evaluate(recsys, dataset, 'BaselineOnly')</pre>
        <p>This time, we get an average MAE of <kbd>0.27</kbd> and an average RMSE of <kbd>0.37</kbd>. Once more, <kbd>GridSearchCV</kbd> can be used to tune the model's hyperparameters. I will leave the parameter tuning for you to try. Now, it is time to move on to our third algorithm: <strong>Singular Value Decomposition</strong> (<strong>SVD</strong>).</p>
        <h1 id="uuid-8fc3f20b-00db-4c9a-a4aa-7d03e59192c2">Using singular value decomposition</h1>
        <p>The user-item rating matrix is usually a huge matrix. The one we got from our dataset here comprises 30,114 rows and 19,228 columns, and most of the values in this matrix (99.999%) are zeros. This is expected. Say you own a streaming service with thousands of movies in your library. It is very unlikely that a user will watch more than a few dozen of them. This sparsity creates another problem. If one user watched the movie <em>The Hangover: Part 1</em> and another user watched <em>The Hangover: Part 2,</em> from the matrix's point of view, they watched two different movies. We already know that collaborative filtering algorithms don't use users or item features. Thus, it is not aware of the fact that the two parts of <em>The Hangover</em> movie belong to the same franchise, let alone knowing that they both are comedies. To deal with this shortcoming, we need to transform our user-item rating matrix. We want the new matrix, or matrices, to be smaller and to capture the similarities between the users and the items better.</p>
        <p>The <strong>SVD</strong> is a matrix factorization algorithm that is used for dimensionality reduction. It is very similar to <strong>Principal Component Analysis</strong>(<strong>PCA</strong>), which we looked at in <a href="https://cdp.packtpub.com/hands_on_machine_learning_with_scikit_learn/wp-admin/post.php?post=28&amp;action=edit">Chapter 5</a><em>, Image Processing with Nearest Neighbors</em>. The resulting singular values, as opposed to the principal components in PCA, capture latent information about the users and the item in the user-item rating matrix. Don't worry if the previous sentence is not clear yet. In the next section, we will understand the algorithm better via an example. </p>
        <h2 id="uuid-f2efdfec-706f-4457-89d6-69f189a3477c">Extracting latent information via SVD  </h2>
        <p>Nothing spells taste like music. Let's take the following dataset. Here, we have six users, each voting for the musicians they like:</p>
        <pre>music_ratings = [('U1', 'Metallica'), ('U1', 'Rammstein'), ('U2', 'Rammstein'), ('U3', 'Tiesto'), ('U3', 'Paul van Dyk'), ('U2', 'Metallica'), ('U4', 'Tiesto'), ('U4', 'Paul van Dyk'), ('U5', 'Metallica'), ('U5', 'Slipknot'), ('U6', 'Tiesto'), ('U6', 'Aly &amp; Fila'), ('U3', 'Aly &amp; Fila')]</pre>
        <p>We can put these ratings into a data frame and convert it into a user-item rating matrix, using the data frame's <kbd>pivot</kbd> method, as follows:</p>
        <pre>df_music_ratings = pd.DataFrame(music_ratings, columns=['User', 'Artist'])<br/>df_music_ratings['Rating'] = 1<br/><br/>df_music_ratings_pivoted = df_music_ratings.pivot(<br/>    'User', 'Artist', 'Rating'<br/>).fillna(0)</pre>
        <p>Here is the resulting matrix. I used <kbd>pandas</kbd> styling to give the different ratings different colors for clarity:</p>
        <p class="CDPAlignCenter CDPAlign">
          <img src="assets/69a9ab17-90b1-41d6-b515-269105890a30.png" style="width:34.25em;"/>
        </p>
        <p>Clearly, users 1, 2, and 5 like metal music, while users 3, 4, and 6 like trance music. We can see this despite the fact that user 5 only shares one band with users 1 and 2. We could perhaps also see this because we are aware of these musicians and because we have a holistic view of the matrix instead of focusing on individual pairs. We can use scikit-learn's <kbd>TruncatedSVD</kbd> function to reduce the dimensionality of the matrix and represent each user and musician via <em>N</em> components (single vectors). The following snippet calculates <kbd>TruncatedSVD</kbd> with two <em>single vectors</em>. Then, the <kbd>transform</kbd> function returns a new matrix, where each row represents one of the six users, and each of its two columns corresponds to one of the two single vectors:</p>
        <pre>from sklearn.decomposition import TruncatedSVD<br/>svd = TruncatedSVD(n_components=2)<br/>svd.fit_transform(df_music_ratings_pivoted).round(2)</pre>
        <p>Once more, I put the resulting matrix into a data frame and used its styling to color the cells according to their values. Here is the code for that:</p>
        <pre>pd.DataFrame(<br/>    svd.fit_transform(df_music_ratings_pivoted),<br/>    index=df_music_ratings_pivoted.index,<br/>    columns=['SV1', 'SV2'], <br/>).round(2).style.bar(<br/>    subset=['SV1', 'SV2'], align='mid', color='#AAA'<br/>)</pre>
        <p>This is the resulting data frame:</p>
        <p class="CDPAlignCenter CDPAlign">
          <img src="assets/c51d9ed9-ea3a-4f77-8d37-b8ac40ac745c.png" style="width:19.42em;"/>
        </p>
        <p>You can treat each of the two components as a music genre. It is clear that the smaller matrix was able to capture the user's taste in terms of genres. Users 1, 2, and 5 are brought closer to each other now, as are users 3, 4, and 6, who are closer to each other than they were in the original matrix. We will use the cosine similarity score to show this more clearly in the next section. </p>
        <div class="packt_infobox">The concept used here is also used with textual data. Words such as <kbd>search</kbd>, <kbd>find</kbd>, and <kbd>forage</kbd> carry similar meanings. Thus, the <kbd>TruncatedSVD</kbd> transformer can be used to compress a<em/><strong>Vector Space Model</strong> (<strong>VSM</strong>) into a lower space before using it in a supervised or an unsupervised learning algorithm. When used in that context, it is known as<strong>Latent Semantic Analysis</strong> (<strong>LSA</strong>).</div>
        <p>This compression not only captures the latent information that is not clear in the bigger matrix, but also helps with distance calculations. We already know that algorithms such as KNN work best with lower dimensions. Don't take my word for it. In the next section, we will compare the cosine distances when calculated based on the original user-item rating matrix versus the two-dimensional one. </p>
        <h3 id="uuid-a8a3a1ba-8636-413b-8160-1fe5a7130b3d">Comparing the similarity measures for the two matrices</h3>
        <p>We can calculate the cosine similarities between all users. We will start with the original user-item rating matrix. After calculating pairwise cosine similarities for users 1, 2, 3, and 5, we put the results into a data frame and apply some styling for clarity:</p>
        <pre>from sklearn.metrics.pairwise import cosine_similarity<br/><br/>user_ids = ['U1', 'U2', 'U3', 'U5']<br/><br/>pd.DataFrame(<br/>    cosine_similarity(<br/>        df_music_ratings_pivoted.loc[user_ids, :].values<br/>    ),<br/>    index=user_ids,<br/>    columns=user_ids<br/>).round(2).style.bar(<br/>    subset=user_ids, align='mid', color='#AAA'<br/>)</pre>
        <p>Here are the resulting pairwise similarities between the four users:</p>
        <p class="CDPAlignCenter CDPAlign">
          <img src="assets/1524d18a-9d9d-4df8-9de5-2bc635683bbc.png" style="width:35.50em;"/>
        </p>
        <p>Indeed, user 5 is more similar to users 1 and 2, compared to user 3. However, they are not as similar as we expected them to be. Let's now calculate the same similarities by using <kbd>TruncatedSVD</kbd> this time:</p>
        <pre>from sklearn.metrics.pairwise import cosine_similarity<br/>from sklearn.decomposition import TruncatedSVD<br/><br/>user_ids = ['U1', 'U2', 'U3', 'U5']<br/><br/>svd = TruncatedSVD(n_components=2)<br/>df_user_svd = pd.DataFrame(<br/>    svd.fit_transform(df_music_ratings_pivoted),<br/>    index=df_music_ratings_pivoted.index,<br/>    columns=['SV1', 'SV2'], <br/>)<br/><br/>pd.DataFrame(<br/>    cosine_similarity(<br/>        df_user_svd.loc[user_ids, :].values<br/>    ),<br/>    index=user_ids,<br/>    columns=user_ids<br/>).round(2).style.bar(<br/>    subset=user_ids, align='mid', color='#AAA'<br/>)</pre>
        <p>The new calculations capture the latent similarities between the musicians this time and incorporate this when comparing the users. Here is the new similarity matrix:</p>
        <p class="CDPAlignCenter CDPAlign">
          <img src="assets/931b2f30-502d-49d9-bbff-9142f321f25f.png" style="width:36.75em;"/>
        </p>
        <p>Clearly, user 5 is more similar to users 1 and 2 than before. Ignore the negative signs before some of the zeros here. This is because of Python's implementation of the <strong>IEEE</strong> (<strong>Institute of Electrical and Electronics Engineers</strong>) standard for floating-point arithmetic. <br/></p>
        <p>Naturally, we can also represent the musicians in terms of their genres (single vectors). This other matrix can be retrieved via <kbd>svd.components_</kbd>. Then, we can calculate the similarities between the different musicians. This transformation is also advised as a preliminary step before clusters sparse data.    </p>
        <p>Now that this version of <kbd>SVD</kbd> is clear, in practice, when dealing with large datasets, more scalable factorization algorithms are usually used. <strong>Probabilistic Matrix Factorization</strong> (<strong>P</strong><strong>MF</strong><em>)</em>scales linearly with the number of observations and performs well on sparse and imbalanced datasets. We are going to use Surprise's implementation of PMF in the next section. </p>
        <h2 id="uuid-b7a4bea0-733e-4d36-a963-fc74a61be429">Click prediction using SVD</h2>
        <p>We can now use Surprise's <kbd>SVD</kbd> algorithm to predict the clicks in our dataset. Let's start with the algorithm's default parameters, and then explain it later on:</p>
        <pre>from surprise.prediction_algorithms.matrix_factorization import SVD<br/>recsys = SVD()<br/>predict_evaluate(recsys, dataset, 'SVD')</pre>
        <p>This time, we get an average MAE of <kbd>0.27</kbd> and an average RMSE of <kbd>0.37</kbd>. These are similar results to the baseline algorithm used earlier. In fact, Surprise's implementation of <kbd>SVD</kbd> is a combination of the baseline algorithm and <kbd>SVD</kbd>. It expresses the user-item ratings using the following formula:</p>
        <p class="CDPAlignCenter CDPAlign">
          <img class="fm-editor-equation" src="assets/f29915ef-89b9-4866-be27-9a1b9d6880ae.png" style="width:19.17em;"/>
        </p>
        <p>The first three terms of the equation (<img class="fm-editor-equation" src="assets/a8e42ccd-0aab-45e7-9757-acf0bea746cb.png" style="width:0.75em;"/>, <em>b<sub>u</sub></em>, and <em>b<sub>i</sub></em>) are the same as in the baseline algorithm. The fourth term represents the product of two similar matrices to the ones we got from <kbd>TruncatedSVD</kbd>. The <em>q<sub>i</sub></em>matrixexpresses each item as a number of single vectors. Similarly, the<em>p<sub>u</sub></em>matrixexpresses each user as a number of single vectors. The item matrix is transposed, hence the letter <em>T</em> on top of it. The algorithm then uses<strong>SGD</strong> to minimize the squared difference between the expected ratings and the actual ones. Similar to the baseline model, it also regularizes the coefficients of the expected rating (<em>b<sub>u</sub>, b<sub>i</sub>, q<sub>i</sub>,</em> and <em>p<sub>u</sub></em>) to avoid overfitting.</p>
        <p>We can ignore the baseline part of the equation—that is, remove the first three coefficients of it (<img class="fm-editor-equation" src="assets/a8e42ccd-0aab-45e7-9757-acf0bea746cb.png" style="width:0.75em;"/>, <em>b<sub>u</sub></em>, and <em>b<sub>i</sub></em>) by setting <kbd>biased=False</kbd>. The number of single vectors to use is set using the <kbd>n_factors</kbd>hyperparameter. We can also control the number of epochs for <kbd>SGD</kbd> via <kbd>n_epochs</kbd>. Furthermore, there are additional hyperparameters for setting the algorithm's learning rate, regularization, and the initial values of its coefficients. You can find the best mix for these parameters using the parameter-tuning helpers provided by<kbd>surprise</kbd>—that is, <kbd>GridSearchCV</kbd>or <kbd>RandomizedSearchCV</kbd>. </p>
        <p class="mce-root">Our discussion of the recommender systems, along with their various algorithms, marks an end to the machine learning topics discussed in this book. Like all the other algorithms discussed here, they are only useful when putting in production for others to use them. In the next section, we are going to see how we can deploy a trained algorithm and make it accessible to others.</p>
        <h1 id="uuid-7393a24e-b617-4f5e-8858-db7c018dc0e1">Deploying machine learning models in production</h1>
        <p>There are two main modes of using machine learning models: </p>
        <ul>
          <li><strong>Batch predictions</strong>: In this mode, you load a bunch of data records after a certain period—for example, every night or every month. You then make predictions for this data. Usually, latency is not an issue here, and you can afford to put your training and prediction code into single batch jobs. One exception to this is if you need to run your job too frequently that you do not have enough time to retrain the model every time the job runs. Then, it makes sense to train the model once, store it somewhere, and load it each time new batch predictions are to be made. </li>
          <li><strong>Online </strong><strong>predictions</strong>: In this model, your model is usually deployed behind an<strong>Application Programming Interface</strong> (<strong>API</strong>). Your API is usually called with a single data record each time, and it is supposed to make predictions for this single record and return it. Having low latency is paramount here and it is typically advised to train the model once, store it somewhere, and use the pre-trained model whenever a new API call is made. </li>
        </ul>
        <p>As you can see, in both cases, we may need to separate the code used during the model's training from the one used at prediction time. Whether it is a supervised learning algorithm or an unsupervised learning one, besides the lines of code it is written in, a fitted model also depends on the coefficients and parameters learned from the data. Thus, we need a way to store the code and the learned parameters as one unit. This single unit can be saved after training and then used later on at prediction time. To be able to store functions or objects in files or share them over the internet, we need to convert them into a standard format or protocol. This process is known as serialization. <kbd>pickle</kbd>is one of the most commonly used serialization protocols in Python. The Python standard library provides tools for pickling objects; however,<kbd>joblib</kbd>is a more efficient option when dealing with NumPy arrays. To be able to use the library, you need to install it via<kbd>pip</kbd>by running the following in your terminal:</p>
        <pre>
          <span class="n">pip</span>
          <span class="n">install</span>
          <span class="n">joblib</span>
        </pre>
        <p>Once installed, you can use <kbd>joblib</kbd> to save anything onto a file on disk. For example, after fitting a baseline algorithm, we can store the fitted object using the <kbd>joblib</kbd> function's <kbd>dump</kbd> method. The method expects, along with the model's object, the name of the file to save the object in. We usually use a <kbd>.pkl</kbd> extension to refer to <kbd>pickle</kbd> files:</p>
        <pre>import joblib<br/>from surprise.prediction_algorithms.baseline_only import BaselineOnly<br/><br/>recsys = BaselineOnly()<br/>recsys.fit(trainset)<br/>joblib.dump(recsys, 'recsys.pkl') </pre>
        <p>Once saved to a disk, any other Python code can load the same model again and use it right away without the need for refitting. Here, we load the pickled algorithm and use it to make predictions for the test set: </p>
        <pre>from surprise import accuracy<br/>recsys = joblib.load('recsys.pkl') <br/>predictions = recsys.test(testset)</pre>
        <p>A <kbd>surprise</kbd> estimator was used here since this is the library we used throughout this chapter. Nevertheless, any Python object can be pickled and loaded in the same way. Any of the estimators used in the previous chapters can be used the same way. Furthermore, you can also write your own classes, instantiate them, and pickle the resulting objects. </p>
        <div class="packt_tip">To deploy your model as an API, you may need to use a web framework, such as <strong>Flask</strong> or <strong>CherryPy</strong>. Developing web applications is beyond the scope of this book, but once you know how to build them, loading pickled models should be straightforward. It's advised to load the pickled object when the web application is starting. This way, you do not introduce any additional latency if you reload the objects each time you receive a new request. </div>
        <h1 id="uuid-30d911d6-8c77-4713-8426-a0c57bf68e25">Summary</h1>
        <p>This chapter marks the end of this book. I hope all the concepts discussed here are clear by now. I also hope the mixture of the theoretical background of each algorithm and its practical use paved the way for you to adapt the solutions offered here for the different problems you meet in practice in real life. Obviously, no book can be conclusive, and new algorithms and tools will be available to you in the future. Nevertheless, Pedro Domingos groups the machine learning algorithms into five tribes. Except for the evolutionary algorithms, we have met algorithms that belong to four out of Domingos' five tribes. Thus, I hope the various algorithms discussed here, each with their own approach, will serve as a good foundation when dealing with any new machine learning solutions in the future. </p>
        <p>All books are a work in progress. Their value is not only in their content but goes beyond that to include the value that comes from the future discussions they spark. Be assured that you will make the author of any book happy each time you share something you built based on the knowledge you gained from that book. You will make them equally happy each time you quote them, share new and better ways to explain things in their books, or even correct mistakes they made. I, too, am looking forward to such invaluable contributions from you. </p>
      </article>
    </section>
  </body></html>