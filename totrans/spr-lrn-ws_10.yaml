- en: 2\. Exploratory Data Analysis and Visualization
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 2.01: Summary Statistics and Missing Values'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The steps to complete this activity are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the required libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: import json
  prefs: []
  type: TYPE_NORMAL
- en: import pandas as pd
  prefs: []
  type: TYPE_NORMAL
- en: import numpy as np
  prefs: []
  type: TYPE_NORMAL
- en: import missingno as msno
  prefs: []
  type: TYPE_NORMAL
- en: from sklearn.impute import SimpleImputer
  prefs: []
  type: TYPE_NORMAL
- en: import matplotlib.pyplot as plt
  prefs: []
  type: TYPE_NORMAL
- en: import seaborn as sns
  prefs: []
  type: TYPE_NORMAL
- en: 'Read the data. Use pandas'' .read_csv method to read the CSV file into a pandas
    DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: data = pd.read_csv('../Datasets/house_prices.csv')
  prefs: []
  type: TYPE_NORMAL
- en: 'Use pandas'' .info() and .describe() methods to view the summary statistics
    of the dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: data.info()
  prefs: []
  type: TYPE_NORMAL
- en: data.describe().T
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of info() will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.50: The output of the info() method (abbreviated)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image-ZT8SEDKR.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.50: The output of the info() method (abbreviated)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of describe() will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.51: The output of the describe() method (abbreviated)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image-OOF44R7X.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.51: The output of the describe() method (abbreviated)'
  prefs: []
  type: TYPE_NORMAL
- en: Find the total count and total percentage of missing values in each column of
    the DataFrame and display them for columns having at least one null value, in
    descending order of missing percentages.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we did in Exercise 2.02: Visualizing Missing Values, we will use the .isnull()
    function on the DataFrame to get a mask, find the count of null values in each
    column by using the .sum() function over the DataFrame mask and the fraction of
    null values by using .mean() over the DataFrame mask, and multiply by 100 to convert
    it to a percentage. Then, we''ll use pd.concat() to combine the total and percentage
    of null values into a single DataFrame and sort the rows according to the percentage
    of missing values:'
  prefs: []
  type: TYPE_NORMAL
- en: mask = data.isnull()
  prefs: []
  type: TYPE_NORMAL
- en: total = mask.sum()
  prefs: []
  type: TYPE_NORMAL
- en: percent = 100*mask.mean()
  prefs: []
  type: TYPE_NORMAL
- en: '#'
  prefs: []
  type: TYPE_NORMAL
- en: missing_data = pd.concat([total, percent], axis=1,join='outer', \
  prefs: []
  type: TYPE_NORMAL
- en: keys=['count_missing', 'perc_missing'])
  prefs: []
  type: TYPE_NORMAL
- en: missing_data.sort_values(by='perc_missing', ascending=False, \
  prefs: []
  type: TYPE_NORMAL
- en: inplace=True)
  prefs: []
  type: TYPE_NORMAL
- en: '#'
  prefs: []
  type: TYPE_NORMAL
- en: missing_data[missing_data.count_missing > 0]
  prefs: []
  type: TYPE_NORMAL
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.52: Total count and percentage of missing values in each column'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image-4D9WP7GA.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.52: Total count and percentage of missing values in each column'
  prefs: []
  type: TYPE_NORMAL
- en: 'Plot the nullity matrix and nullity correlation heatmap. First, we find the
    list of column names for those having at least one null value. Then, we use the
    missingno library to plot the nullity matrix (as we did in Exercise 2.02: Visualizing
    Missing Values) for a sample of 500 points, and the nullity correlation heatmap
    for the data in those columns:'
  prefs: []
  type: TYPE_NORMAL
- en: nullable_columns = data.columns[mask.any()].tolist()
  prefs: []
  type: TYPE_NORMAL
- en: msno.matrix(data[nullable_columns].sample(500))
  prefs: []
  type: TYPE_NORMAL
- en: plt.show()
  prefs: []
  type: TYPE_NORMAL
- en: msno.heatmap(data[nullable_columns], vmin = -0.1, \
  prefs: []
  type: TYPE_NORMAL
- en: figsize=(18,18))
  prefs: []
  type: TYPE_NORMAL
- en: plt.show()
  prefs: []
  type: TYPE_NORMAL
- en: 'The nullity matrix will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.53: Nullity matrix'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image-VEDY4A9O.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.53: Nullity matrix'
  prefs: []
  type: TYPE_NORMAL
- en: 'The nullity correlation heatmap will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.54: Nullity correlation heatmap'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image-S4SOOAAB.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.54: Nullity correlation heatmap'
  prefs: []
  type: TYPE_NORMAL
- en: 'Delete the columns having more than 80% of values missing. Use the .loc operator
    on the DataFrame we created in Step 2 to select only those columns that had fewer
    than 80% of their values missing:'
  prefs: []
  type: TYPE_NORMAL
- en: data = data.loc[:,missing_data[missing_data.perc_missing < 80].index]
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace null values in the FireplaceQu column with NA values. Use the .fillna()
    method to replace null values with the NA string:'
  prefs: []
  type: TYPE_NORMAL
- en: data['FireplaceQu'] = data['FireplaceQu'].fillna('NA')
  prefs: []
  type: TYPE_NORMAL
- en: data['FireplaceQu']
  prefs: []
  type: TYPE_NORMAL
- en: 'The output should appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.55: Replacing null values'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image-1P5WR7JE.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.55: Replacing null values'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to https://packt.live/316c4a0.
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at https://packt.live/2Z21v5c. You must
    execute the entire Notebook in order to get the desired result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 2.02: Representing the Distribution of Values Visually'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Plot a histogram using Matplotlib for the target variable, SalePrice. First,
    we initialize the figure using the plt.figure command and set the figure size.
    Then, we use matplotlib''s .hist() function as our primary plotting function,
    to which we pass the SalePrice series object for plotting the histogram. Lastly,
    we specify the axes'' labels and show the plot:'
  prefs: []
  type: TYPE_NORMAL
- en: plt.figure(figsize=(8,6))
  prefs: []
  type: TYPE_NORMAL
- en: plt.hist(data.SalePrice, bins=range(0,800000,50000))
  prefs: []
  type: TYPE_NORMAL
- en: plt.ylabel('Number of Houses')
  prefs: []
  type: TYPE_NORMAL
- en: plt.xlabel('Sale Price')
  prefs: []
  type: TYPE_NORMAL
- en: plt.show()
  prefs: []
  type: TYPE_NORMAL
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.56: Histogram for the target variable'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image-QTG3WQJ1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.56: Histogram for the target variable'
  prefs: []
  type: TYPE_NORMAL
- en: 'Find the number of unique values within each column having the object type.
    Create a new DataFrame called object_variables by using the .select_dtypes function
    on the original DataFrame to select those columns with the numpy.object data type.
    Then, find the number of unique values for each column in this DataFrame by using
    the .nunique() function, and sort the resultant series:'
  prefs: []
  type: TYPE_NORMAL
- en: object_variables = data.select_dtypes(include=[np.object])
  prefs: []
  type: TYPE_NORMAL
- en: object_variables.nunique().sort_values()
  prefs: []
  type: TYPE_NORMAL
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.57: Number of unique values within each column having the object
    type (truncated)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image-KSB6TTSG.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.57: Number of unique values within each column having the object type
    (truncated)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a DataFrame representing the number of occurrences for each categorical
    value in the HouseStyle column. Use the .value_counts() function to calculate
    the frequencies of each value in decreasing order in the form of a pandas series,
    and then reset the index to give us a DataFrame and sort the values according
    to the index:'
  prefs: []
  type: TYPE_NORMAL
- en: counts = data.HouseStyle.value_counts(dropna=False)
  prefs: []
  type: TYPE_NORMAL
- en: counts.reset_index().sort_values(by='index')
  prefs: []
  type: TYPE_NORMAL
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.58: Number of occurrences of each categorical value in the HouseStyle
    column'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image-FK26JP04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.58: Number of occurrences of each categorical value in the HouseStyle
    column'
  prefs: []
  type: TYPE_NORMAL
- en: 'Plot a pie chart representing these counts. As in Step 1, we initialize the
    plot using plt.figure() and use the plt.title() and plt.show() methods to set
    the figure title and display it, respectively. The primary plotting function used
    is plt.pie(), to which we pass the series we created in the previous step:'
  prefs: []
  type: TYPE_NORMAL
- en: fig, ax = plt.subplots(figsize=(10,10))
  prefs: []
  type: TYPE_NORMAL
- en: slices = ax.pie(counts, labels = counts.index, \
  prefs: []
  type: TYPE_NORMAL
- en: colors = ['white'], \
  prefs: []
  type: TYPE_NORMAL
- en: 'wedgeprops = {''edgecolor'': ''black''})'
  prefs: []
  type: TYPE_NORMAL
- en: patches = slices[0]
  prefs: []
  type: TYPE_NORMAL
- en: hatches =  ['/', '\\', '|', '-', '+', 'x', 'o', 'O', '\.', '*']
  prefs: []
  type: TYPE_NORMAL
- en: colors = ['white', 'white', 'lightgrey', 'white', \
  prefs: []
  type: TYPE_NORMAL
- en: '''lightgrey'', ''white'', ''lightgrey'', ''white'']'
  prefs: []
  type: TYPE_NORMAL
- en: 'for patch in range(len(patches)):'
  prefs: []
  type: TYPE_NORMAL
- en: patches[patch].set_hatch(hatches[patch])
  prefs: []
  type: TYPE_NORMAL
- en: patches[patch].set_facecolor(colors[patch])
  prefs: []
  type: TYPE_NORMAL
- en: plt.title('Pie chart showing counts for\nvarious house styles')
  prefs: []
  type: TYPE_NORMAL
- en: plt.show()
  prefs: []
  type: TYPE_NORMAL
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.59: Pie chart representing the counts'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image-JTOOX73Y.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.59: Pie chart representing the counts'
  prefs: []
  type: TYPE_NORMAL
- en: 'Find the number of unique values within each column having the number type.
    As was executed in Step 2, now select columns having the numpy.number data type
    and find the number of unique values in each column using .nunique(). Sort the
    resultant series in descending order:'
  prefs: []
  type: TYPE_NORMAL
- en: numeric_variables = data.select_dtypes(include=[np.number])
  prefs: []
  type: TYPE_NORMAL
- en: numeric_variables.nunique().sort_values(ascending=False)
  prefs: []
  type: TYPE_NORMAL
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.60: Number of unique values within each numeric column (truncated)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image-3RPWU49J.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.60: Number of unique values within each numeric column (truncated)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Plot a histogram using seaborn for the LotArea variable. Use seaborn''s .distplot()
    function as the primary plotting function, to which the LotArea series in the
    DataFrame needs to be passed (without any null values, use .dropna() on the series
    to remove them). To improve the plot view, also set the bins parameter and specify
    the X-axis limits using plt.xlim():'
  prefs: []
  type: TYPE_NORMAL
- en: plt.figure(figsize=(10,7))
  prefs: []
  type: TYPE_NORMAL
- en: sns.distplot(data.LotArea.dropna(), bins=range(0,100000,1000))
  prefs: []
  type: TYPE_NORMAL
- en: plt.xlim(0,100000)
  prefs: []
  type: TYPE_NORMAL
- en: plt.show()
  prefs: []
  type: TYPE_NORMAL
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.61: Histogram for the LotArea variable'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image-YDX4ZTO7.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.61: Histogram for the LotArea variable'
  prefs: []
  type: TYPE_NORMAL
- en: 'Calculate the skew and kurtosis values for the values in each column:'
  prefs: []
  type: TYPE_NORMAL
- en: data.skew().sort_values()
  prefs: []
  type: TYPE_NORMAL
- en: data.kurt()
  prefs: []
  type: TYPE_NORMAL
- en: 'The output for skew values will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.62: Skew values for each column (truncated)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image-EDDXHS8I.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.62: Skew values for each column (truncated)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output for kurtosis values will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.63: Kurtosis values for each column (truncated)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image-WMP9BEKX.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.63: Kurtosis values for each column (truncated)'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to https://packt.live/3fR91qj.
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at https://packt.live/37PYOI4\. You must
    execute the entire Notebook in order to get the desired result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 2.03: Relationships within the Data'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Plot the correlation heatmap for the dataset. As we did in Exercise 2.13: Plotting
    a Correlation Heatmap, plot the heatmap using seaborn''s .heatmap() function and
    pass the feature correlation matrix (as determined by using pandas'' .corr() function
    on the DataFrame). Additionally, set the color map to RdBu using the cmap parameter,
    and the minimum and maximum values on the color scale to -1 and 1 using the vmin
    and vmax parameters, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: plt.figure(figsize = (12,10))
  prefs: []
  type: TYPE_NORMAL
- en: sns.heatmap(data.corr(), square=True, cmap="RdBu", \
  prefs: []
  type: TYPE_NORMAL
- en: vmin=-1, vmax=1)
  prefs: []
  type: TYPE_NORMAL
- en: plt.show()
  prefs: []
  type: TYPE_NORMAL
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.64: Correlation heatmap for the dataset'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image-VCRY5EOD.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.64: Correlation heatmap for the dataset'
  prefs: []
  type: TYPE_NORMAL
- en: 'Plot a more compact heatmap having annotations for correlation values using
    the following subset of features:'
  prefs: []
  type: TYPE_NORMAL
- en: feature_subset = ['GarageArea','GarageCars','GarageCond', \
  prefs: []
  type: TYPE_NORMAL
- en: '''GarageFinish'', ''GarageQual'',''GarageType'', \'
  prefs: []
  type: TYPE_NORMAL
- en: '''GarageYrBlt'',''GrLivArea'',''LotArea'', \'
  prefs: []
  type: TYPE_NORMAL
- en: '''MasVnrArea'',''SalePrice'']'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now do the same as in the previous step, this time selecting only the above
    columns in the dataset and adding a parameter, annot, with a True value to the
    primary plotting function, with everything else remaining the same:'
  prefs: []
  type: TYPE_NORMAL
- en: plt.figure(figsize = (12,10))
  prefs: []
  type: TYPE_NORMAL
- en: sns.heatmap(data[feature_subset].corr(), square=True, \
  prefs: []
  type: TYPE_NORMAL
- en: annot=True, cmap="RdBu", vmin=-1, vmax=1)
  prefs: []
  type: TYPE_NORMAL
- en: plt.show()
  prefs: []
  type: TYPE_NORMAL
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.65: Correlation heatmap for a feature subset with annotations'
  prefs: []
  type: TYPE_NORMAL
- en: for correlation values
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image-20XN5WXG.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.65: Correlation heatmap for a feature subset with annotations for
    correlation values'
  prefs: []
  type: TYPE_NORMAL
- en: 'Display the pairplot for the same subset of features, with the KDE plot on
    the diagonals and the scatter plot elsewhere. Use seaborn''s .pairplot() function
    to plot the pairplot for the non-null values in the selected columns of the DataFrame.
    To render the diagonal KDE plots, pass kde to the diag_kind parameter and, to
    set all other plots as scatter plots, pass scatter to the kind parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: sns.pairplot(data[feature_subset].dropna(), \
  prefs: []
  type: TYPE_NORMAL
- en: kind ='scatter', diag_kind='kde')
  prefs: []
  type: TYPE_NORMAL
- en: plt.show()
  prefs: []
  type: TYPE_NORMAL
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.66: Pairplot for the same subset of features'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image-NOERLBX6.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.66: Pairplot for the same subset of features'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a boxplot to show the variation in SalePrice for each category of GarageCars.
    The primary plotting function used here will be seaborn''s .boxplot() function,
    to which we pass the DataFrame along with the parameters x and y, the former being
    the categorical variable and the latter the continuous variable over which we
    want to see the variation within each category, that is, GarageCars and SalePrice,
    respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: plt.figure(figsize=(10, 10))
  prefs: []
  type: TYPE_NORMAL
- en: sns.boxplot(x='GarageCars', y="SalePrice", data=data)
  prefs: []
  type: TYPE_NORMAL
- en: plt.show()
  prefs: []
  type: TYPE_NORMAL
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.67: Boxplot showing the variation in SalePrice for each category
    of GarageCars'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image-IOJJQAGE.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.67: Boxplot showing the variation in SalePrice for each category of
    GarageCars'
  prefs: []
  type: TYPE_NORMAL
- en: 'Plot a line graph using seaborn to show the variation in SalePrice for older
    to more recently built flats. Here, we will plot a line graph using seaborn''s
    .lineplot() function. Since we want to see the variation in SalePrice, we take
    this as the y variable and, since the variation is across a period of time, we
    take YearBuilt as the x variable. Keeping this in mind, we pass the respective
    series as values to the y and x parameters for the primary plotting function.
    We also pass a ci=None parameter to hide the standard deviation indicator around
    the line in the plot:'
  prefs: []
  type: TYPE_NORMAL
- en: plt.figure(figsize=(10,7))
  prefs: []
  type: TYPE_NORMAL
- en: sns.lineplot(x=data.YearBuilt, y=data.SalePrice, ci=None)
  prefs: []
  type: TYPE_NORMAL
- en: plt.show()
  prefs: []
  type: TYPE_NORMAL
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.68: Line graph showing the variation in SalePrice for older to more
    recently'
  prefs: []
  type: TYPE_NORMAL
- en: built flats
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image-GI1DMCQ1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.68: Line graph showing the variation in SalePrice for older to more
    recently built flats'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.68 illustrates how to use a line chart to emphasize both overall trends
    and the ups and downs on shorter time cycles. You may want to compare this chart
    to a scatter chart of the same data and consider what sort of information each
    conveys.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to https://packt.live/2Z4bqHM.
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at https://packt.live/2Nl5ggI. You must
    execute the entire Notebook in order to get the desired result.
  prefs: []
  type: TYPE_NORMAL
