["```py\ndf = pd.DataFrame(\n    {\n        'gender': np.random.binomial(1, .6, 100),\n        'height': np.random.normal(0, 10, 100), \n        'noise': np.random.normal(0, 2, 100), \n    }\n)\n\ndf['height'] = df['height'] + df['gender'].apply(\n    lambda g: 150 if g else 180\n)\ndf['height (with 75% NaN)'] = df['height'].apply(\n    lambda x: x if np.random.binomial(1, .25, 1)[0] else np.nan\n)\ndf['weight'] = df['height'] + df['noise'] - 110\n```", "```py\ndf.isnull().mean()\n```", "```py\ndf['height (75% zero imputed)'] = df['height (with 75% NaN)'].fillna(0)\n```", "```py\nfrom sklearn.linear_model import Ridge\nfrom sklearn.metrics import mean_squared_error\n\nreg = Ridge()\nx, y = df[['height (75% zero imputed)']], df['weight']\nreg.fit(x, y)\nmean_squared_error(y, reg.predict(x))\n```", "```py\nfrom sklearn.impute import SimpleImputer\nimp = SimpleImputer(missing_values=np.nan, strategy='mean')\ndf['height (75% mean imputed)'] = imp.fit_transform(\n    df[['height (with 75% NaN)']]\n)[:, 0]\n```", "```py\n# We need to enable the module first since it is an experimental one \nfrom sklearn.experimental import enable_iterative_imputer\nfrom sklearn.impute import IterativeImputer\nimp = IterativeImputer(missing_values=np.nan)\ndf['height (75% iterative imputed)'] = imp.fit_transform(\n    df[['height (with 75% NaN)', 'gender']]\n)[:, 0]\n```", "```py\n          pip install category_encoders\n\n```", "```py\ndf = pd.DataFrame({\n    'Size': np.random.choice(['XS', 'S', 'M', 'L', 'XL', 'XXL'], 10),\n    'Brand': np.random.choice(['Nike', 'Puma', 'Adidas', 'Le Coq', 'Reebok'], 10),\n})\n```", "```py\nfrom sklearn.model_selection import train_test_split\ndf_train, df_test = train_test_split(df, test_size=0.5)\n```", "```py\nfrom category_encoders.one_hot import OneHotEncoder\nencoder = OneHotEncoder(use_cat_names=True, handle_unknown='return_nan')\nx_train = encoder.fit_transform(df_train)\nx_test = encoder.transform(df_test)\n```", "```py\nfrom category_encoders.ordinal import OrdinalEncoder\n\noencoder = OrdinalEncoder(\n  mapping= [\n    {\n      'col': 'Size', \n      'mapping': {'XS': 1, 'S': 2, 'M': 3, 'L': 4, 'XL': 5}\n    }\n  ]\n)\n\ndf_train.loc[\n  :, 'Size [Ordinal Encoded]'\n] = oencoder.fit_transform(\n  df_train['Size']\n)['Size'].values\ndf_test.loc[\n  :, 'Size [Ordinal Encoded]'\n] = oencoder.transform(\n  df_test['Size']\n)['Size'].values\n```", "```py\nfrom sklearn.preprocessing import StandardScaler\n\nscaler = StandardScaler()\nx_train_scaled = scaler.fit_transform(x_train)\nx_test_scaled = scaler.transform(x_test)\n```", "```py\nfrom sklearn.preprocessing import MinMaxScaler\n\nscaler = MinMaxScaler(feature_range=(0,1))\nx_train_scaled = scaler.fit_transform(x_train)\nx_test_scaled = scaler.transform(x_test)\n```", "```py\nfrom sklearn.preprocessing import RobustScaler\n\nscaler = RobustScaler()\nx_train_scaled = scaler.fit_transform(x_train)\nx_test_scaled = scaler.transform(x_test)\n```", "```py\nfrom sklearn import datasets\n\nwine = datasets.load_wine()\ndf = pd.DataFrame(\n    wine.data,\n    columns=wine.feature_names\n)\ndf['target'] = pd.Series(\n    wine.target\n)\n```", "```py\nfrom sklearn.model_selection import train_test_split\ndf_train, df_test = train_test_split(df, test_size=0.4)\n\nx_train = df_train[wine.feature_names]\nx_test = df_test[wine.feature_names]\n\ny_train = df_train['target']\ny_test = df_test['target']\n```", "```py\nfrom sklearn.feature_selection import VarianceThreshold\nvt = VarianceThreshold(threshold=0)\nvt.fit(x_train)\n```", "```py\nx_train = x_train.iloc[:, vt.get_support()]\nx_test = x_test.iloc[:, vt.get_support()]\n```", "```py\npd.DataFrame(\n    {\n        'Feature': wine.feature_names,\n        'Variance': vt.variances_,\n    }\n).sort_values(\n    'Variance', ascending=True\n)\n```", "```py\nfrom sklearn.feature_selection import f_classif\nf, p = f_classif(x_train, y_train)\n```", "```py\nfrom sklearn.feature_selection import mutual_info_classif\nmi = mutual_info_classif(x_train, y_train)\n```", "```py\npd.DataFrame(\n  {\n    'Feature': wine.feature_names,\n    'F': f,\n    'MI': mi,\n  }\n).sort_values(\n  'MI', ascending=False\n).style.bar(\n  subset=['F', 'MI'], color='grey'\n)\n```"]