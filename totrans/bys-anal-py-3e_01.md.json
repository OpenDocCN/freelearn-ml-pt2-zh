["```py\nnp.random.seed(123) \n\ntrials = 4 \ntheta_real = 0.35 # unknown value in a real experiment \ndata = pz.Binomial(n=1, p=theta_real).rvs(trials)\n```", "```py\nwith pm.Model() as our_first_model: \n    *θ* = pm.Beta('*θ*', alpha=1., beta=1.) \n    y = pm.Bernoulli('y', p=*θ*, observed=data) \n    idata = pm.sample(1000)\n```", "```py\nAuto-assigning NUTS sampler... Initializing NUTS using jitter+adapt_diag... Multiprocess sampling (4 chains in 4 jobs)\nNUTS: [*θ*]\nSampling 4 chains for 1_000 tune and 1_000 draw iterations (4_000 + 4_000 draws total) took 1 second.\n```", "```py\naz.plot_trace(idata)\n```", "```py\naz.plot_trace(idata, kind=\"rank_bars\", combined=True)\n```", "```py\naz.summary(idata, kind=\"stats\").round(2)\n```", "```py\naz.plot_posterior(idata)\n```", "```py\naz.plot_bf(idata, var_name=\"*θ*\", \n           prior=np.random.uniform(0, 1, 10000), ref_val=0.5);\n```", "```py\naz.plot_posterior(idata, rope=[0.45, .55])\n```", "```py\naz.plot_posterior(idata, ref_val=0.5)\n```", "```py\ngrid = np.linspace(0, 1, 200) \n*θ*_pos = idata.posterior['*θ*'] \nlossf_a = [np.mean(abs(i - *θ*_pos)) for i in grid] \nlossf_b = [np.mean((i - *θ*_pos)**2) for i in grid] \nfor lossf, c in zip([lossf_a, lossf_b], ['C0', 'C1']): \n    ...\n```", "```py\nlossf = [] \nfor i in grid: \n    if i < 0.5: \n        f = 1/np.median(*θ*_pos / np.abs(i**2 - *θ*_pos)) \n    else: \n        f = np.mean((i - *θ*_pos)**2 + np.exp(-i)) - 0.25 \n    lossf.append(f)\n```", "```py\nwith pm.Model() as model_g: \n    μ = pm.Uniform('μ', lower=40, upper=70) \n    σ = pm.HalfNormal('σ', sigma=5) \n    Y = pm.Normal('Y', mu=μ, sigma=σ, observed=data) \n    idata_g = pm.sample()\n```", "```py\naz.summary(idata_g, kind=\"stats\").round(2)\n```", "```py\npm.sample_posterior_predictive(idata_g, model=model_g, \n                              extend_inferencedata=True)\n```", "```py\naz.plot_ppc(idata_g, num_pp_samples=100)\n```", "```py\nwith pm.Model() as model_t: \n    μ = pm.Uniform('μ', 40, 75) \n    σ = pm.HalfNormal('σ', sigma=10) \n    ν = pm.Exponential('ν', 1/30) \n    y = pm.StudentT('y', nu=ν, mu=μ, sigma=σ, observed=data) \n    idata_t = pm.sample()\n```", "```py\nposterior = idata_g.posterior\n```", "```py\nposterior.sel(draw=0, chain=[0, 2])\n```", "```py\nposterior.sel(draw=slice(0, 100))\n```", "```py\nposterior.mean()\n```", "```py\nposterior.mean(\"draw\")\n```", "```py\nstacked = az.extract(idata_g)\n```", "```py\naz.extract(idata_g, num_samples=100)\n```", "```py\ntips = pd.read_csv(\"data/tips.csv\") \ntips.tail()\n```", "```py\ncategories = np.array([\"Thur\", \"Fri\", \"Sat\", \"Sun\"]) \ntip = tips[\"tip\"].values \nidx = pd.Categorical(tips[\"day\"], categories=categories).codes\n```", "```py\nwith pm.Model() as comparing_groups: \n    μ = pm.Normal(\"μ\", mu=0, sigma=10, shape=4) \n    σ = pm.HalfNormal(\"σ\", sigma=10, shape=4) \n\n    y = pm.Normal(\"y\", mu=μ[idx], sigma=σ[idx], observed=tip)\n```", "```py\ncoords = {\"days\": categories, \"days_flat\":categories[idx]} \n\nwith pm.Model(coords=coords) as comparing_groups: \n    μ = pm.HalfNormal(\"μ\", sigma=5, dims=\"days\") \n    σ = pm.HalfNormal(\"σ\", sigma=1, dims=\"days\") \n\n    y = pm.Gamma(\"y\", mu=μ[idx], sigma=σ[idx], observed=tip, dims=\"days_flat\") \n\n    idata_cg = pm.sample() \n    idata_cg.extend(pm.sample_posterior_predictive(idata_cg))\n```", "```py\n_, axes = plt.subplots(2, 2) \naz.plot_ppc(idata_cg, num_pp_samples=100, \n            coords={\"days_flat\":[categories]}, flatten=[], ax=axes)\n```"]