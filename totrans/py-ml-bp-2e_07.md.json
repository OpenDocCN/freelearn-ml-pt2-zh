["```py\n!pip install pandas_datareader \n```", "```py\nimport pandas as pd \nfrom pandas_datareader import data, wb \nimport matplotlib.pyplot as plt \n\n%matplotlib inline \npd.set_option('display.max_colwidth', 200) \n```", "```py\nimport pandas_datareader as pdr \n\nstart_date = pd.to_datetime('2010-01-01') \nstop_date = pd.to_datetime('2018-12-01') \n\nspy = pdr.data.get_data_yahoo('SPY', start_date, stop_date) \n```", "```py\nspy_c = spy['Close'] \n\nfig, ax = plt.subplots(figsize=(15,10)) \nspy_c.plot(color='k') \nplt.title(\"SPY\", fontsize=20); \n```", "```py\nfirst_open = spy['Open'].iloc[0] \nfirst_open \n```", "```py\nlast_close = spy['Close'].iloc[-1] \nlast_close \n```", "```py\nlast_close - first_open \n```", "```py\nspy['Daily Change'] = pd.Series(spy['Close'] - spy['Open']) \n```", "```py\nspy['Daily Change'] \n```", "```py\nspy['Daily Change'].sum() \n```", "```py\nnp.std(spy['Daily Change']) \n```", "```py\nspy['Overnight Change'] = pd.Series(spy['Open'] - spy['Close'].shift(1)) \n\nnp.std(spy['Overnight Change']) \n```", "```py\n spy[spy['Daily Change']<0]['Daily Change'].mean() \n```", "```py\n spy[spy['Overnight Change']<0]['Overnight Change'].mean() \n```", "```py\ndaily_rtn = ((spy['Close'] - spy['Close'].shift(1))/spy['Close'].shift(1))*100 \n\nid_rtn = ((spy['Close'] - spy['Open'])/spy['Open'])*100 \n\non_rtn = ((spy['Open'] - spy['Close'].shift(1))/spy['Close'].shift(1))*100 \n```", "```py\nDaily_rtn \n```", "```py\ndef get_stats(s, n=252): \n    s = s.dropna() \n    wins = len(s[s>0]) \n    losses = len(s[s<0]) \n    evens = len(s[s==0]) \n    mean_w = round(s[s>0].mean(), 3) \n    mean_l = round(s[s<0].mean(), 3) \n    win_r = round(wins/losses, 3) \n    mean_trd = round(s.mean(), 3) \n    sd = round(np.std(s), 3) \n    max_l = round(s.min(), 3) \n    max_w = round(s.max(), 3) \n    sharpe_r = round((s.mean()/np.std(s))*np.sqrt(n), 4) \n    cnt = len(s) \n    print('Trades:', cnt,\\ \n          '\\nWins:', wins,\\ \n          '\\nLosses:', losses,\\ \n          '\\nBreakeven:', evens,\\ \n          '\\nWin/Loss Ratio', win_r,\\ \n          '\\nMean Win:', mean_w,\\ \n          '\\nMean Loss:', mean_l,\\ \n          '\\nMean', mean_trd,\\ \n          '\\nStd Dev:', sd,\\ \n          '\\nMax Loss:', max_l,\\ \n          '\\nMax Win:', max_w,\\ \n          '\\nSharpe Ratio:', sharpe_r) \n```", "```py\nget_stats(daily_rtn) \n```", "```py\nget_stats(id_rtn) \n```", "```py\nget_stats(on_rtn) \n```", "```py\nstart_date = pd.to_datetime('2000-01-01') \nstop_date = pd.to_datetime('2018-12-01') \n\nsp = pdr.data.get_data_yahoo('SPY', start_date, stop_date) \n```", "```py\nfig, ax = plt.subplots(figsize=(15,10)) \nsp['Close'].plot(color='k') \nplt.title(\"SPY\", fontsize=20) \n```", "```py\nlong_day_rtn = ((sp['Close'] - sp['Close'].shift(1))/sp['Close'].shift(1))*100 \n\nlong_id_rtn = ((sp['Close'] - sp['Open'])/sp['Open'])*100 \n\nlong_on_rtn = ((sp['Open'] - sp['Close'].shift(1))/sp['Close'].shift(1))*100 \n```", "```py\n(sp['Close'] - sp['Close'].shift(1)).sum() \n```", "```py\n(sp['Close'] - sp['Open']).sum() \n```", "```py\n(sp['Open'] - sp['Close'].shift(1)).sum() \n```", "```py\nget_stats(long_day_rtn) \n```", "```py\nget_stats(long_id_rtn) \n```", "```py\nget_stats(long_on_rtn) \n```", "```py\nfor i in range(1, 21, 1): \n    sp.loc[:,'Close Minus ' + str(i)] = sp['Close'].shift(i) \n\nsp20 = sp[[x for x in sp.columns if 'Close Minus' in x or x == 'Close']].iloc[20:,] \n\nsp20 \n```", "```py\nsp20 = sp20.iloc[:,::-1] \n\nsp20 \n```", "```py\nfrom sklearn.svm import SVR \nclf = SVR(kernel='linear') \n\nX_train = sp20[:-2000] \ny_train = sp20['Close'].shift(-1)[:-2000] \n\nX_test = sp20[-2000:] \ny_test = sp20['Close'].shift(-1)[-2000:] \n```", "```py\nmodel = clf.fit(X_train, y_train) \n\npreds = model.predict(X_test) \n```", "```py\ntf = pd.DataFrame(list(zip(y_test, preds)), columns=['Next Day Close', 'Predicted Next Close'], index=y_test.index) \n\ntf \n```", "```py\ncdc = sp[['Close']].iloc[-1000:] \nndo = sp[['Open']].iloc[-1000:].shift(-1) \n\ntf1 = pd.merge(tf, cdc, left_index=True, right_index=True) \ntf2 = pd.merge(tf1, ndo, left_index=True, right_index=True) \ntf2.columns = ['Next Day Close', 'Predicted Next Close', 'Current Day Close', 'Next Day Open'] \n\ntf2 \n```", "```py\ndef get_signal(r): \n    if r['Predicted Next Close'] > r['Next Day Open']: \n        return 1 \n    else: \n        return 0 \n\ndef get_ret(r): \n    if r['Signal'] == 1: \n        return ((r['Next Day Close'] - r['Next Day Open'])/r['Next Day Open']) * 100 \n    else: \n        return 0 \n\ntf2 = tf2.assign(Signal = tf2.apply(get_signal, axis=1)) \ntf2 = tf2.assign(PnL = tf2.apply(get_ret, axis=1)) \n\ntf2 \n```", "```py\n(tf2[tf2['Signal']==1]['Next Day Close'] - tf2[tf2['Signal']==1]['Next Day Open']).sum() \n```", "```py\n(sp['Close'].iloc[-2000:] - sp['Open'].iloc[-2000:]).sum() \n```", "```py\nget_stats((sp['Close'].iloc[-2000:] - sp['Open'].iloc[-2000:])/sp['Open'].iloc[-2000:] * 100) \n```", "```py\nget_stats(tf2['PnL']) \n```", "```py\ndef get_signal(r): \n    if r['Predicted Next Close'] > r['Next Day Open'] + 1: \n        return 1 \n    else: \n        return 0 \n\ndef get_ret(r): \n    if r['Signal'] == 1: \n        return ((r['Next Day Close'] - r['Next Day Open'])/r['Next Day Open']) * 100 \n    else: \n        return 0 \n\ntf2 = tf2.assign(Signal = tf2.apply(get_signal, axis=1)) \ntf2 = tf2.assign(PnL = tf2.apply(get_ret, axis=1)) \n\n(tf2[tf2['Signal']==1]['Next Day Close'] - tf2[tf2['Signal']==1]['Next Day Open']).sum() \n```", "```py\nget_stats(tf2['PnL']) \n```", "```py\ndef get_signal(r): \n    if r['Predicted Next Close'] > r['Next Day Open'] + 1: \n        return 0 \n    else: \n        return 1 \n\ndef get_ret(r): \n    if r['Signal'] == 1: \n        return ((r['Next Day Close'] - r['Next Day Open'])/r['Next Day Open']) * 100 \n    else: \n        return 0 \n\ntf2 = tf2.assign(Signal = tf2.apply(get_signal, axis=1)) \ntf2 = tf2.assign(PnL = tf2.apply(get_ret, axis=1)) \n\n(tf2[tf2['Signal']==1]['Next Day Close'] - tf2[tf2['Signal']==1]['Next Day Open']).sum() \n```", "```py\nget_stats(tf2['PnL']) \n```", "```py\n!pip install fastdtw \n```", "```py\nfrom scipy.spatial.distance import euclidean \nfrom fastdtw import fastdtw \n```", "```py\ndef dtw_dist(x, y): \n    distance, path = fastdtw(x, y, dist=euclidean) \n    return distance \n```", "```py\ntseries = [] \ntlen = 5 \nfor i in range(tlen, len(sp), tlen): \n    pctc = sp['Close'].iloc[i-tlen:i].pct_change()[1:].values * 100 \n    res = sp['Close'].iloc[i-tlen:i+1].pct_change()[-1] * 100 \n    tseries.append((pctc, res)) \n```", "```py\ntseries[0] \n```", "```py\ndist_pairs = [] \nfor i in range(len(tseries)): \n    for j in range(len(tseries)): \n        dist = dtw_dist(tseries[i][0], tseries[j][0]) \n        dist_pairs.append((i,j,dist,tseries[i][1], tseries[j][1])) \n```", "```py\ndist_frame = pd.DataFrame(dist_pairs, columns=['A','B','Dist', 'A Ret', 'B Ret']) \n\nsf = dist_frame[dist_frame['Dist']>0].sort_values(['A','B']).reset_index(drop=1) \n\nsfe = sf[sf['A']<sf['B']] \n```", "```py\nwinf = sfe[(sfe['Dist']<=1)&(sfe['A Ret']>0)] \n\nwinf \n```", "```py\nplt.plot(np.arange(4), tseries[6][0]); \n```", "```py\nplt.plot(np.arange(4), tseries[598][0]) \n```", "```py\nexcluded = {} \nreturn_list = [] \ndef get_returns(r): \n    if excluded.get(r['A']) is None: \n        return_list.append(r['B Ret']) \n        if r['B Ret'] < 0: \n            excluded.update({r['A']:1}) \n\nwinf.apply(get_returns, axis=1); \n```", "```py\nget_stats(pd.Series(return_list)) \n```"]