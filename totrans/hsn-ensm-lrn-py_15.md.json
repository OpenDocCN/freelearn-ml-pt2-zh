["```py\nimport numpy as np\nimport pandas as pd\nfrom simulator import simulate\nfrom sklearn import metrics\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.model_selection import train_test_split\nnp.random.seed(123456)\nlr = LinearRegression()\ndata = pd.read_csv('BTC-USD.csv')\n```", "```py\ndata = data.dropna()\ndata.Date = pd.to_datetime(data.Date)\ndata.set_index('Date', drop=True, inplace=True)\ndiffs = (data.Close.diff()/data.Close).values[1:]\n\ndiff_len = len(diffs)\n```", "```py\ndef create_x_data(lags=1):\n diff_data = np.zeros((diff_len, lags))\n\nfor lag in range(1, lags+1):\n this_data = diffs[:-lag]\n diff_data[lag:, lag-1] = this_data\n\nreturn diff_data\n\n# REPRODUCIBILITY\nx_data = create_x_data(lags=20)*100\ny_data = diffs*100\n```", "```py\nwindow = 150\npreds = np.zeros(diff_len-window)\nfor i in range(diff_len-window-1):\n x_train = x_data[i:i+window, :]\n y_train = y_data[i:i+window]\n lr.fit(x_train, y_train)\n preds[i] = lr.predict(x_data[i+window+1, :].reshape(1, -1))\n\nprint('Percentages MSE: %.2f'%metrics.mean_absolute_error(y_data[window:], preds))\n```", "```py\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n\nfrom sklearn import metrics\n\ndef simulate(data, preds):\n # Constants and placeholders\n buy_threshold = 0.5\n stake = 100\n\ntrue, pred, balances = [], [], []\n\nbuy_price = 0\n buy_points, sell_points = [], []\n balance = 0\n\nstart_index = len(data)-len(preds)-1\n```", "```py\n# Calculate predicted values\n for i in range(len(preds)):\n\nlast_close = data.Close[i+start_index-1]\n current_close = data.Close[i+start_index]\n\n# Save predicted values and true values\n true.append(current_close)\n pred.append(last_close*(1+preds[i]/100))\n\n # Buy/Sell according to signal\n if preds[i] > buy_threshold and buy_price == 0:\n buy_price = true[-1]\n buy_points.append(i)\n\nelif preds[i] < -buy_threshold and not buy_price == 0:\n profit = (current_close - buy_price) * stake/buy_price\n balance += profit\n buy_price = 0\n sell_points.append(i)\n\nbalances.append(balance)\n true = np.array(true)\n pred = np.array(pred)\n\n# Create plots\n plt.figure()\n\nplt.subplot(2, 1, 1)\n plt.plot(true, label='True')\n plt.plot(pred, label='pred')\n plt.scatter(buy_points, true[buy_points]+500, marker='v',\n c='blue', s=5, zorder=10)\n plt.scatter(sell_points, true[sell_points]-500, marker='^'\n , c='red', s=5, zorder=10)\n plt.title('Trades')\n\nplt.subplot(2, 1, 2)\n plt.plot(balances)\n plt.title('Profit')\n print('MSE: %.2f'%metrics.mean_squared_error(true, pred))\n balance_df = pd.DataFrame(balances)\n\npct_returns = balance_df.diff()/stake\n pct_returns = pct_returns[pct_returns != 0].dropna()\n\n print('Sharpe: %.2f'%(np.mean(pct_returns)/np.std(pct_returns)))\n```", "```py\nimport numpy as np\nfrom copy import deepcopy\n\nclass VotingRegressor():\n\n# Accepts a list of (name, classifier) tuples\n def __init__(self, base_learners):\n self.base_learners = {}\n for name, learner in base_learners:\n self.base_learners[name] = deepcopy(learner)\n\n # Fits each individual base learner\n def fit(self, x_data, y_data):\n for name in self.base_learners:\n learner = self.base_learners[name]\n learner.fit(x_data, y_data)\n```", "```py\n# Generates the predictions\n def predict(self, x_data):\n\n# Create the predictions matrix\n predictions = np.zeros((len(x_data), len(self.base_learners)))\n\nnames = list(self.base_learners.keys())\n\n# For each base learner\n for i in range(len(self.base_learners)):\n name = names[i]\n learner = self.base_learners[name]\n\n# Store the predictions in a column\n preds = learner.predict(x_data)\n predictions[:,i] = preds\n\n# Take the row-average\n predictions = np.mean(predictions, axis=1)\n return predictions\n```", "```py\nimport numpy as np\nimport pandas as pd\n\nfrom simulator import simulate\nfrom sklearn import metrics\nfrom sklearn.neighbors import KNeighborsRegressor\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.svm import SVR\nfrom voting_regressor import VotingRegressor\n```", "```py\nbase_learners = [('SVR', SVR()),\n ('LR', LinearRegression()),\n ('KNN', KNeighborsRegressor())]\n\nlr = VotingRegressor(base_learners)\n```", "```py\nbase_learners = [('SVR', SVR()), ('KNN', KNeighborsRegressor())]\n```", "```py\n # Generates the predictions\n def predict(self, x_data):\n\n# Create the predictions matrix\n predictions = np.zeros((len(x_data), len(self.base_learners)))\n\nnames = list(self.base_learners.keys())\n\n# For each base learner\n for i in range(len(self.base_learners)):\n name = names[i]\n learner = self.base_learners[name]\n\n# Store the predictions in a column\n preds = learner.predict(x_data)\n predictions[:,i] = preds\n\n# Take the row-average\n predictions = np.mean(predictions, axis=1)\n return predictions\n```", "```py\nbase_learners = [[SVR(), LinearRegression(), KNeighborsRegressor()],\n                [LinearRegression()]]\nlr = StackingRegressor(base_learners)\n```", "```py\nlr = XGBRegressor(max_depth=2, n_estimators=10, reg_alpha=0.5)\n```", "```py\ndef create_x_data(lags=1):\n diff_data = np.zeros((diff_len, lags))\n ma_data = np.zeros((diff_len, lags))\n\n diff_ma = (data.Close.diff()/data.Close).rolling(15).mean().fillna(0).values[1:]\n for lag in range(1, lags+1):\n this_data = diffs[:-lag]\n diff_data[lag:, lag-1] = this_data\n\n this_data = diff_ma[:-lag]\n ma_data[lag:, lag-1] = this_data\n return np.concatenate((diff_data, ma_data), axis=1)\n\nx_data = create_x_data(lags=30)*100\ny_data = diffs*100\n```"]