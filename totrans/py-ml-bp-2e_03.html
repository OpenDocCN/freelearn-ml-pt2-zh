<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Build an App to Find Cheap Airfares</h1>
                </header>
            
            <article>
                
<p><span class="HeaderFooterPACKT">Let's talk about mistakes. They're part of life; everyone makes them—even airlines.</span></p>
<p><span class="HeaderFooterPACKT">In 2014, I happened to be reading my Twitter feed one afternoon when one of the accounts I follow tweeted that a major US airline had fares to Europe that were significantly below what would be expected. At the time, the cheapest fare from New York to Vienna was around $800, but the advertised fares for a select number of dates were between $350 and $450. This seemed too good to be true. But it wasn't. I had lucked upon what's known in the industry as a <em>mistake fare</em>.</span></p>
<p><span class="HeaderFooterPACKT">In the super-secretive society of travel hackers and mileage junkies, it's well-known that airlines occasionally—and accidentally—post fares that exclude fuel surcharges. And remarkably, this isn't the only type of mistake they make. You might expect advanced algorithms would be updating fares for each flight, taking into account an enormous number of factors. And for the most part, you'd be right. But due to legacy systems and the complexity of dealing with multiple carriers and multiple jurisdictions, mistakes do sometimes occur.</span></p>
<p><span class="HeaderFooterPACKT">Here is a list of some of these more recent mistake fares:</span></p>
<ul>
<li><span class="HeaderFooterPACKT">In 2007, United Airlines sold business fare tickets from San Francisco to New Zealand for $1,500</span></li>
<li><span class="HeaderFooterPACKT">In 2013, Delta sold economy fare tickets from multiple US cities to Hawaii for $6.90</span></li>
<li><span class="HeaderFooterPACKT">In 2015, American Airlines sold business class fares to China from Washington, DC for $450</span></li>
</ul>
<p class="mce-root"/>
<p><span class="HeaderFooterPACKT">Now that you know these fares exist, how can you get in on them? Machine learning, of course! Since they typically last just a few hours before they disappear, we're going to build an application that continually monitors fare pricing, checking for anomalous prices that will generate an alert we can quickly act on.</span></p>
<p><span class="HeaderFooterPACKT">Here's what we'll cover in this chapter:</span></p>
<ul>
<li>Sourcing airfare pricing on the web</li>
<li>Retrieving fare data with advanced web scraping techniques</li>
<li>Parsing the DOM to extract prices</li>
<li>Identifying outlier fares with anomaly detection techniques</li>
<li>Sending real-time text alerts with IFTTT</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sourcing airfare pricing data</h1>
                </header>
            
            <article>
                
<p>Fortunately, sourcing airfare data is somewhat easier that real estate data. There are a number of providers of this data, as well as paid and unpaid APIs. One challenging aspect of retrieving the data is that it requires a number of web requests. In the previous edition of this book, we outlined how to scrape data from Google's <strong>Flight Explorer</strong> page. This was the ideal presentation for seeing weeks of pricing data on one page for multiple cities. Unfortunately, that page has now been removed, and Google now provides a more typical search interface that requires the user to input the departure city, the destination city, start date, and end date. One fortunate feature that remains is the ability to input an entire region rather than a specific city. We'll make use of this in our scraping. An example of this can be seen in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1013 image-border" src="assets/02d0154d-8231-47b0-ad25-e8e5ed48eb86.png" style="width:151.75em;height:78.33em;"/></p>
<p>As you can see, we have input <kbd>New York</kbd> as our departure city and simply put <kbd>Asia</kbd> as our destination. This returns pricing for all the top cities in Asia (as well as the Middle East, for some reason). This is great news as we want to capture as many prices in one web request as possible.</p>
<p>While the interface still has some features that make it easier to scrape this data, we'll need to use some more advanced techniques than we've used in the past. We'll discuss that next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Retrieving fare data with advanced web scraping</h1>
                </header>
            
            <article>
                
<p>In previous chapters, we've seen how to use the <kbd>Requests</kbd> library to retrieve web pages. As I've said before, it is a fantastic tool, but unfortunately, it won't work for us here. The page we want to scrape is entirely AJAX-based. <strong>Asynchronous JavaScript</strong> (<strong>AJAX</strong>) is a method for retrieving data from a server without having to reload the page. What this means for us is that we'll need to use a browser to retrieve the data. While that might sound like it would require an enormous amount of overhead, there are two libraries that, when used together, make it a lightweight task.</p>
<p class="mce-root"/>
<p>The two libraries are Selenium and ChromeDriver. Selenium is a powerful tool for automating web browsers, and ChromeDriver is a browser. Why use ChromeDriver rather than Firefox or Chrome itself? ChromeDriver is what's known as a <strong>headless browser</strong>. This means it has no user interface. This keeps it lean, making it ideal for what we're trying to do.</p>
<div class="packt_infobox">To install ChromeDriver, you can download the binaries or source from <a href="https://sites.google.com/a/chromium.org/chromedriver/downloads" target="_blank"><span class="URLPACKT">https://sites.google.com/a/chromium.org/chromedriver/downloads</span></a>. As for Selenium, it can be pip installed.</div>
<p>We'll also need another library called <kbd>BeautifulSoup</kbd> to parse the data from the page. If you don't have that installed, you should <kbd>pip install</kbd> that now as well.</p>
<p>With that done, let's get started. We'll start out within the Jupyter Notebook. This works best for exploratory analysis. Later, when we've completed our exploration, we'll move on to working in a text editor for the code we want to deploy. This is done in following steps:</p>
<ol>
<li>First, we import our routine libraries, as shown in the following code snippet:</li>
</ol>
<pre style="padding-left: 60px"><strong>import numpy as np 
import pandas as pd 
import matplotlib.pyplot as plt 
%matplotlib inline </strong></pre>
<ol start="2">
<li>Next, make sure you have installed <kbd>BeautifulSoup</kbd> and <kbd>Selenium</kbd>, and downloaded <kbd>ChromeDriver</kbd>, as mentioned previously. We'll import those now in a new cell:</li>
</ol>
<pre style="padding-left: 60px"><strong>from bs4 import BeautifulSoup 
from selenium import webdriver 
 
# replace this with the path of where you downloaded chromedriver 
chromedriver_path = "/Users/alexcombs/Downloads/chromedriver" 
 
browser = webdriver.Chrome(chromedriver_path)</strong> </pre>
<p style="padding-left: 60px">Notice that I have referenced the path on my machine where I have downloaded <kbd>ChromeDriver</kbd>. Note that you will have to replace that line with the path on your own machine.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a link</h1>
                </header>
            
            <article>
                
<p>Now, remarkably, we have everything we need to begin our airline fare scraping, with one exception: we need the URL. For this exercise, I'm going to focus on flights leaving from NYC and flying to Europe. Since we don't want to pull down massive quantities of data and risk being blocked, we are going to just pull data for non-stop flights that depart on Saturday and return on the following Saturday. You are, of course, free to change this to whatever fares you'd like to target, but we'll use this for our sample project.</p>
<p>The next step is to fill out the form in <span class="packt_screen">Google Flights</span>. Make sure to choose a future date. Once you have input your data and hit <span class="packt_screen">Search</span>, copy the URL string from your browser bar, as seen in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1014 image-border" src="assets/508213ef-1d4f-4d8d-8dd3-59d5b186d821.png" style="width:162.50em;height:100.17em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The URL I copied is for flights that depart on <kbd>2018-12-01</kbd> and return on <kbd>2018-12-08</kbd>. Those dates can be seen in the search string. If you choose different dates, you should see those reflected in the string you copy. Let's code this now:</p>
<ol>
<li>Let's input that string and save it as the variable <kbd>sats</kbd>, as seen in the following block of code:</li>
</ol>
<pre style="padding-left: 60px"><strong>sats = 'https://www.google.com/flights/f=0#f=0&amp;flt=/m/02_286.r/m/02j9z.2018-12-01*r/m/02j9z./m/02_286.2018-12-08;c:USD;e:1;s:0*1;sd:1;t:e'</strong> </pre>
<ol start="2">
<li>Next, we'll test that we can successfully retrieve the content that we see on the page. We'll test that with the following line of code, which utilizes <kbd>selenium</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>browser.get(sats)</strong> </pre>
<ol start="3">
<li>That one line of code was all we needed to retrieve the page. We can validate that this was successful with a couple of additional lines of code.</li>
<li>First, let's check the title of the page:</li>
</ol>
<pre style="padding-left: 60px"><strong>browser.title</strong> </pre>
<p style="padding-left: 60px">The resulting output can be seen as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-349 image-border" src="assets/8098a33d-ea16-401c-b538-808ac5644ecc.png" style="width:14.08em;height:2.83em;"/></p>
<p>It looks like we were able to get the correct page. Let's now check to see whether we captured everything we were seeking. We can do that by taking a screenshot of the page. We do that with the following line of code:</p>
<pre><strong>browser.save_screenshot('/Users/alexcombs/Desktop/test_flights.png')</strong> </pre>
<p class="mce-root"/>
<p>Again, the path I used to save the screenshot was based on my machine; you will need to reference a path on your own machine. As you should see based on the following output, we were able to successfully get all the content of the page:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1015 image-border" src="assets/ad72822c-a619-48ff-8154-d6736d5f8c59.png" style="width:56.00em;height:31.25em;"/></p>
<p>Since we appear to have all the page data we were seeking, we will now move on to how to pull individual data points from the page. To do that, first, we'll need to learn about the <strong>Document Object Model</strong> (<strong>DOM</strong>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Parsing the DOM to extract pricing data</h1>
                </header>
            
            <article>
                
<p>The DOM is the collection of elements that comprise a web page. It includes HTML tags such as <kbd>body</kbd> and <kbd>div</kbd>, as well as the classes and IDs embedded within these tags.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Let's take a look at the DOM for our Google page:</p>
<ol>
<li>To see it, right-click on the page and click on <span class="packt_screen">Inspect</span>. This should be the same for Firefox or Chrome. This will open the developer tab that allows you to see the page source information, as demonstrated in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1016 image-border" src="assets/b0a6fcbc-0afa-421d-9664-23f9242afb5d.png" style="width:162.50em;height:98.58em;"/></p>
<ol start="2">
<li>Once this is open, choose the element selector in the upper left-hand corner, and click on an element to jump to that element in the page source code:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1017 image-border" src="assets/eb476064-5fec-4898-9022-582df358a0e5.png" style="width:162.50em;height:101.00em;"/></p>
<p class="mce-root"/>
<ol start="3">
<li>The element that we are concerned with is the box that contains the flight information. This can be seen in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1018 image-border" src="assets/545cff57-fc62-4ec7-8698-f204cb72cd2b.png" style="width:162.50em;height:99.33em;"/></p>
<p style="padding-left: 60px">If you look closely at the element, you will notice that it is an element called a <kbd>div</kbd>. This div has an attribute called <kbd>class</kbd>. The is a long string of random numbers and letters in this <kbd>class</kbd>, but you will also notice that it contains the string <kbd>info-container</kbd>. We can use this information to retrieve all the <kbd>div</kbd> elements that have flight information for each city. We'll do that in a minute, but for now, let's discuss the parsing process.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Parsing</h1>
                </header>
            
            <article>
                
<p>To begin our parsing, we will need to use the library we mentioned earlier called <kbd>BeautifulSoup</kbd>. We imported it earlier, so now we just need to pass the page source into <kbd>BeautifulSoup</kbd>. We do that by means of the following code:</p>
<pre><strong>soup = BeautifulSoup(browser.page_source, "html5lib")</strong> </pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Notice that the browser object contains a <kbd>page_source</kbd> attribute. That is all the HTML we retrieved with our <kbd>get</kbd> request earlier. The other parameter passed into <kbd>BeautifulSoup</kbd> is the parsing library it will use. Here, we will stick with <kbd>html5lib</kbd>.</p>
<p>Now, once the content of the page has been passed to <kbd>BeautifulSoup</kbd>, we want to start to extract the elements of interest. That's where the <kbd>div</kbd> elements with the <kbd>info-container</kbd> class come in. We are going to retrieve those. Each one corresponds to a single city.</p>
<p>Let's retrieve them, but we'll just look at the first one:</p>
<pre><strong>cards = soup.select('div[class*=info-container]') 
 
</strong><strong>cards[0]</strong> </pre>
<p>The output for the preceding code is shown as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-355 image-border" src="assets/9a502333-31f6-438b-a335-bc17013ed6da.png" style="width:146.17em;height:58.33em;"/></p>
<p>In the preceding code, we used the <kbd>select</kbd> method on our <kbd>soup</kbd> object. The select method allows us to use CSS selectors to reference the elements of interest. Here, we have specified that we want divs that have a <kbd>class</kbd> attribute that contains somewhere within the class name the string <kbd>info-container</kbd>. There is excellent documentation on BeautifulSoup that explains these CSS selectors and other methods, and is available at <span class="URLPACKT"><a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/#css-selectors">https://www.crummy.com/software/BeautifulSoup/bs4/doc/#css-selectors</a><a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/#css-selectors" target="_blank">.</a></span></p>
<p>Looking at the preceding output, notice that buried deep within the markup, there is the name of the destination city (<kbd>London</kbd>) and the fare price (<kbd>$440</kbd>). Since we just want the data and not all the surrounding markup, we'll need to create code to iterate over each <kbd>info-container</kbd> divs and pull out the city and the fare:</p>
<pre><strong>for card in cards: 
    print(card.select('h3')[0].text) 
    print(card.select('span[class*=price]')[0].text) 
    print('\n') </strong></pre>
<p>The preceding code results in the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1019 image-border" src="assets/227c0fc3-e4b5-4be8-9fee-cee005f602c8.png" style="width:7.58em;height:24.50em;"/></p>
<p>Since it looks as if we were able to successfully retrieve the fares for each city, let's now move on to constructing a full scrape and parse for a large number of fares.</p>
<p>We are now going to attempt to retrieve the lowest cost, non-stop fares from NYC to Europe for a 26-week period. I'm using a start date of December 01, 2018, but obviously, if you are reading this after that date, make sure to adjust your dates accordingly.</p>
<p>The first thing we'll need is to bring in some additional imports. We do that in the following code:</p>
<pre><strong>from datetime import date, timedelta 
from time import sleep</strong> </pre>
<p class="mce-root"/>
<p>Next, we'll construct the remainder of our scraping code:</p>
<pre><strong>start_sat = '2018-12-01' 
end_sat = '2018-12-08' 
 
start_sat_date = datetime.strptime(start_sat, '%Y-%m-%d') 
end_sat_date = datetime.strptime(end_sat, '%Y-%m-%d') 
 
fare_dict = {} 
 
for i in range(26):     
    sat_start = str(start_sat_date).split()[0] 
    sat_end = str(end_sat_date).split()[0] 
     
    fare_dict.update({sat_start: {}}) 
     
    sats = "https://www.google.com/flights/?f=0#f=0&amp;flt=/m/02_286.r/m/02j9z." + \ 
    sat_start + "*r/m/02j9z./m/02_286." + \ 
    sat_end + ";c:USD;e:1;s:0*1;sd:1;t:e" 
     
    sleep(np.random.randint(3,7)) 
 </strong>   <strong> 
    browser.get(sats) 
     
    soup = BeautifulSoup(browser.page_source, "html5lib") 
     
    cards = soup.select('div[class*=info-container]') 
     
    for card in cards: 
        city = card.select('h3')[0].text 
        fare = card.select('span[class*=price]')[0].text 
        fare_dict[sat_start] = {**fare_dict[sat_start], **{city: fare}} 
         
    start_sat_date = start_sat_date + timedelta(days=7) 
    end_sat_date = end_sat_date + timedelta(days=7) </strong></pre>
<p>That's a fair amount of code, so we'll unpack what is going on line by line. The first two lines just create our start and end dates that we'll use. The next two lines convert those date strings into <kbd>datetime</kbd> objects. This will be used later on when we want to add a week to each using <kbd>timedelta</kbd>. The last line before the <kbd>for</kbd> loop simply creates a dictionary that will hold our parsed data.</p>
<p>The next line begins a <kbd>for</kbd> loop. Inside this loop that will run <kbd>26</kbd> iterations, we convert our <kbd>datetime</kbd> object back into a string so that we can pass it into the URL that we will call with our browser object. Also, notice that on each iteration we populate our fare dictionary with the start date. We then create our URL using the date strings we created.</p>
<p>Next, we insert a random pause using the <kbd>numpy.random</kbd> function and the Python <kbd>sleep</kbd> function. This is simply to prevent us from appearing to be a bot and overtaxing the site.</p>
<p>We then retrieve the page with our browser object, pass it into <kbd>BeautifulSoup</kbd> for parsing, select the <kbd>info-container</kbd> divs, and then parse and update our fare dictionary. Finally, we add one week to our start and end dates so that the next iteration goes one week forward in time.</p>
<p>Now, let's look at the data in our fare dictionary:</p>
<pre><strong>fare_dict</strong> </pre>
<p>The preceding code results in the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-357 image-border" src="assets/e9b602b2-0979-4af4-9a8c-56a3e365b8d1.png" style="width:22.42em;height:24.83em;"/></p>
<p>As you can see, we have a dictionary with date as the primary key, and then sub dictionaries with city/fare pairings.</p>
<p>Now, let's dive into one city to examine the data. We'll begin with <kbd>Berlin</kbd>:</p>
<pre><strong>city_key = 'Berlin' 
for key in fare_dict: 
    print(key, fare_dict[key][city_key])</strong> </pre>
<p>The preceding code results in the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-358 image-border" src="assets/49d0b34a-49e4-427e-9c09-a8ff18caed94.png" style="width:11.83em;height:24.50em;"/></p>
<p>One thing we notice right away is that we'll need to clean up the airfares so that we can work with them. We'll need to remove the dollar sign and the commas and convert them into integers. We do that in the following code:</p>
<pre><strong>city_dict = {} 
for k,v in fare_dict.items(): 
    city_dict.update({k:int(v[city_key].replace(',','').split('$')[1])})</strong> </pre>
<p>The preceding code results in the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-360 image-border" src="assets/66d482dd-d12a-4f6e-8dc3-890c8be649df.png" style="width:13.42em;height:24.33em;"/></p>
<p>Remember, the output shown in the preceding code is only for Berlin, as we are just examining one city at the moment.</p>
<p>Now, let's plot that data:</p>
<pre><strong>prices = [int(x) for x in city_dict.values()] 
dates = city_dict.keys() 
 
fig,ax = plt.subplots(figsize=(10,6)) 
plt.scatter(dates, prices, color='black', s=50) 
ax.set_xticklabels(dates, rotation=-70);</strong> </pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The preceding code generates the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1020 image-border" src="assets/be3ca9f2-8abf-40bd-a4dd-65a07befade6.png" style="width:47.42em;height:32.08em;"/></p>
<p>Notice that we have 26 consecutive weeks of data, in this case, for non-stop flights from NYC to Berlin leaving on Saturday and returning the following Saturday. There appears to be a fair amount of variation in these fares. Just eyeballing the data, it appears that there might be two outliers on the high end toward the beginning of the period and the end.</p>
<p>Now, let's take a look at another city. To do this, we simply need to return to our code and change the <kbd>city_key</kbd> variable. We can then rerun the cells below it. We'll do that in the following code:</p>
<pre><strong>city_key = 'Milan' 
for key in fare_dict: 
    print(key, fare_dict[key][city_key])</strong> </pre>
<p>This results in the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-362 image-border" src="assets/3a956cce-cbe3-49c6-b3b9-0349f9c553df.png" style="width:12.75em;height:25.25em;"/></p>
<p><span>We'll need to remove the dollar sign and the commas and convert them into integers. We do that in the following code:</span></p>
<pre><strong>city_dict = {} 
for k,v in fare_dict.items(): 
    city_dict.update({k:int(v[city_key].replace(',','').split('$')[1])}) 
 
city_dict</strong> </pre>
<p>The preceding code results in the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1021 image-border" src="assets/5ea4b5e6-56ee-4bf5-b88d-48542d881c79.png" style="width:14.67em;height:25.50em;"/></p>
<p><span>Now, let's plot that data:</span></p>
<pre><strong>prices = [int(x) for x in city_dict.values()] 
dates = city_dict.keys() 
 
fig,ax = plt.subplots(figsize=(10,6)) 
plt.scatter(dates, prices, color='black', s=50) 
ax.set_xticklabels(dates, rotation=-70);</strong> </pre>
<p>The preceding code results in the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1022 image-border" src="assets/472f83cb-3c53-4e46-a29d-8218243f70da.png" style="width:41.08em;height:27.58em;"/></p>
<p>Here, we can see even wider variations, with fares ranging from under $600 to over $1,200. Those cheap fares on the left are exactly the type of fares we'd like to know about. We are going to want to create an outlier detection system that will tell us about these bargain fares. We'll move on and discuss that now.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Identifying outlier fares with anomaly detection techniques</h1>
                </header>
            
            <article>
                
<p>There are various rigorous definitions of outliers, but for our purposes, an <strong>outlier</strong> is any extreme value that is far from the other observations in the dataset. There are numerous techniques, both parametric and non-parametric, that are used to identify outliers; example algorithms include <strong>density-based spatial clustering of applications with noise</strong> (<strong>DBSCAN</strong>), isolation forests, and Grubbs' Test. Typically, the type of data determines the type of algorithm that is used. For example, some algorithms do better on multivariate data than univariate data. Here, we are dealing with univariate time-series data, so we'll want to choose an algorithm that handles that well.</p>
<div class="packt_infobox">If you aren't familiar with the term <em>time series</em>, it simply means data that is recorded at regular intervals, such as the daily closing price of a stock.</div>
<p>The algorithm that we are going to use for our data is called <strong><span>Generalized Extreme Studentized Deviate</span></strong> (<strong>Generalized ESD</strong>) test for outliers. This algorithm is well suited for our data, since it is univariate and approximately normal.</p>
<p>There are several tests we can use to ensure that our data is approximately normally distributed, but we can also visually inspect our data for normality using a normal probability plot. We'll do that now for Moscow city data using some functionality from the SciPy library:</p>
<pre><strong>from scipy import stats 
fix, ax = plt.subplots(figsize=(10,6)) 
stats.probplot(list(city_dict.values()), plot=plt) 
plt.show()</strong> </pre>
<p>The preceding code generates the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1023 image-border" src="assets/128bbbd5-12c0-4e06-be04-3d6f32717512.png" style="width:43.83em;height:27.17em;"/></p>
<p class="mce-root"/>
<p>When assessing a <strong>normal probability</strong> or <strong><span>quantile-quantile</span></strong> (<strong>Q-Q</strong>) <strong>plot</strong>, we are looking for the data to be as close to the straight line as possible to reveal normality. Data that veers off in one direction or another, or with a strong S shape, argues against normal data. Here, we have a fairly low number of data points, and those that we do have are fairly balanced around the diagonal. If we had more data, it is likely that we would more closely approximate the diagonal. This should work well enough for our purposes.</p>
<p>We'll now move on to our outlier detection code. We are going to be utilizing another library for this called <kbd>PyAstronomy</kbd>. If you don't have it, it can easily be pip installed.</p>
<p>Let's look at the code:</p>
<pre><strong>from PyAstronomy import pyasl 
 
r = pyasl.generalizedESD(prices, 3, 0.025, fullOutput=True) 
 
print('Total Outliers:', r[0]) 
 
out_dates = {} 
for i in sorted(r[1]): 
    out_dates.update({list(dates)[i]: list(prices)[i]}) 
 
print('Outlier Dates', out_dates.keys(), '\n') 
print('     R         Lambda') 
 
for i in range(len(r[2])): 
    print('%2d  %8.5f  %8.5f' % ((i+1), r[2][i], r[3][i])) 
 
fig, ax = plt.subplots(figsize=(10,6)) 
plt.scatter(dates, prices, color='black', s=50) 
ax.set_xticklabels(dates, rotation=-70); 
 
for i in range(r[0]): 
    plt.plot(r[1][i], prices[r[1][i]], 'rp')</strong> </pre>
<p>Let's discuss what the preceding code does. The first line is simply our import. Following that, we implement our generalized ESD algorithm. The parameters are our fare prices, then the maximum number of outliers (here, we chose <kbd>3</kbd>), the significance level (alpha, at <kbd>0.025</kbd>), and finally a Boolean to specify that we want the full output. With respect to the significance level, the lower the value, the less sensitive the algorithm and the fewer false positives will be generated.</p>
<p>The next two lines simply print out data related to the <kbd>R</kbd> and <kbd>Lambda</kbd> values. These are utilized in the determination of whether a data point is an outlier.</p>
<p class="mce-root"/>
<p>Finally, the remainder of the code is simply for generating the scatter plot and coloring those fares that are outliers red.</p>
<p>The preceding code generates the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-366 image-border" src="assets/0a02c3e2-6605-45a9-9bac-8ec7430039b3.png" style="width:46.33em;height:40.75em;"/></p>
<p>Again, this data is for Moscow. Make sure you changed your <kbd>city_key</kbd> variable to reflect that to ensure you get that data. Notice that despite all the variations, there are no outliers in the data.</p>
<p>Now, let's run it for Milan as well. We'll go back up and change our <kbd>city_key</kbd> variable and run the cells below that to update everything, as demonstrated in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1024 image-border" src="assets/670a1a91-fc27-4831-83ad-1a78f54e0d10.png" style="width:45.83em;height:38.83em;"/></p>
<p>Notice that this time, we have three outliers, and these are fares that are under $600 when the mean fare looks to be over $900, so this looks like a win for us.</p>
<p>Let's try another city. This time, we'll look at Athens by updating the <kbd>city_key</kbd> variable and running the subsequent cells:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1025 image-border" src="assets/080ba74c-e3d1-44b6-a9e2-0f156a14ae69.png" style="width:52.75em;height:46.00em;"/></p>
<p>Notice that again, we have three outliers, but that this time, they are extreme fares to the upside. Since we are only interested in getting alerts for cheap fares, we can build in a mechanism to only alert us when the fare outlier is less than the mean fare.</p>
<p>Now, we'll now create some code to handle this element:</p>
<pre><strong>city_mean = np.mean(list(city_dict.values())) 
 
for k,v in out_dates.items(): 
    if v &lt; city_mean: 
        print('Alert for', city_key + '!') 
        print('Fare: $' + str(v), 'on', k) 
        print('\n')</strong> </pre>
<p>When we run the code for Athens, it will generate no output. When run for Milan, it generates the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-369 image-border" src="assets/24a54489-3428-4263-8be8-1bbaaf435f90.png" style="width:17.08em;height:14.17em;"/></p>
<p>So, now, we have created a system to scrape the data, parse it, and identify the outliers. Let's move on and create a fully-fledged application that can alert us in real time.</p>
<div class="packt_infobox">Keep in mind that we just did a very preliminary analysis on our outlier detection model. In the real world, it would likely take a much more thorough series of tests to identify whether we had selected workable parameters for our model.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sending real-time alerts using IFTTT</h1>
                </header>
            
            <article>
                
<p>To have a chance at getting these cheap fares, we're going to need to know in nearly real time when they happen. To accomplish this, we'll use a service called <strong>If This Then That</strong> (<strong>IFTTT</strong>). This free service allows you to connect a huge number of services with a series of triggers and actions. Want to save as many pictures as you like on Instagram to your iPhone photos? Want to get an email every time a particular person tweets? Want your Facebook updates posted to Twitter? IFTTT can do all of this. Go through the following steps:</p>
<ol>
<li>The first step is to sign up for an account at <a href="https://ifttt.com/" target="_blank"><span class="URLPACKT">http://www.ifttt.com</span></a>.</li>
<li>Once you've done that, you'll need to sign up for the Maker channel, <a href="https://ifttt.com/maker_webhooks" target="_blank"><span class="URLPACKT">https://ifttt.com/maker_webhooks</span></a>, and the SMS channel, <span class="URLPACKT"><a href="https://ifttt.com/sms" target="_blank">https://ifttt.com/sms</a></span>.</li>
<li>Maker allows you to create IFTTT recipes by sending and receiving HTTP requests.</li>
<li>Once you've created an account and activated the Maker and SMS channels, click <span class="packt_screen">My Applets</span> from the home page, and then click <span class="packt_screen">New Applet</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1026 image-border" src="assets/3382cd71-d1f7-44ac-9377-d89b4187a378.png" style="width:40.83em;height:8.42em;"/></p>
<ol start="5">
<li>Then, click on <span class="packt_screen">this</span>, as shown in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1027 image-border" src="assets/b632a0c0-06f0-458f-8523-16b088845c3b.png" style="width:30.17em;height:15.17em;"/></p>
<ol start="6">
<li>Then, search for <kbd>webhooks</kbd> and click <span class="packt_screen">Receive a web request</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1028 image-border" src="assets/342a78ef-d23c-4862-8377-31740b0a6523.png" style="width:28.17em;height:20.08em;"/></p>
<ol start="7">
<li>Then, we'll create an event called <kbd>cheap_fares</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1029 image-border" src="assets/7c3025ec-fa02-4d77-a752-05e364451d77.png" style="width:23.17em;height:27.00em;"/></p>
<ol start="8">
<li>Once you fill out the event name, click <span class="packt_screen">Create trigger</span>. Next, we'll set up the <span class="packt_screen">+<span class="packt_screen">t</span></span><span class="packt_screen">hat</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1030 image-border" src="assets/3fd8b525-d386-4614-900f-7ac084c380ba.png" style="width:21.00em;height:3.42em;"/></p>
<ol start="9">
<li>Click <span class="packt_screen">that</span>, and then search for <kbd>SMS</kbd> and select it:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1031 image-border" src="assets/b99706b9-ff75-41fa-b134-4b538bb21ff3.png" style="width:31.42em;height:21.58em;"/></p>
<p style="padding-left: 60px"><span>Then, choose </span><span class="packt_screen">Send me an SMS</span><span>:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1032 image-border" src="assets/290c915e-fb68-4fda-8eae-b07ab23f8d40.png" style="width:28.08em;height:18.58em;"/></p>
<ol start="10">
<li>After that, we'll customize our message:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1033 image-border" src="assets/0f5f71ef-2098-4701-9293-66f152f7eba2.png" style="width:27.58em;height:28.42em;"/></p>
<p style="padding-left: 60px">Once this is complete, click on <span class="packt_screen">Finish</span> to wrap-up the setup:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-378 image-border" src="assets/277b926f-3ec4-4dd2-8790-0efdeb1943e7.png" style="width:21.75em;height:37.50em;"/></p>
<p>To test the setup, go to <a href="https://ifttt.com/maker_webhooks" target="_blank"><span class="URLPACKT">http://www.ifttt.com/maker_webhooks</span></a> and click on <span class="packt_screen">Settings</span>. You should see your account information that includes a URL with a secret key. Copy and paste that URL into your browser. It should have a form with your secret key and a place to fill in the values that correspond to your city and price.</p>
<p class="mce-root"/>
<p>Fill in <span class="packt_screen">cheap_fares</span> for event, and place the city and fare into <span class="packt_screen">value1</span> and <span class="packt_screen">value2</span>, respectively:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1034 image-border" src="assets/07a5bbd4-c648-4a74-a2ac-bfb96c1abfce.png" style="width:45.25em;height:19.67em;"/></p>
<p>Finally, click <span class="packt_screen">Test It</span>, and you should receive a text message in just a few seconds.</p>
<p>Now that we have all the pieces in place, it's time to pull it all together into a single script that will monitor fares 24/7.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Putting it all together</h1>
                </header>
            
            <article>
                
<p>Up until this point, we've worked within the Jupyter Notebook, but now, in order to deploy our app, we'll move on to working in a text editor. The notebook is excellent for exploratory analysis and visualization, but running a background job is best done within a simple <kbd>.py</kbd> file. So, let's get started.</p>
<p>We'll begin with our imports. You may need to <kbd>pip install</kbd> a few of these if you don't already have them installed:</p>
<pre><strong>import sys 
import sys 
import numpy as np 
from bs4 import BeautifulSoup 
from selenium import webdriver 
import requests 
import scipy 
from PyAstronomy import pyasl 
 
from datetime import date, timedelta, datetime 
import time 
from time import sleep 
import schedule </strong></pre>
<p>Next, we'll create a function that pulls down the data and runs our algorithm:</p>
<pre><strong>def check_flights(): 
   # replace this with the path of where you downloaded chromedriver 
   chromedriver_path = "/Users/alexcombs/Downloads/chromedriver" 
 
   browser = webdriver.Chrome(chromedriver_path) 
 
   start_sat = sys.argv[2] 
   end_sat = sys.argv[3] 
 
   start_sat_date = datetime.strptime(start_sat, '%Y-%m-%d') 
   end_sat_date = datetime.strptime(end_sat, '%Y-%m-%d') 
 
   fare_dict = {} 
</strong> <strong>
   for i in range(26):     
       sat_start = str(start_sat_date).split()[0] 
       sat_end = str(end_sat_date).split()[0] 
        
       fare_dict.update({sat_start: {}}) 
        
       sats = "https://www.google.com/flights/?f=0#f=0&amp;flt=/m/02_286.r/m/02j9z." + \ 
       sat_start + "*r/m/02j9z./m/02_286." + \ 
       sat_end + ";c:USD;e:1;s:0*1;sd:1;t:e" 
        
       sleep(np.random.randint(10,15)) 
        
       browser.get(sats) 
   </strong>    <strong> 
       soup = BeautifulSoup(browser.page_source, "html5lib") 
        
       cards = soup.select('div[class*=info-container]') 
        
       for card in cards: 
           city = card.select('h3')[0].text 
           fare = card.select('span[class*=price]')[0].text 
           fare_dict[sat_start] = {**fare_dict[sat_start], **{city: fare}} 
            
       start_sat_date = start_sat_date + timedelta(days=7) 
       end_sat_date = end_sat_date + timedelta(days=7) 
 </strong>
 <strong>
   city_key = sys.argv[1] 
 
   city_dict = {} 
   for k,v in fare_dict.items(): 
       city_dict.update({k:int(v[city_key].replace(',','').split('$')[1])}) 
 
   prices = [int(x) for x in city_dict.values()] 
   dates = city_dict.keys() 
 
   r = pyasl.generalizedESD(prices, 3, 0.025, fullOutput=True) 
 
   print('Total Outliers:', r[0]) 
 
   out_dates = {} 
   for i in sorted(r[1]): 
       out_dates.update({list(dates)[i]: list(prices)[i]}) 
 
   city_mean = np.mean(list(city_dict.values())) 
 
   for k,v in out_dates.items(): 
       if v &lt; city_mean: 
          requests.post('https://maker.ifttt.com/trigger/cheap_fares/with/key/bNHFwiZx0wMS7EnD425n3T', \ 
             data={ "value1" : str(city_key), "value2" : str(v), "value3" : "" }) 
          print('Alert for', city_key + '!') 
          print('Fare: $' + str(v), 'on', k) 
          print('\n') 
       else: 
          print(str(v) + ' is greater than ' + str(city_mean)) 
   </strong> </pre>
<p>Finally, we'll include a scheduler. This will run our code every 60 minutes:</p>
<pre><strong># set up the scheduler to run our code every 60 min 
schedule.every(60).minutes.do(check_flights) 
 
while 1: 
    schedule.run_pending() 
    time.sleep(1) </strong></pre>
<p>And that should do it. We can now save this as <kbd>fare_alerter.py</kbd>, and run it from the command line. You will need to pass in three arguments. The first is the city, the second is the start date, and the final one is the end date. An example is as follows:</p>
<pre><strong>python fare_alerter.py 'Milan' '2018-12-01' '2018-12-08'</strong></pre>
<p>The script will continue running and check fares every 60 minutes. If a mistake fare occurs, we'll be one of the first to know!</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>We've covered a lot of ground in this chapter. We've learned how to find the best airfare data on the web, how to work with the DOM to find the elements we want to parse, how to identify outliers, and finally, how to send text alerts from our code using web requests through IFTTT. While what we've covered here is for airfares, nearly everything we've done could be reused for any type of pricing you'd like to be alerted to.</p>
<p>If you do decide to use it for airfares though, I hope it provides you with many happy travels!</p>


            </article>

            
        </section>
    </body></html>