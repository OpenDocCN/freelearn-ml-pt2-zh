<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">First Step Towards Supervised Learning</h1>
                </header>
            
            <article>
                
<p>In this book, we will learn about the implementation of many of the common machine learning algorithms you interact with in your daily life. There will be plenty of math, theory, and tangible code examples to satisfy even the biggest machine learning junkie and, hopefully, you'll pick up some useful Python tricks and practices along the way. We are going to start off with a very brief introduction to supervised learning, sharing a real-life machine learning demo; <span>getting our Anaconda environment setup done; learning how to measure the slope of a curve, Nd-curve, and multiple functions;</span> and finally, we'll discuss how we know whether or not a model is good. In this chapter, we will cover the following topics:</p>
<ul>
<li>An example of supervised learning in<span> </span>action</li>
<li>Setting up the environment</li>
<li>Supervised learning</li>
<li>Hill climbing and loss functions</li>
<li>Model evaluation and data splitting</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p class="mce-root"><span class="fontstyle0">For this chapter, you will need to install the following software, if you haven't already done so:</span></p>
<ul>
<li>Jupyter Notebook</li>
<li>Anaconda</li>
<li>Python</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"><span class="fontstyle0">The code files for this chapter can be found at</span> <a href="https://github.com/PacktPublishing/Supervised-Machine-Learning-with-Python" target="_blank"><span class="fontstyle2">https:/</span><span class="fontstyle3">​</span><span class="fontstyle2">/</span><span class="fontstyle3">​</span><span class="fontstyle2">github.</span><span class="fontstyle3">​</span><span class="fontstyle2">com/</span><span class="fontstyle3">​</span><span class="fontstyle2">PacktPublishing/</span><span class="fontstyle2"><br/></span><span class="fontstyle2">Supervised-Machine-Learning-with-Python</span></a><span class="fontstyle0">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">An example of supervised learning in action</h1>
                </header>
            
            <article>
                
<p>First, we will take a look at what we can do with supervised machine learning. With the following Terminal prompt, we will launch a new Jupyter Notebook:</p>
<pre><strong>jupyter notebook</strong></pre>
<p>Once we are inside this top-level, <kbd>Hands-on-Supervised-Machine-Learning-with-Python-master</kbd> home directory, we will go directly inside the <kbd>examples</kbd> directory:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-158 image-border" src="assets/6b307221-119e-4772-a9d0-44d3186979f3.png" style="width:92.75em;height:23.50em;"/></p>
<p>You can see that our only Notebook in here is <kbd>1.1 Supervised Learning Demo.ipynb</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-500 image-border" src="assets/c853b1ee-ae6e-4447-b516-ffc646c710d0.png" style="width:23.33em;height:10.00em;"/></p>
<p>We have the supervised learning demo Jupyter Notebook. We are going to be using a UCI dataset called the <kbd>Spam</kbd> dataset. This is a list of different emails that contain different features that correspond to spam or not spam. We want to build a machine learning algorithm that can predict whether or not we have an email coming in that is going to be spam. <span>This could be extremely helpful for you if you're running your own email server.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>So, the first function in the following code is simply a request's get function. You should already have the dataset, which is already sitting inside the <kbd>examples</kbd> directory. But in case you don't, you can go ahead and run the following code. You can see that we already have <kbd>spam.csv</kbd>, so we're not going to download it:</p>
<pre class="mce-root">from urllib.request import urlretrieve, ProxyHandler, build_opener, install_opener<br/>import requests<br/>import os<br/>pfx = "https://archive.ics.uci.edu/ml/machine-learning databases/spambase/"<br/>data_dir = "data"<br/># We might need to set a proxy handler...<br/>try:<br/>    proxies = {"http": os.environ['http_proxy'],<br/>               "https": os.environ['https_proxy']}<br/>    print("Found proxy settings")<br/>    #create the proxy object, assign it to a variable<br/>    proxy = ProxyHandler(proxies)<br/>    # construct a new opener using your proxy settings<br/>    opener = build_opener(proxy)<br/>    # install the opener on the module-level<br/>    install_opener(opener)<br/> <br/>except KeyError:<br/>    pass<br/># The following will download the data if you don't already have it...<br/>def get_data(link, where):<br/>    # Append the prefix<br/>    link = pfx + link</pre>
<p class="mce-root">Next, we will use the <kbd>pandas</kbd> library. This is a data analysis library from Python. You can install it when we go through the next stage, which is the environment setup. This library is a data frame data structure that is a kind of native Python, which we will use as follows:</p>
<pre>import pandas as pd<br/>names = ["word_freq_make", "word_freq_address", "word_freq_all", <br/>         "word_freq_3d", "word_freq_our", "word_freq_over", <br/>         "word_freq_remove", "word_freq_internet", "word_freq_order",<br/>         "word_freq_mail", "word_freq_receive", "word_freq_will", <br/>         "word_freq_people", "word_freq_report", "word_freq_addresses", <br/>         "word_freq_free", "word_freq_business", "word_freq_email", <br/>         "word_freq_you", "word_freq_credit", "word_freq_your", <br/>         "word_freq_font", "word_freq_000", "word_freq_money", <br/>         "word_freq_hp", "word_freq_hpl", "word_freq_george", <br/>         "word_freq_650", "word_freq_lab", "word_freq_labs", <br/>         "word_freq_telnet", "word_freq_857", "word_freq_data", <br/>         "word_freq_415", "word_freq_85", "word_freq_technology", <br/>         "word_freq_1999", "word_freq_parts", "word_freq_pm", <br/>         "word_freq_direct", "word_freq_cs", "word_freq_meeting", <br/>         "word_freq_original", "word_freq_project", "word_freq_re", <br/>         "word_freq_edu", "word_freq_table", "word_freq_conference", <br/>         "char_freq_;", "char_freq_(", "char_freq_[", "char_freq_!", <br/>         "char_freq_$", "char_freq_#", "capital_run_length_average", <br/>         "capital_run_length_longest", "capital_run_length_total",<br/>         "is_spam"]<br/>df = pd.read_csv(os.path.join("data", "spam.csv"), header=None, names=names)<br/># pop off the target<br/>y = df.pop("is_spam")<br/>df.head()</pre>
<p>This allows us to lay out our data in the following format. We can use all sorts of different statistical functions that are nice to use when you're doing machine learning:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-162 image-border" src="assets/9205d451-daa7-42ca-ae8f-075ae077fe9e.png" style="width:75.08em;height:17.50em;"/></p>
<p>If some of this terminology is not familiar to you, don't panic yet—we will learn about these terminologies in detail over the course of the book.</p>
<p>For <kbd>train_test_split</kbd>, we will take the <kbd>df</kbd> dataset and split it into two parts: train set and test set. In addition to that, we have the target, which is a <kbd>01</kbd> variable that indicates true or false for spam or not spam. We will split that as well, which includes the corresponding vector of true or false labels. By splitting the labels, we get <kbd>3680</kbd> training samples and <kbd>921</kbd> test samples, file as shown in the following code snippet:</p>
<pre>from sklearn.model_selection import train_test_split<br/>X_train, X_test, y_train, y_test = train_test_split(df, y, test_size=0.2, random_state=42, stratify=y)<br/>print("Num training samples: %i" % X_train.shape[0])<br/>print("Num test samples: %i" % X_test.shape[0])</pre>
<p>The output of the preceding code is as follows:</p>
<pre>Num training samples: 3680<br/>Num test samples: 921</pre>
<p class="mce-root"/>
<div class="packt_infobox">Notice that we have a lot more training samples than test samples, which is important for fitting our models. We will learn about this later in the book. So, don't worry too much about what's going on here, as this is all just for demo purposes.</div>
<p>In the following code, we have the <kbd>packtml</kbd> library. This is the actual package that we are building, which is a classification and regression tree classifier. <kbd>CARTClassifier</kbd> is simply a generalization of a decision tree for both regression and classification purposes. Everything we fit here is going to be a supervised machine learning algorithm that we build from scratch. This is one of the classifiers that we are going to build in this book. We also have this utility function for plotting a learning curve. This is going to take our train set and break it into different folds for cross-validation. We will fit the training set in different stages of numbers of training samples, so we can see how the learning curve converges between the train and validation folds, which determines how our algorithm is learning, essentially:</p>
<pre>from packtml.utils.plotting import plot_learning_curve<br/>from packtml.decision_tree import CARTClassifier<br/>from sklearn.metrics import accuracy_score<br/>import numpy as np<br/>import matplotlib.pyplot as plt<br/>%matplotlib inline<br/>    <br/># very basic decision tree<br/>plot_learning_curve(<br/>        CARTClassifier, metric=accuracy_score,<br/>        X=X_train, y=y_train, n_folds=3, seed=21, trace=True,<br/>        train_sizes=(np.linspace(.25, .75, 4) * X_train.shape[0]).astype(int),<br/>        max_depth=8, random_state=42)\<br/>    .show()</pre>
<p>We will go ahead and run the preceding code and plot how the algorithm has learned across the different sizes of our training set. You can see we're going to fit it for 4 different training set sizes at 3 folds of cross-validation.</p>
<p>So, what we're actually doing is fitting 12 separate models, which will take a few seconds to run:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-492 image-border" src="assets/1923903f-00ea-423c-985e-9142be846bd2.png" style="width:38.50em;height:27.50em;"/></p>
<p>In the preceding output, we can see our <strong>Training score</strong> and our <strong>Validation score</strong>. The <strong>Training score</strong> diminishes as it learns to generalize, and our <strong>Validation score</strong> increases as it learns to generalize from the training set to the validation set. So, our accuracy is hovering right around 92-93% on our validation set.</p>
<p>We will use the hyperparameters from the very best one here:</p>
<pre>decision_tree = CARTClassifier(X_train, y_train, random_state=42, max_depth=8)</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Logistic regression</h1>
                </header>
            
            <article>
                
<p>In this section, we will learn about logistic regression, which is another classification model that we're going to build from scratch. We will go ahead and fit the following code:</p>
<pre>from packtml.regression import SimpleLogisticRegression<br/># simple logistic regression classifier<br/>plot_learning_curve(<br/>        SimpleLogisticRegression, metric=accuracy_score,<br/>        X=X_train, y=y_train, n_folds=3, seed=21, trace=True,<br/>        train_sizes=(np.linspace(.25, .8, 4) *     X_train.shape[0]).astype(int),<br/>        n_steps=250, learning_rate=0.0025, loglik_interval=100)\<br/>    .show()</pre>
<p>This is much faster than the decision tree. In the following output, you can see that we converge a lot more around the 92.5% range. This looks a little more consistent than our decision tree, but it doesn't perform quite well enough on the validation set:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-499 image-border" src="assets/fa022926-38db-42f3-8dc2-f205f5120b4f.png" style="width:38.75em;height:25.58em;"/></p>
<p>In the following screenshot, there are encoded records of spam emails. We will see how this encoding performs on an email that we can read and validate. So, if you have visited the UCI link that was included at the top of the Jupyter Notebook, it will provide a description of all the features inside the dataset. We have a lot of different features here that are counting the ratio of particular words to the number of words in the entire email. Some of those words might be free and some credited. We also have a couple of other features that are counting character frequencies, the number of exclamation points, and the number of concurrent capital runs.</p>
<p>So, if you have a really highly capitalized set of words, we have all these features:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-167 image-border" src="assets/278f0298-97cf-4a1e-abd2-79fc4470b12d.png" style="width:34.33em;height:28.42em;"/></p>
<p>In the following screenshot, we will create two emails. The first email is very obviously spam. Even if anyone gets this email, no one will respond to it:</p>
<pre>spam_email = """<br/>Dear small business owner,<br/>    <br/>This email is to inform you that for $0 down, you can receive a <br/>FREE CREDIT REPORT!!! Your money is important; PROTECT YOUR CREDIT and <br/>reply direct to us for assistance!<br/>"""<br/><br/>print(spam_email)</pre>
<p>The output of the preceding code snippet is as follows:</p>
<pre>Dear small business owner,<br/>    <br/>This email is to inform you that for $0 down, you can receive a <br/>FREE CREDIT REPORT!!! Your money is important; PROTECT YOUR CREDIT and <br/>reply direct to us for assistance!</pre>
<p>The second email looks less like spam:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-168 image-border" src="assets/239df941-2895-4c5e-b9ab-d7e4d5304eca.png" style="width:33.08em;height:7.50em;"/></p>
<p>The model that we have just fit is going to look at both of the emails and encode the features, and will classify which is, and which is not, spam.</p>
<p>The following function is going to encode those emails into the features we discussed. Initially, we're going to use a <kbd>Counter</kbd> function as an object, and tokenize our emails. All we're doing is splitting our email into a list of words, and then the words can be split into a list of characters. Later, we'll count the characters and words so that we can generate our features:</p>
<pre>from collections import Counter<br/>import numpy as np<br/>def encode_email(email):<br/>    # tokenize the email<br/>    tokens = email.split()<br/>    <br/>    # easiest way to count characters will be to join everything<br/>    # up and split them into chars, then use a counter to count them<br/>    # all ONE time.<br/>    chars = list("".join(tokens))<br/>    char_counts = Counter(chars)<br/>    n_chars = len(chars)<br/>    <br/>    # we can do the same thing with "tokens" to get counts of words<br/>    # (but we want them to be lowercase!)<br/>    word_counts = Counter([t.lower() for t in tokens])<br/>    <br/>    # Of the names above, the ones that start with "word" are<br/>    # percentages of frequencies of words. Let's get the words<br/>    # in question<br/>    freq_words = [ <br/>        name.split("_")[-1]<br/>        for name in names <br/>        if name.startswith("word")<br/>    ]<br/>    <br/>    # compile the first 48 values using the words in question<br/>    word_freq_encodings = [100. * (word_counts.get(t, 0) / len(tokens))<br/>                           for t in freq_words]</pre>
<p class="mce-root"/>
<p>So, all those features that we have up at the beginning tell us what words we're interested in counting. We can see that the original dataset is interested in counting words such as address, email, business, and credit, and then, for our characters, we're looking for opened and closed parentheses and dollar signs (which are quite relevant to our spam emails). So, we're going to count all of those shown as follows:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/defb48de-1917-450d-8b29-3bfd7edc6f46.png" style="width:42.17em;height:27.08em;"/></div>
<p>Apply the ratio and keep track of the total number of <kbd>capital_runs</kbd>, computing the mean average, maximum, and minimum:</p>
<pre> # make a np array to compute the next few stats quickly<br/>capital_runs = np.asarray(capital_runs)<br/>    capital_stats = [capital_runs.mean(), <br/>                     capital_runs.max(), <br/>                     capital_runs.sum()]<br/>                </pre>
<p>When we run the preceding code, we get the following output. This is going to encode our emails. This is just simply a vector of all the different features. It should be about 50 characters long:</p>
<pre># get the email vectors<br/>fake_email = encode_email(spam_email)<br/>real_email = encode_email(not_spam)<br/># this is what they look like:<br/>print("Spam email:")<br/>print(fake_email)<br/>print("\nReal email:")<br/>print(real_email)</pre>
<p>The output of the preceding code is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-169 image-border" src="assets/49f17f3e-ff3a-4a64-9765-05e471651690.png" style="width:39.42em;height:20.42em;"/></p>
<p>When we fit the preceding values into our models, we will see whether our model is any good. So, ideally, we will see that the actual fake email is predicted to be fake, and the actual real email is predicted to be real. So, if the emails are predicted as fake, our spam prediction is indeed spam for both the decision tree and the logistic regression. Our true email is not spam, which perhaps is even more important, because we don't want to filter real email into the spam folder. So, you can see that we fitted some pretty good models here that apply to something that we would visually inspect as true spam or not:</p>
<pre>predict = (lambda rec, mod: "SPAM!" if mod.predict([rec])[0] == 1 else "Not spam")<br/><br/>print("Decision tree predictions:")<br/>print("Spam email prediction: %r" % predict(fake_email, decision_tree))<br/>print("Real email prediction: %r" % predict(real_email, decision_tree))<br/><br/>print("\nLogistic regression predictions:")<br/>print("Spam email prediction: %r" % predict(fake_email, logistic_regression))<br/>print("Real email prediction: %r" % predict(real_email, logistic_regression))</pre>
<p>The output of the preceding code is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-170 image-border" src="assets/8aa61090-9474-4640-bf82-5c88c68fb8c6.png" style="width:17.33em;height:7.33em;"/></p>
<p>This is a demo of the actual algorithms that we're going to build from scratch in this <span><span>book</span></span>, and can be applied to real-world problems.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up the environment</h1>
                </header>
            
            <article>
                
<p>We will go ahead and get our environment set up. Now that we have walked through the preceding example, let's go ahead and get our Anaconda environment set up. Among other things, Anaconda is a dependency management tool that will allow us to control specific versioning of each of the packages that we want to use. We will go to the Anaconda website through this link, <span class="MsoHyperlink"><a href="https://www.anaconda.com/download/">https://www.anaconda.com/download/</a>,<a href="https://www.anaconda.com/download/"/></span> and click on the <span class="packt_screen">Download</span> tab.</p>
<div class="packt_tip">The package that we're building is not going to work with Python 2.7. So, once you have Anaconda, we will perform a live coding example of an actual package setup, as well as the environment setup that's included in the <kbd>.yml</kbd> file that we built.</div>
<p>Once you have Anaconda set up inside the home directory, we are going to use the <kbd>environment.yml</kbd> file. You can see that the name of the environment we're going to create is <kbd>packt-sml</kbd> for supervised machine learning. We will need NumPy, SciPy, scikit-learn, and pandas. These are all scientific computing and data analysis libraries. Matplotlib is what we were using to plot those plots inside the Jupyter Notebook, so you're going to need all those plots. The <kbd>conda</kbd> package makes it really easy to build this environment. All we have to do is type <kbd>conda env create</kbd> and then <kbd>-f</kbd> to point it to the file, go to <kbd>Hands-on-Supervised-Machine-Learning-with-Python-master</kbd>, and we're going to use the <kbd>environment.yml</kbd> as shown in the following command:</p>
<pre><strong>cat environment.yml<br/></strong><strong>conda env create -f environment.yml</strong></pre>
<p>As this is the first time you're creating this, it will create a large script that will download everything you need. Once you have created your environment, you need to activate it. So, on a macOS or a Linux machine, we will type <kbd>source activate packt-sml</kbd>.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>If you're on Windows, simply type <kbd>activate packt-sml</kbd>, which will activate that environment:</p>
<pre><strong> source activate packt-sml</strong></pre>
<p>The output is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-498 image-border" src="assets/205cbcc3-10ea-48a9-a83b-76fcf196cffc.png" style="width:93.83em;height:10.92em;"/></p>
<p>In order to build the package, we will type the <kbd>cat setup.py</kbd> command. We can inspect this quickly:</p>
<pre><strong>cat setup.py</strong></pre>
<p>Take a look at this <kbd>setup.py</kbd>. Basically, this is just using setup tools to install the package. In the following screenshot, we see all the different sub models:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-172 image-border" src="assets/c57903bf-a407-461b-93d6-f2798ddf73a0.png" style="width:36.42em;height:30.50em;"/></p>
<p>We will build the package by typing the <kbd>python setup.py install</kbd> command. Now, when we go into Python and try to import <kbd>packtml</kbd>, we get the following output:</p>
<p><img class="alignnone size-full wp-image-173 image-border" src="assets/273e6b37-dfe5-4dbd-ae08-a34b4635bd8b.png" style="width:98.42em;height:76.92em;"/></p>
<p>In this section, we have installed the environment and built the package. In the next section, we will start covering some of the theory behind supervised machine learning.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Supervised learning</h1>
                </header>
            
            <article>
                
<p>In this section, we will formally define what machine learning is and, specifically, what supervised machine learning is.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>In the early days of AI, everything was a rules engine. The programmer wrote the function and the rules, and the computer simply followed them. Modern-day AI is more in line with machine learning, which teaches a computer to write its own functions. Some may contest that oversimplification of the concept, but, at its core, this is largely what machine learning is all about.</p>
<p>We're going to look at a quick example of what machine learning is and what it is not. Here, we're using scikit-learn's datasets, submodule to create two objects and variables, also known as covariance or features, which are along the column axis. <kbd>y</kbd> is a vector with the same number of values as there are rows in <kbd>X</kbd>. In this case, <kbd>y</kbd> is a class label. For the sake of an example, <kbd>y</kbd> here could be a binary label corresponding to a real-world occurrence, such as the malignancy of a tumor. <kbd>X</kbd> is then a matrix of attributes that describe <kbd>y</kbd>. One feature could be the diameter of the tumor, and another could indicate its density. The preceding explanation can be seen in the following code:</p>
<pre>import numpy as np<br/>from sklearn.datasets import make_classification<br/><br/>rs = np.random.RandomState(42)<br/>X,y = make_classification(n_samples=10, random_state=rs)</pre>
<p>A rules engine, by our definition, is simply business logic. It can be as simple or as complex as you need it to be, but the <span><span>programmer </span></span>makes the rules. In this function, we're going to evaluate our <kbd>X</kbd> matrix by returning <kbd>1</kbd>, or <kbd>true</kbd>, where the sums over the rows are greater than <kbd>0</kbd>. Even though there's some math involved here, there is still a rules engine, because we, the programmers, defined a rule. So, we could theoretically get into a gray area, where the rule itself was discovered via machine learning. But, for the sake of argument, let's take an example that the head surgeon arbitrarily picks <kbd>0</kbd> as our threshold, and anything above that is deemed as cancerous:</p>
<pre>def make_life_alterning_decision(X):<br/>    """Determine whether something big happens"""<br/>    row_sums = X.sum(axis=1)<br/>    return (row_sums &gt; 0).astype(int)<br/>make_life_alterning_decision(X)</pre>
<p>The output of the preceding code snippet is as follows:</p>
<pre>array([0, 1, 0, 0, 1, 1, 1, 0, 1, 0])</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Now, as mentioned before, our rules engine can be as simple or as complex as we want it to be. Here, we're not only interested in <kbd>row_sums</kbd>, but we have several criteria to meet in order to deem something cancerous. The minimum value in the row must be less than <kbd>-1.5</kbd>, in addition to one or more of the following three criteria:</p>
<ul>
<li>The row sum exceeds <kbd>0</kbd></li>
<li>The sum of the rows is evenly divisible by <kbd>0.5</kbd></li>
<li>The maximum value of the row is greater than <kbd>1.5</kbd></li>
</ul>
<p>So, even though our math is a little more complex here, we're still just building a rules engine:</p>
<pre>def make_more_complex_life_alterning_decision(X):<br/>    """Make a more complicated decision about something big"""   <br/>    row_sums = X.sum(axis=1)<br/>      return ((X.min(axis=1) &lt; -1.5) &amp;<br/>              ((row_sums &gt;= 0.) |<br/>               (row_sums % 0.5 == 0) |<br/>               (X.max(axis=1) &gt; 1.5))).astype(int)<br/> <br/>make_more_complex_life_alterning_decision(X) </pre>
<p>The output of the preceding code is as follows:</p>
<pre>array([0, 1, 1, 1, 1, 1, 0, 1, 1, 0])</pre>
<p>Now, let's say that our surgeon understands and realizes they're not the math or programming whiz that they thought they were. So, they hire programmers to build them a machine learning model. The model itself is a function that discovers parameters that complement a decision function, which is essentially the function the machine itself learned. So, parameters are things we'll discuss in our next <a href="b51fa9b6-9158-4bcf-9998-18a8f91d3d06.xhtml">Chapter 2</a>, <em>Implementing Parametric Models,</em> which are parametric models. So, what's happening behind the scenes when we invoke the <kbd>fit</kbd> method is that the model learns the characteristics and patterns of the data, and how the <kbd>X</kbd> matrix describes the <kbd>y</kbd> vector. Then, when we call the <kbd>predict</kbd> function, it applies its learned decision function to the input data to make an educated guess:</p>
<pre>from sklearn.linear_model import LogisticRegression<br/><br/>def learn_life_lession(X, y):<br/>    """Learn a lesson abd apply it in a future situation"""<br/>    model = LogisticRegression().fit(X, y)<br/>    return (lambda X: model.predict(X))<br/>educated_decision = learn_life_lession(X, y)(X)<br/>educated_decision</pre>
<p>The output of the preceding code is as follows:</p>
<pre>array([1, 1, 0, 0, 0, 1, 1, 0, 1, 0])</pre>
<p>So, now we're at a point where we need to define specifically what supervised learning is. Supervised learning is precisely the example we just described previously. Given our matrix of examples, <em>X</em>, in a vector of corresponding labels, <em>y</em>, that learns a function which approximates the value of <em>y</em> or <img class="fm-editor-equation" src="assets/ec167647-fd63-4575-af06-3c72ac2af74b.png" style="width:0.83em;height:1.58em;"/>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/8bae7a15-da5a-4a4b-ab78-6e5a9587ff51.png" style="width:7.92em;height:1.58em;"/></p>
<p>There are other forms of machine learning that are not supervised, known as <strong>unsupervised machine learning</strong>. These do not have labels and are more geared toward pattern recognition tasks. So, what makes something supervised is the presence of labeled data.</p>
<p>Going back to our previous example, when we invoke the <kbd>fit</kbd> method, we learn our new decision function and then, when we call <kbd>predict</kbd>, we're approximating the new <kbd>y</kbd> values. So, the output is this <img class="fm-editor-equation" src="assets/68d94b46-bc5d-4c32-9c89-4805452ca273.png" style="width:0.83em;height:1.58em;"/> we just looked at:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-186 image-border" src="assets/4430bb58-e5a2-4710-8fb3-a957fc2e1684.png" style="width:36.67em;height:17.67em;"/></p>
<p>Supervised learning learns a function from labelled samples that approximates future <kbd>y</kbd> values. At this point, you should feel comfortable explaining the abstract concept—just the high-level idea of what supervised machine learning is.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Hill climbing and loss functions</h1>
                </header>
            
            <article>
                
<p>In the last section, we got comfortable with the idea of supervised machine learning. Now, we will learn how exactly a machine learns underneath the hood. This section is going to examine a common optimization technique used by many machine learning algorithms, called <strong>hill climbing</strong>. It is predicated on the fact that each problem has an ideal state and a way to measure how close or how far we are from that. It is important to note that not all machine learning algorithms use this approach.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Loss functions</h1>
                </header>
            
            <article>
                
<p>First, we'll cover loss functions, and then, prior to diving into hill climbing and descent, we'll take a quick math refresher.</p>
<div class="packt_tip packt_infobox">There's going to be some math in this lesson, and while we try to shy away from the purely theoretical concepts, this is something that we simply have to get through in order to understand the guts of most of these algorithms. There will be a brief applied section at the end. Don't panic if you can't remember some of the calculus; just simply try to grasp what is happening behind the black box.</div>
<p>So, as mentioned before, a machine learning algorithm has to measure how close it is to some objective. We define this as a cost function, or a loss function. Sometimes, we hear it referred to as an objective function. Although not all machine learning algorithms are designed to directly minimize a loss function, we're going to learn the rule here rather than the exception. The point of a loss function is to determine the goodness of a model fit. It is typically evaluated over the course of a model's learning procedure and converges when the model has maximized its learning capacity.</p>
<p>A typical loss function computes a scalar value which is given by the true labels and the predicted labels. That is, given our actual <em>y</em> and our predicted <em>y</em>, which is <img class="fm-editor-equation" src="assets/6adc46e5-4e64-4050-b55c-5c1d8e0e8e55.png" style="width:0.67em;height:1.25em;"/>. This notation might be cryptic, but all it means is that some function, <em>L</em>, which we're going to call our loss function, is going to accept the ground truth, which is <em>y</em> and the predictions, <img class="fm-editor-equation" src="assets/6fa4fd62-405e-4353-b7bf-35e9022c2f5a.png" style="width:0.75em;height:1.42em;"/>, and return some scalar value. The typical formula for the loss function is given as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/18aa419c-7dd3-45df-8bcf-d7724f238d73.png" style="width:6.83em;height:1.42em;"/></p>
<p>So, I've listed several common loss functions here, which may or may not look familiar. <strong>Sum of Squared Error</strong> (<strong>SSE</strong>) is a metric that we're going to be using for our regression models:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/fc07628b-c403-4b88-8337-300ee6bcf651.png" style="width:20.33em;height:3.08em;"/></p>
<p>Cross entropy is a very commonly used classification metric:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/29b4930c-d8a3-4fd2-b805-b7a4466b5e58.png" style="width:24.50em;height:2.67em;"/></p>
<p>In the following diagram, the <em>L</em> function on the left is simply indicating that it is our loss function over <em>y</em> and <img class="fm-editor-equation" src="assets/ba99764f-61f6-4266-806b-7acbb95ed809.png" style="width:0.83em;height:1.58em;"/> given parameter theta. So, for any algorithm, we want to find the set of the theta parameters that minimize the loss. That is, if we're predicting the cost of a house, for example, we may want to estimate the cost per square foot as accurately as possible so as to minimize how wrong we are.</p>
<p>Parameters are often in a much higher dimensional space than can be represented visually. So, the big question we're concerned with is the following: How can we minimize the cost? It is typically not feasible for us to attempt every possible value to determine the true minimum of a problem. So, we have to find a way to descend this nebulous hill of loss. The tough part is that, at any given point, we don't know whether the curve goes up or down without some kind of evaluation. And that's precisely what we want to avoid, because it's very expensive:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-187 image-border" src="assets/8dfdcaa5-bf54-47ff-a8af-dbfc885a2b29.png" style="width:20.00em;height:10.42em;"/></p>
<p>We can describe this problem as waking up in a pitch-black room with an uneven floor and trying to find the lowest point in the room. You don't know how big the room is. You don't know how deep or how high it gets. Where do you step first? One thing we can do is to examine exactly where we stand and determine which direction around us slopes downward. To do that, we have to measure the slope of the curve.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Measuring the slope of a curve</h1>
                </header>
            
            <article>
                
<p>The following is a quick refresher on scalar derivatives. To compute the slope at any given point, the standard way is to typically measure the slope of the line between the point we're interested in and some secant point, which we'll call delta <em>x</em>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-188 image-border" src="assets/2ec22951-f7ed-4b45-bc08-48fba2dd67ce.png" style="width:18.67em;height:10.67em;"/></p>
<p>As the distance between <em>x</em> and its neighbor delta <em>x</em> approaches <em>0</em>, or as our limit approaches <em>0</em>, we arrive at the slope of the curve. This is given by the following formula:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/30cef7ab-b444-4823-aacf-64bdda6d6016.png" style="width:19.08em;height:2.58em;"/></p>
<p>There are several different notations that you may be familiar with. One is <em>f</em> prime of <em>x</em>. The slope of a constant is <em>0</em>. So, if <em>f(x)</em> is <em>9</em>, in other words, if <em>y</em> is simply <em>9</em>, it never changes. There is no slope. So, the slope is <em>0</em>, as shown:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/7dcce59e-5617-411b-921e-e5497a64a9b4.png" style="width:3.92em;height:2.25em;"/></p>
<p>We can also see the power law in effect here in the second example. This will come in useful later on. If we multiply the variable by the power, and decrement the power by one, we get the following:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/22f03da9-d95c-4c95-9857-020d6fe1b9f3.png" style="width:6.58em;height:2.67em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Measuring the slope of an Nd-curve</h1>
                </header>
            
            <article>
                
<p>In order to measure the slope of a vector or a multi-dimensional surface, we will introduce the idea of partial derivatives, which are simply derivatives with respect to a variable, with all the other variables held as constants. So, our solution is a vector of dimension <em>k</em>, where <em>k</em> is the number of variables that our function takes. In this case, we have <em>x</em> and <em>y</em>. Each respective position in the vector that we solve is a derivative with respect to the corresponding function's positional variable.</p>
<p>From a conceptual level, what we're doing is we're holding one of the variables still and changing the other variables around it to see how the slope changes. Our denominator's notation indicates which variable we're measuring the slope with, with respect to that point. So, in this case, the first position, <em>d(x)</em>, is showing that we're taking the partial derivative of function <em>f</em> with respect to <em>x</em>, where we hold <em>y</em> constant. And then, likewise, in the second one, we're taking the derivative of function f with respect to <em>y</em>, holding <em>x</em> constant. So, what we get in the end is called a gradient, which is a super keyword. It is simply just a vector of partial derivatives:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/62ac4d23-5f7d-460a-858a-bdd93f6f3646.png" style="width:7.58em;height:1.58em;"/></p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/e86981ff-c747-49ba-a53d-8ee22588f525.png" style="width:21.00em;height:2.67em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Measuring the slope of multiple functions</h1>
                </header>
            
            <article>
                
<p>We want to get really complicated, though, and measure the slopes of multiple functions at the same time. All we'll end up with is a matrix of gradients along the rows. In the following formula, we can see the solution that we just solved from the previous example:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/38704fda-a85a-4fec-9e1c-4fbbcc29ff32.png" style="width:7.08em;height:1.50em;"/></p>
<p>In the next formula, we have introduced this new function, called <em>g</em>. We see the gradient for function <em>g</em>, with each position corresponding to the partial derivative with respect to the variables <em>x</em> and <em>y</em>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/0a984ad0-25f6-4b2f-8613-03876048985a.png" style="width:9.50em;height:1.67em;"/></p>
<p class="mce-root"/>
<p>When we stack these together into a matrix, what we get is a Jacobian. You don't need to solve this, but you should understand that what we're doing is taking the slope of a multi-dimensional surface. You can treat it as a bit of a black box as long as you understand that. This is exactly how we're computing the gradient and the Jacobian:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/f5f178d0-8f97-4450-8043-e9fb391a1bfe.png" style="width:24.75em;height:4.33em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Hill climbing and descent</h1>
                </header>
            
            <article>
                
<p>We will go back to our example—the lost hill that we looked at. We want to find a way to select a set of theta parameters that is going to minimize our loss function, <em>L</em>. As we've already established, we need to climb or descend the hill, and understand where we are with respect to our neighboring points without having to compute everything. To do that, we need to be able to measure the slope of the curve with respect to the theta parameters. So, going back to our house example, as mentioned before, we want to know how much correct the incremental value of cost per square foot makes. Once we know that, we can start taking directional steps toward finding the best estimate. So, if you make a bad guess, you can turn around and go in exactly the other direction. So, we can either climb or descend the hill depending on our metric, which allows us to optimize the parameters of a function that we want to learn irrespective of how the function itself performs. This is a layer of abstraction. This optimization process is called gradient descent, and it <span><span>supports</span></span> many of the machine learning algorithms that we will discuss in this book.</p>
<p>The following code shows a simple example of how we can measure the gradient of a matrix with respect to theta. This example is actually a simplified snippet of the learning component of logistic regression:</p>
<pre>import numpy as np<br/><br/>seed = (42)<br/><br/>X = np.random.RandomState(seed).rand(5, 3).round(4)<br/><br/>y = np.array([1, 1, 0, 1, 0])<br/><br/>h = (lambda X: 1. / (1. + np.exp(-X)))<br/><br/>theta = np.zeros(3)<br/><br/>lam = 0.05<br/><br/>def iteration(theta):<br/><br/>    y_hat = h(X.dot(theta))<br/><br/>    residuals = y - y_hat<br/><br/>    gradient = X.T.dot(residuals)<br/>    theta += gradient * lam<br/>    print("y hat: %r" % y_hat.round(3).tolist())<br/>    print("Gradient: %r" % gradient.round(3).tolist())<br/>    print("New theta: %r\n" % theta.round(3).tolist())<br/><br/>iteration(theta)<br/>iteration(theta)</pre>
<p>At the very top, we randomly initialize <kbd>X</kbd> and <kbd>y</kbd>, which is not part of the algorithm. So, <kbd>x</kbd> here is the sigmoid function, also called the <strong>logistic function</strong>. The word logistic comes from logistic progression. This is a necessary transformation that is applied in logistic regression. Just understand that we have to apply that; it's part of the function. So, we initialize our <kbd>theta</kbd> vector, with respect to which we're going to compute our gradient as zeros. Again, all of them are zeros. Those are our parameters. Now, for each iteration, we're going to get our <img class="fm-editor-equation" src="assets/c700ee8d-f92f-44b3-9ac0-54c1cb781e40.png" style="width:0.67em;height:1.25em;"/>, which is our estimated <kbd>y</kbd>, if you recall. We get that by taking the dot product of our <kbd>X</kbd> matrix against our theta <span>parameters</span>, pushed through that logistic function, <kbd>h</kbd>, <span><span>which</span></span> is our <img class="fm-editor-equation" src="assets/9fa6e3b4-1d08-487f-b97c-17fbef8dfa08.png" style="width:0.67em;height:1.25em;"/>.</p>
<p>Now, we want to compute the gradient of that dot product between the residuals and the input matrix, <kbd>X</kbd>, of our predictors. The way we compute our residuals is simply <kbd>y</kbd> minus <img class="fm-editor-equation" src="assets/038cd708-4e73-4af7-a532-e5f7a70612f5.png" style="width:0.58em;height:1.08em;"/>, which gives the residuals. Now, we have our <img class="fm-editor-equation" src="assets/e627b377-2a40-4d23-9e9d-409a0db456e6.png" style="width:0.75em;height:1.42em;"/>. How do we get the gradient? The gradient is just the dot product between the input matrix, <kbd>X</kbd>, and those residuals. We will use that gradient to determine which direction we need to step in. The way we do that is we add the gradient to our theta vector. Lambda regulates how quickly we step up or down that gradient. So, it's our learning rate. If you think of it as a step size—going back to that dark room example—if it's too large, it's easy to overstep the lowest point. But if it's too small, you're going to spend forever inching around the room. So, it's a bit of a balancing act, but it allows us to regulate the pace at which we update our theta values and descend our gradient. Again, this algorithm is something we will cover in the next chapter.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>We get the output of the preceding code as follows:</p>
<pre>y hat: [0.5, 0.5, 0.5, 0.5, 0.5]<br/>Gradient: [0.395, 0.024, 0.538]<br/>New theta: [0.02, 0.001, 0.027]<br/><br/>y hat: [0.507, 0.504, 0.505, 0.51, 0.505]<br/>Gradient: [0.378, 0.012, 0.518]<br/>New theta: [0.039, 0.002, 0.053]<br/><br/></pre>
<p>This example demonstrates how our gradient or slope actually changes as we adjust our coefficients and vice versa.</p>
<p>In the next section, we will see how to evaluate our models and learn the cryptic <kbd>train_test_split</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Model evaluation and data splitting</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will define what it means to evaluate a model, best practices for gauging the advocacy of a model, how to split your data, and several considerations that you'll have to make when preparing your split.</p>
<p>It is important to understand some core best practices of machine learning. One of our primary tasks as ML practitioners is to create a model that is effective for making predictions on new data. But how do we know that a model is good? If you recall from the previous section, we defined supervised learning as simply a task that learns a function from labelled data such that we can approximate the target of the new data. Therefore, we can test our model's effectiveness. We can determine how it performs on data that is never seen—just like it's taking a test.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Out-of-sample versus in-sample evaluation</h1>
                </header>
            
            <article>
                
<p>Let's say we are training a small machine which is a simple classification task. Here's some nomenclature you'll need: the in-sample data is the data the model learns from and the out-of-sample data is the data the model has never seen before. One of the pitfalls many new data scientists make is that they measure their model's effectiveness on the same data that the model learned from. What this ends up doing is rewarding the model's ability to memorize, rather than its ability to generalize, which is a huge difference.</p>
<p>If you take a look at the two examples here, the first presents a sample that the model learned from, and we can be reasonably confident that it's going to predict one, which would be correct. The second example presents a new sample, which appears to resemble more of the zero class. Of course, the model doesn't know that. But a good model should be able to recognize and generalize this pattern, shown as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-189 image-border" src="assets/2fbc7355-5703-4c20-86a5-84d65ef157cb.png" style="width:33.33em;height:14.67em;"/></p>
<p>So, now the question is how we can ensure both in-sample and out-of-sample data for the model to prove its worth. Even more precisely, our out-of-sample data needs to be labeled. New or unlabeled data won't suffice because we have to know the actual answer in order to determine how correct the model is. So, one of the ways we can handle this in machine learning is to split our data into two parts: a training set and a testing set. The training set is what our model will learn on; the testing set is what our model will be evaluated on. How much data you have matters a lot. In fact, in the next sections, when we discuss the bias-variance trade-off, you'll see how some models require much more data to learn than others do.</p>
<p>Another thing to keep in mind is that if some of the distributions of your variables are highly skewed, or you have rare categorical levels embedded throughout, or even class imbalance in your <kbd>y</kbd> vector, you may end up getting a bad split. As an example, let's say you have a binary feature in your <kbd>X</kbd> matrix that indicates the presence of a very rare sensor for some event that occurs every 10,000 occurrences. If you randomly split your data and all of the positive sensor events are in your test set, then your model will learn from the training data that the sensor is never tripped and may deem that as an unimportant variable when, in reality, it could be hugely important, and hugely predictive. So, you can control these types of issues with stratification.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Splitting made easy</h1>
                </header>
            
            <article>
                
<p class="CDPAlignLeft CDPAlign">Here, we have a simple snippet that demonstrates how we can use the scikit-learn library to split our data into training and test sets. We're loading the data in from the datasets module and passing both <kbd>X</kbd> and <kbd>y</kbd> into the split function. We should be familiar with loading the data up. We have the <kbd>train_test_split</kbd> function from the <kbd>model_selection</kbd> submodule in <kbd>sklearn</kbd>. This is going to take any number of arrays. So, 20% is going to be <kbd>test_size</kbd>, and the remaining 80% of that data will be training. We define <kbd>random_state</kbd>, so that our split can be reproducible if we ever have to prove exactly how we got this split. There's also the <kbd>stratify</kbd> keyword, which we're not using here, which can be used to <kbd>stratify</kbd> a split for rare features or an imbalanced <kbd>y</kbd> vector:</p>
<pre>from sklearn.datasets import load_boston<br/><br/>from sklearn.model_selection import train_test_split<br/><br/><br/><br/>boston_housing = load_boston() # load data<br/><br/>X, y = boston_housing.data, boston_housing.target # get X, y<br/><br/>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2,<br/><br/>                                                                                                              random_state=42)<br/><br/><span># show num samples (there are no duplicates in either set!)</span><br/>print("Num train samples: %i" % X_train.shape[0])<br/><br/>print("Num test samples: %i" % X_test.shape[0])</pre>
<p>The output of the preceding code is as follows:</p>
<pre>Num train samples: 404<br/>Num test samples: 102</pre>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we introduced supervised learning, got our environment put together, and learned about hill climbing and model evaluation. At this point, you should understand the abstract conceptual underpinnings of what makes a machine learn. It's all about optimizing a number of loss functions. In the next chapter, we'll jump into parametric models and even code some popular algorithms from scratch.</p>


            </article>

            
        </section>
    </body></html>