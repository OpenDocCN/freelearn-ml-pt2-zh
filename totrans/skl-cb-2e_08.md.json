["```py\n#load the libraries we have been using\nimport numpy as np \nimport pandas as pd \nimport matplotlib.pyplot as plt  #Library for visualization\n\nfrom sklearn import datasets\n\niris = datasets.load_iris()\nX_w = iris.data[:, :2]  #load the first two features of the iris data \ny_w = iris.target         #load the target of the iris data\n```", "```py\n#select only the first two classes for both the feature set and target set\n#the first two classes of the iris dataset: Setosa (0), Versicolour (1)\n\nX = X_w[y_w < 2] \ny = y_w[y_w < 2]\n\n```", "```py\nX_0 = X[y == 0]\nX_1 = X[y == 1]\n\n#to visualize within IPython:\n%matplotlib inline \nplt.figure(figsize=(10,7)) #change figure-size for easier viewing\nplt.scatter(X_0[:,0],X_0[:,1], color = 'red')\nplt.scatter(X_1[:,0],X_1[:,1], color = 'blue')\n```", "```py\nfrom sklearn.model_selection import train_test_split\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=7,stratify=y)\n```", "```py\nfrom sklearn.svm import SVC\n\nsvm_inst = SVC(kernel='linear')\n```", "```py\nsvm_inst.fit(X_train,y_train)\n```", "```py\ny_pred = svm_inst.predict(X_test)\n```", "```py\nfrom sklearn.metrics import accuracy_score\n\naccuracy_score(y_test, y_pred) \n\n1.0\n```", "```py\nfrom itertools import product\n\n#Minima and maxima of both features\nxmin, xmax = np.percentile(X[:, 0], [0, 100])\nymin, ymax = np.percentile(X[:, 1], [0, 100])\n\n#Grid/Cartesian product with itertools.product\ntest_points = np.array([[xx, yy] for xx, yy in product(np.linspace(xmin, xmax), np.linspace(ymin, ymax))])\n\n#Predictions on the grid\ntest_preds = svm_inst.predict(test_points)\n```", "```py\nX_0 = X[y == 0]\nX_1 = X[y == 1]\n\n%matplotlib inline\nplt.figure(figsize=(10,7))   #change figure-size for easier viewing\nplt.scatter(X_0[:,0],X_0[:,1], color = 'red')\nplt.scatter(X_1[:,0],X_1[:,1], color = 'blue')\n\ncolors = np.array(['r', 'b'])\nplt.scatter(test_points[:, 0], test_points[:, 1], color=colors[test_preds], alpha=0.25)\nplt.scatter(X[:, 0], X[:, 1], color=colors[y])\nplt.title(\"Linearly-separated classes\")\n```", "```py\nsvm_inst.coef_\n\narray([[ 2.22246001, -2.2213921 ]])\n\nsvm_inst.intercept_\n\narray([-5.00384439])\n```", "```py\nsvm_inst\n\nSVC(C=1.0, cache_size=200, class_weight=None, coef0=0.0,\n decision_function_shape=None, degree=3, gamma='auto', kernel='linear',\n max_iter=-1, probability=False, random_state=None, shrinking=True,\n tol=0.001, verbose=False)\n```", "```py\n#load the libraries we have been using\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nfrom sklearn import datasets\n\niris = datasets.load_iris()\nX_w = iris.data[:, :2]  #load the first two features of the iris data \ny_w = iris.target       #load the target of the iris data\n\nX = X_w[y_w != 0]\ny = y_w[y_w != 0]\n\nX_1 = X[y == 1]\nX_2 = X[y == 2]\n```", "```py\nfrom sklearn.model_selection import train_test_split\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=7,stratify=y)\n```", "```py\nfrom sklearn.svm import SVC\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.preprocessing import StandardScaler\n\nsvm_est = Pipeline([('scaler',StandardScaler()),('svc',SVC())])\n```", "```py\nCs = [0.001, 0.01, 0.1, 1, 10]\ngammas = [0.001, 0.01, 0.1, 1, 10]\n```", "```py\nparam_grid = dict(svc__gamma=gammas, svc__C=Cs)\n```", "```py\nfrom sklearn.model_selection import StratifiedShuffleSplit\n\ncv = StratifiedShuffleSplit(n_splits=5, test_size=0.2, random_state=7)\n```", "```py\ncv = 10\n```", "```py\nfrom sklearn.model_selection import GridSearchCV\n\ngrid_cv = GridSearchCV(svm_est, param_grid=param_grid, cv=cv)\ngrid_cv.fit(X_train, y_train)\n```", "```py\ngrid_cv.best_params_\n\n{'svc__C': 10, 'svc__gamma': 0.1}\n```", "```py\ngrid_cv.best_score_\n\n0.71250000000000002\n```", "```py\nfrom sklearn.model_selection import RandomizedSearchCV\n\nrand_grid = RandomizedSearchCV(svm_est, param_distributions=param_grid, cv=cv,n_iter=10)\nrand_grid.fit(X_train, y_train)\n```", "```py\nrand_grid.best_params_\n\n{'svc__C': 10, 'svc__gamma': 0.001}\n```", "```py\nfrom itertools import product\n\n#Minima and maxima of both features\nxmin, xmax = np.percentile(X[:, 0], [0, 100])\nymin, ymax = np.percentile(X[:, 1], [0, 100])\n\n#Grid/Cartesian product with itertools.product\ntest_points = np.array([[xx, yy] for xx, yy in product(np.linspace(xmin, xmax), np.linspace(ymin, ymax))])\n\n#Predictions on the grid\ntest_preds = grid_cv.predict(test_points)\n```", "```py\nX_1 = X[y == 1]\nX_2 = X[y == 2]\n\n%matplotlib inline\nplt.figure(figsize=(10,7))   #change figure-size for easier viewing\nplt.scatter(X_2[:,0],X_2[:,1], color = 'red')\nplt.scatter(X_1[:,0],X_1[:,1], color = 'blue')\n\ncolors = np.array(['r', 'b'])\nplt.scatter(test_points[:, 0], test_points[:, 1], color=colors[test_preds-1], alpha=0.25)\nplt.scatter(X[:, 0], X[:, 1], color=colors[y-1]) \nplt.title(\"RBF-separated classes\")\n```", "```py\n#load the libraries we have been using\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nfrom sklearn import datasets\n\niris = datasets.load_iris()\nX = iris.data[:, :2]  #load the first two features of the iris data \ny = iris.target       #load the target of the iris data\n\nX_0 = X[y == 0]\nX_1 = X[y == 1]\nX_2 = X[y == 2]\n```", "```py\nfrom sklearn.model_selection import train_test_split\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=7,stratify=y)\n```", "```py\nfrom sklearn.svm import SVC\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.multiclass import OneVsRestClassifier\n\nsvm_est = Pipeline([('scaler',StandardScaler()),('svc',OneVsRestClassifier(SVC()))])\n```", "```py\nCs = [0.001, 0.01, 0.1, 1, 10]\ngammas = [0.001, 0.01, 0.1, 1, 10]\n```", "```py\nparam_grid = dict(svc__estimator__gamma=gammas, svc__estimator__C=Cs)\n```", "```py\nfrom sklearn.model_selection import RandomizedSearchCV\nfrom sklearn.model_selection import StratifiedShuffleSplit\n\ncv = StratifiedShuffleSplit(n_splits=5, test_size=0.2, random_state=7)\nrand_grid = RandomizedSearchCV(svm_est, param_distributions=param_grid, cv=cv,n_iter=10)\nrand_grid.fit(X_train, y_train)\n```", "```py\nrand_grid.best_params_\n\n{'svc__estimator__C': 10, 'svc__estimator__gamma': 0.1}\n```", "```py\n%matplotlib inline\nfrom itertools import product\n\n#Minima and maxima of both features\nxmin, xmax = np.percentile(X[:, 0], [0, 100])\nymin, ymax = np.percentile(X[:, 1], [0, 100])\n\n#Grid/Cartesian product with itertools.product\ntest_points = np.array([[xx, yy] for xx, yy in product(np.linspace(xmin, xmax,100), np.linspace(ymin, ymax,100))])\n\n#Predictions on the grid\ntest_preds = rand_grid.predict(test_points)\n\nplt.figure(figsize=(15,9))   #change figure-size for easier viewing\n\nplt.scatter(X_0[:,0],X_0[:,1], color = 'green')\nplt.scatter(X_1[:,0],X_1[:,1], color = 'blue')\nplt.scatter(X_2[:,0],X_2[:,1], color = 'red')\n\ncolors = np.array(['g', 'b', 'r'])\nplt.tight_layout()\nplt.scatter(test_points[:, 0], test_points[:, 1], color=colors[test_preds], alpha=0.25)\nplt.scatter(X[:, 0], X[:, 1], color=colors[y])\n```", "```py\n#load the libraries we have been using\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nfrom sklearn import datasets\n\ndiabetes = datasets.load_diabetes()\n\nX = diabetes.data\ny = diabetes.target\n```", "```py\nfrom sklearn.model_selection import train_test_split\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=7)\n```", "```py\nfrom sklearn.svm import SVR\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.multiclass import OneVsRestClassifier\n\nsvm_est = Pipeline([('scaler',StandardScaler()),('svc',OneVsRestClassifier(SVR()))])\n```", "```py\nCs = [0.001, 0.01, 0.1, 1]\ngammas = [0.001, 0.01, 0.1]\n\nparam_grid = dict(svc__estimator__gamma=gammas, svc__estimator__C=Cs)\n```", "```py\nfrom sklearn.model_selection import RandomizedSearchCV\nfrom sklearn.model_selection import StratifiedShuffleSplit\n\nrand_grid = RandomizedSearchCV(svm_est, param_distributions=param_grid, cv=5,n_iter=5,scoring='neg_mean_absolute_error')\nrand_grid.fit(X_train, y_train)\n```", "```py\nrand_grid.best_params_\n\n{'svc__estimator__C': 10, 'svc__estimator__gamma': 0.1}\n```", "```py\nrand_grid.best_score_\n\n-58.059490084985839\n```"]