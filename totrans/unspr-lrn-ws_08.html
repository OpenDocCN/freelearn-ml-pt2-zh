<html><head></head><body>
		<div>
			<div id="_idContainer195" class="Content">
			</div>
		</div>
		<div id="_idContainer196" class="Content">
			<h1 id="_idParaDest-135"><a id="_idTextAnchor138"/>7. Topic Modeling</h1>
		</div>
		<div id="_idContainer264" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">In this chapter, we will perform basic cleaning techniques for textual data and then model the cleaned data to derive relevant topics. You will evaluate <strong class="bold">Latent Dirichlet Allocation</strong> (<strong class="bold">LDA</strong>) models and execute <strong class="bold">non-negative matrix factorization</strong> (<strong class="bold">NMF</strong>) models. Finally, you will interpret the results of topic models and identify the best topic model for the given scenario. We will see how topic modeling provides insights into the underlying structure of documents. By the end of this chapter, you will be able to build fully functioning topic models to derive value and insights for your business.</p>
			<h1 id="_idParaDest-136"><a id="_idTextAnchor139"/>Introduction</h1>
			<p>In the last chapter, the discussion focused on preparing data for modeling using dimensionality reduction and autoencoding. Large feature sets can be problematic when it comes to modeling because of multicollinearity and extensive computation and can thereby hinder real-time prediction. Dimensionality reduction using principal component analysis is one antidote to that problem. Similarly, autoencoders seek to find optimal feature encodings. You can think of autoencoders as a means of identifying quality interaction terms for the dataset. Let's now move past dimensionality reduction and look at some real-world modeling techniques.</p>
			<p>Topic modeling is one facet of <strong class="bold">Natural Language Processing</strong> (<strong class="bold">NLP</strong>), the field of computer science exploring the syntactic and semantic analysis of natural language, which has been increasing in popularity with the increased availability of textual datasets. NLP can deal with language in almost any form, including text, speech, and images. Besides topic modeling, sentiment analysis, entity recognition, and object character recognition are noteworthy NLP applications. </p>
			<p>Nowadays, the data being collected and analyzed comes less frequently in standard tabular forms and more often in less structured forms, such as documents, images, and audio files. As such, successful data science practitioners need to be fluent in the methodologies used to handle these diverse datasets. </p>
			<p>Here is a demonstration of identifying words in a text and assigning them to topics:</p>
			<div>
				<div id="_idContainer197" class="IMG---Figure">
					<img src="image/B15923_07_01.jpg" alt="Figure 7.1: Example of identifying words in a text and assigning them to topics&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1: Example of identifying words in a text and assigning them to topics</p>
			<p>Your immediate question is probably <em class="italic">what are topics?</em> Let's answer that question with an example. You could imagine, or perhaps have noticed, that on days when major events take place (such as national elections, natural disasters, or sports championships), the posts on social media websites tend to focus on those events. Posts generally reflect, in some way, the day's events, and they will do so in varying ways. Posts can, and will, have a number of divergent viewpoints that can be clustered into high-level topics. If we had tweets about the World Cup final, the topics of those tweets could cover divergent viewpoints, ranging from the quality of the refereeing to fan behavior. In the United States, the president delivers an annual speech in mid to late January called the State of the Union. With sufficient numbers of social media posts, we would be able to infer or predict high-level reactions (topics) to the speech from the social media community by grouping posts using the specific keywords contained in them. Topic models are important because they serve the same role for textual data that classic summary statistics serve for numeric data. That is, they provide a meaningful summarization of data. Let's return to the State of the Union example. The quick look here would be ascertaining the major points of the speech that either resonate with or miss the viewership.</p>
			<h1 id="_idParaDest-137"><a id="_idTextAnchor140"/>Topic Models</h1>
			<p>Topic models fall into the unsupervised learning bucket because, almost always, the topics being identified are not known in advance. So, no target exists on which we can perform regression or classification modeling. In terms of unsupervised learning, topic models most resemble clustering algorithms, specifically k-means clustering. You'll recall that, in k-means clustering, the number of clusters is established first, and then the model assigns each data point to one of the predetermined number of clusters. The same is generally true of topic models. We select the number of topics at the start, and then the model isolates the words that form that number of topics. This is a great jumping-off point for a high-level topic modeling overview.</p>
			<p>Before that, let's check that the correct environment and libraries are installed and ready for use. The following table lists the required libraries and their main purposes:</p>
			<div>
				<div id="_idContainer198" class="IMG---Figure">
					<img src="image/B15923_07_02.jpg" alt="Figure 7.2: Table showing different libraries and their use&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.2: Table showing different libraries and their use</p>
			<p>If any or all of these libraries are not currently installed, install the required packages via the command line using <strong class="source-inline">pip</strong>; for example, <strong class="source-inline">pip install langdetect</strong>.</p>
			<p><em class="italic">Step 3</em> of the forthcoming exercise covers the installation of word dictionaries from the <strong class="source-inline">nltk</strong> package. Word dictionaries are simply collections of words that are curated for a specific use. The stop words word dictionary, installed below, contains the common words in the English language that do not clarify context, meaning, or intention. These common words could include <em class="italic">the</em>, <em class="italic">an</em>, <em class="italic">a</em>, and <em class="italic">in</em>. The word net word dictionary provides word mappings that help in the lemmatization process â€“ explained below. The word mappings link words such as <em class="italic">run</em>, <em class="italic">running</em>, and <em class="italic">ran</em> together as all essentially meaning the same thing. At a high level, word dictionaries provide data scientists with a means of preparing text data for analysis without having an in-depth knowledge of linguistics or spending an enormous amount of time defining word lists or word mappings.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">In the exercises and activities below, the results can differ slightly from what is shown because of the optimization algorithms that support both Latent Dirichlet Allocation and Non-negative Matrix Factorization. Many of the functions do not have a seed setting capability.</p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor141"/>Exercise 7.01: Setting up the Environment</h2>
			<p>To check whether the environment is ready for topic modeling, we will perform several steps. The first of these involves loading all the libraries that will be needed in this chapter:</p>
			<ol>
				<li>Open a new Jupyter notebook.</li>
				<li>Import the requisite libraries:<p class="source-code">import langdetect</p><p class="source-code">import matplotlib.pyplot</p><p class="source-code">import nltk</p><p class="source-code">import numpy</p><p class="source-code">import pandas</p><p class="source-code">import pyLDAvis</p><p class="source-code">import pyLDAvis.sklearn</p><p class="source-code">import regex</p><p class="source-code">import sklearn</p><p>Note that not all of these packages are used for cleaning the data; some of them are used in the actual modeling. But it is useful to import all of the required libraries at once, so let's take care of all library importing now.</p><p>Libraries not yet installed will return the following error:</p><div id="_idContainer199" class="IMG---Figure"><img src="image/B15923_07_03.jpg" alt="Figure 7.3: Library not installed error&#13;&#10;"/></div><p class="figure-caption">Figure 7.3: Library not installed error</p><p>If this error is returned, install the relevant libraries via the command line as previously discussed. Once successfully installed, rerun the library import process using <strong class="source-inline">import</strong>.</p></li>
				<li>Certain textual data cleaning and preprocessing processes require word dictionaries. Here, we'll install two of these dictionaries. If the <strong class="source-inline">nltk</strong> library is imported, execute the following code:<p class="source-code">nltk.download('wordnet')</p><p class="source-code">nltk.download('stopwords')</p><p>The output is as follows:</p><div id="_idContainer200" class="IMG---Figure"><img src="image/B15923_07_04.jpg" alt="Figure 7.4: Importing libraries and downloading dictionaries&#13;&#10;"/></div><p class="figure-caption">Figure 7.4: Importing libraries and downloading dictionaries</p></li>
				<li>Run <strong class="source-inline">matplotlib</strong> and specify inline so that the plots print inside the notebook:<p class="source-code">%matplotlib inline</p></li>
			</ol>
			<p>The notebook and environment are now set and ready for data loading.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/34gLGKa">https://packt.live/34gLGKa</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/3fbWQES">https://packt.live/3fbWQES</a>.</p>
			<p class="callout">You must execute the entire Notebook in order to get the desired result.</p>
			<h2 id="_idParaDest-139"><a id="_idTextAnchor142"/>A High-Level Overview of Topic Models</h2>
			<p>When it comes to analyzing large volumes of potentially related text data, topic models are one go-to approach. By 'related', we mean that the documents describe similar topics. To run any topic model, the only data required are the documents themselves. No additional data (meta or otherwise) is required.</p>
			<p>In the simplest terms, topic models identify the abstract topics (also known as themes) in a collection of documents (referred to as a <strong class="bold">corpus</strong>), using the words contained in the documents. That is, if a sentence contains the words <em class="italic">salary</em>, <em class="italic">employee</em>, and <em class="italic">meeting</em>, it would be safe to assume that that sentence is about, or that its topic is, <em class="italic">work</em>. It is of note that the documents making up the corpus need not be documents as traditionally defined â€“ think letters or contracts. A document could be anything containing text, including tweets, news headlines, or transcribed speech. </p>
			<p>Topic models assume that words in the same document are related and use that assumption to define abstract topics by finding groups of words that repeatedly appear in close proximity. In this way, these models are classic pattern recognition algorithms in which the detected patterns are made up of words. The general topic modeling algorithm has four main steps:</p>
			<ol>
				<li value="1">Determine the number of topics.</li>
				<li>Scan the documents and identify co-occurring words or phrases.</li>
				<li>Auto-learn groups (or clusters) of words characterizing the documents.</li>
				<li>Output abstract topics characterizing the corpus as word groupings.</li>
			</ol>
			<p>As <em class="italic">Step 1</em> notes, the number of topics needs to be selected before fitting the model. Selecting an appropriate number of topics can be tricky, but, as is the case with most machine learning models, this parameter can be optimized by fitting several models using different numbers of topics and selecting the best model based on a performance metric. We'll dive into this process again later.</p>
			<p>The following is the generic topic modeling workflow:</p>
			<div>
				<div id="_idContainer201" class="IMG---Figure">
					<img src="image/B15923_07_05.jpg" alt="Figure 7.5: The generic topic modeling workflow&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.5: The generic topic modeling workflow</p>
			<p>It is important to optimize the number of topics parameter, as this parameter can majorly impact topic coherence. This is because the model finds groups of words that best fit the corpus under the constraint of a predefined number of topics. If the number of topics is too high, the topics become inappropriately narrow. Overly specific topics are referred to as <strong class="bold">over-cooked</strong>. Likewise, if the number of topics is too low, the topics become generic and vague. These types of topics are considered <strong class="bold">under-cooked</strong>. Over-cooked and under-cooked topics can sometimes be fixed by decreasing or increasing the number of topics, respectively. In practice, a frequent and unavoidable result of topic models is that, frequently, at least one topic will be problematic.</p>
			<p>A key aspect of topic models is that they do not produce specific one-word or one-phrase topics, but rather collections of words, each of which represents an abstract topic. Recall the imaginary sentence about <em class="italic">work</em> from before. The topic model built to identify the topics of some hypothetical corpus to which that sentence belongs would not return the word <em class="italic">work</em> as a topic. It would instead return a collection of words, such as <em class="italic">paycheck</em>, <em class="italic">employee</em>, and <em class="italic">boss</em>â€”words that describe the topic and from which the one-word or one-phrase topic could be inferred. This is because topic models understand word <strong class="bold">proximity</strong>, not context. The model has no idea what <em class="italic">paycheck</em>, <em class="italic">employee</em>, and <em class="italic">boss</em> mean; it only knows that these words, generally, whenever they appear, appear in close proximity to one another:</p>
			<div>
				<div id="_idContainer202" class="IMG---Figure">
					<img src="image/B15923_07_06.jpg" alt="Figure 7.6: Inferring topics from word groupings&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.6: Inferring topics from word groupings</p>
			<p>Topic models can be used to predict the topic(s) belonging to unseen documents, but if you are going to make predictions, it is important to recognize that topic models only know the words used to train them. That is, if the unseen documents have words that were not in the training data, the model will not be able to process those words even if they link to one of the topics identified in the training data. Because of this fact, topic models tend to be used more for exploratory analysis and inference than for prediction.</p>
			<p>Each topic model outputs two matrices. The first matrix contains words against topics. It lists each word related to each topic with some quantification of the relationship. Given the number of words being considered by the model, each topic is only going to be described by a relatively small number of words. </p>
			<p>Words can either be assigned to one topic or to multiple topics with differing quantifications. Whether words are assigned to one or multiple topics depends on the algorithm. Similarly, the second matrix contains documents against topics. It maps each document to each topic by some quantification of the relationship of each document topic combination. </p>
			<p>When discussing topic modeling, it is important to continually reinforce the fact that the word groups representing topics are not related conceptually; they are related only by proximity. The frequent proximity of certain words in the documents is enough to define topics because of an assumption stated previouslyâ€”that all words in the same document are related. </p>
			<p>However, this assumption may either not be true or the words may be too generic to form coherent topics. Interpreting abstract topics involves balancing the innate characteristics of text data with the generated word groupings. Text data, and language in general, is highly variable, complex, and contextual, which means any generalized result needs to be consumed cautiously.</p>
			<p>This is not to downplay or invalidate the results of the model. Given thoroughly cleaned documents and an appropriate number of topics, word groupings, as we will see, can be a good guide as to what is contained in a corpus and can effectively be incorporated into larger data systems.</p>
			<p>We have discussed some of the limitations of topic models already, but there are some additional points to consider. The noisy nature of text data can lead topic models to assign words unrelated to one of the topics to that topic.</p>
			<p>Again, consider the sentence about <em class="italic">work</em> from before. The word <em class="italic">meeting</em> could appear in the word grouping representing the topic <em class="italic">work</em>. It is also possible that the word <em class="italic">long</em> could be in that group, but the word <em class="italic">long</em> is not directly related to <em class="italic">work</em>. <em class="italic">Long</em> may be in the group because it frequently appears in close proximity to the word <em class="italic">meeting</em>. Therefore, <em class="italic">long</em> would probably be considered to be falsely (or spuriously) correlated to <em class="italic">work</em> and should probably be removed from the topic grouping, if possible. Spuriously correlated words in word groupings can cause significant problems when analyzing the data.</p>
			<p>This is not necessarily a flaw in the model. It is, instead, a characteristic that, given noisy data, the model could extract quirks from the data that might negatively impact the results. Spurious correlations could be the result of how, where, or when the data was collected. If the documents were collected only in some specific geographic region, words associated with that region could be incorrectly, albeit accidentally, linked to one or many of the word groupings output from the model.</p>
			<p>Note that, with additional words in the word group, we could be attaching more documents to that topic than should be attached. It should be straightforward that, if we shrink the number of words belonging to a topic, then that topic will be assigned to fewer documents. Keep in mind that this is not a bad thing. We want each word grouping to contain only words that make sense so that we assign the appropriate topics to the appropriate documents.</p>
			<p>There are many topic modeling algorithms, but perhaps the two best known are <strong class="bold">Latent Dirichlet Allocation</strong> (<strong class="bold">LDA</strong>) and <strong class="bold">Non-Negative Matrix Factorization</strong> (<strong class="bold">NMF</strong>). We will discuss both in detail later on.</p>
			<h2 id="_idParaDest-140"><a id="_idTextAnchor143"/>Business Applications</h2>
			<p>Despite its limitations, topic modeling can provide actionable insights that drive business value if used correctly and in the appropriate context. Let's now review some of the biggest applications of topic models.</p>
			<p>One of the use cases is exploratory data analysis on new text data where the underlying structure of the dataset is unknown. This is the equivalent to plotting and computing summary statistics for an unseen dataset featuring numeric and categorical variables whose characteristics need to be understood before more sophisticated analyses can be reasonably performed. With the results of topic modeling, the usability of this dataset in future modeling exercises is ascertainable. For example, if the topic model returns clear and distinct topics, then that dataset would be a great candidate for further clustering-type analyses.</p>
			<p>Determining topics creates an additional variable that can be used to sort, categorize, and/or chunk data. If our topic model returns cars, farming, and electronics as abstract topics, we could filter our large text dataset down to just the documents with farming as a topic. Once filtered, we could perform further analyses, including sentiment analysis, another round of topic modeling, or any other analysis we could think up. Beyond defining the topics present in a corpus, topic modeling returns a lot of other information indirectly that could be used to further break a large dataset down and understand its characteristics. </p>
			<p>Among those characteristics is topic prevalence. Think about performing an analysis on an open response survey that is designed to gauge the response to a product. We could imagine the topic model returning topics in the form of sentiment. One group of words might be <em class="italic">good</em>, <em class="italic">excellent</em>, <em class="italic">recommend</em>, and <em class="italic">quality</em>, while the other might be <em class="italic">garbage</em>, <em class="italic">broken</em>, <em class="italic">poor</em>, and <em class="italic">disappointing</em>.</p>
			<p>Given this style of survey, the topics themselves may not be that surprising, but what would be interesting is that we could count the number of documents containing each topic and glean useful insights from it. From the counts, we could say things like x-percent of the survey respondents had a positive reaction to the product, while only y-percent of the respondents had a negative reaction. Essentially, what we would have created is a rough version of a sentiment analysis.</p>
			<p>Currently, the most frequent use of a topic model is as a component of a recommendation engine. The emphasis today is on personalizationâ€”delivering products to consumers that are specifically designed and curated for those individuals. Take websites, news or otherwise, devoted to the propagation of articles. Companies such as Yahoo and Medium need customers to keep reading in order to stay in business, and one way to keep customers reading is to feed them articles that they would be more inclined to read. This is where topic modeling comes in. Using a corpus made up of articles previously read by an individual, a topic model would essentially tell us what types of articles said subscriber likes to read. The company could then go to its inventory and find articles with similar topics and send them to the individual via their account page or email. This is custom curation to facilitate simplicity and ease of use while also maintaining engagement.</p>
			<p>Before we get into prepping data for our model, let's quickly load and explore the data.</p>
			<h2 id="_idParaDest-141"><a id="_idTextAnchor144"/>Exercise 7.02: Data Loading</h2>
			<p>In this exercise, we will load the data and format it. We will execute this exercise in the same notebook that we executed in <em class="italic">Exercise 7.01</em>, <em class="italic">Setting up the Environment</em>. It is incredibly important to understand as thoroughly as possible the dataset with which we are going to work. That process of understanding starts with knowing what the data looks like at a high level, how big the data is, what columns are present, and identifying what aspects of the dataset might be helpful in solving the problem we've been tasked with solving. We answer these basic questions below.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">This data is downloaded from <a href="https://archive.ics.uci.edu/ml/datasets/News+Popularity+in+Multiple+Social+Media+Platforms">https://archive.ics.uci.edu/ml/datasets/News+Popularity+in+Multiple+Social+Media+Platforms</a> (UCI Machine Learning Repository [<a href="http://archive.ics.uci.edu/ml">http://archive.ics.uci.edu/ml</a>]. Irvine, CA: University of California, School of Information and Computer Science).</p>
			<p class="callout">Citation: Nuno Moniz and LuÃ­s Torgo. "Multi-Source Social Feedback of Online News Feeds".CoRR [arXiv:1801.07055 [cs.SI]] (2018).</p>
			<p class="callout">The dataset can also be downloaded from <a href="https://packt.live/2Xin2HC">https://packt.live/2Xin2HC</a>.</p>
			<p>This is the only file that is required for this exercise. Once downloaded and saved locally, the data can be loaded into the notebook.</p>
			<ol>
				<li value="1">Define the path to the data and load it using <strong class="source-inline">pandas</strong>:<p class="source-code">path = "News_Final.csv"</p><p class="source-code">df = pandas.read_csv(path, header=0)</p><p class="callout-heading">Note</p><p class="callout">Add the file to the same folder where you have opened your notebook.</p></li>
				<li>Examine the data briefly by executing the following code:<p class="source-code">def dataframe_quick_look(df, nrows):</p><p class="source-code">Â Â Â Â print("SHAPE:\n{shape}\n".format(shape=df.shape))</p><p class="source-code">Â Â Â Â print("COLUMN NAMES:\n{names}\n".format(names=df.columns))</p><p class="source-code">Â Â Â Â print("HEAD:\n{head}\n".format(head=df.head(nrows)))</p><p class="source-code">dataframe_quick_look(df, nrows=2)</p><p>This user-defined function returns the shape of the data (the number of rows and columns), the column names, and the first two rows of the data:</p><div id="_idContainer203" class="IMG---Figure"><img src="image/B15923_07_07.jpg" alt="Figure 7.7: Raw data&#13;&#10;"/></div><p class="figure-caption">Figure 7.7: Raw data</p><p>This is a much larger dataset in terms of features than is needed to run the topicÂ models.</p></li>
				<li>Notice that one of the columns, named <strong class="source-inline">Topic</strong>, actually contains the information that any topic model would try to ascertain. Briefly look at the topic data provided, so that when you finally generate your own topics, the results can be compared directly. Run the following line to print the unique topic values and their number of occurrences:<p class="source-code">print("TOPICS:\n{topics}\n".format(topics=df["Topic"]\</p><p class="source-code">Â Â Â Â Â Â .value_counts()))</p><p>The output is as follows:</p><p class="source-code">TOPICS:</p><p class="source-code">economy      33928</p><p class="source-code">obama        28610</p><p class="source-code">microsoft    21858</p><p class="source-code">palestine     8843</p><p class="source-code">Name: Topic, dtype: int64</p></li>
				<li>Now, extract the headline data and transform the extracted data into a list object. Print the first five elements of the list and the list length to confirm that the extraction was successful:<p class="source-code">raw = df["Headline"].tolist()</p><p class="source-code">print("HEADLINES:\n{lines}\n".format(lines=raw[:5]))</p><p class="source-code">print("LENGTH:\n{length}\n".format(length=len(raw)))</p><p>The output is as follows:</p><div id="_idContainer204" class="IMG---Figure"><img src="image/B15923_07_08.jpg" alt="Figure 7.8: A list of headlines&#13;&#10;"/></div><p> </p></li>
			</ol>
			<p class="figure-caption">Figure 7.8: A list of headlines</p>
			<p>With the data now loaded and correctly formatted, let's talk about textual data cleaning and then jump into some actual cleaning and preprocessing. For instructional purposes, the cleaning process will initially be built and executed on only one headline. Once we have established the process and tested it on the example headline, we will go back and run the process on every headline. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/34gLGKa">https://packt.live/34gLGKa</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/3fbWQES">https://packt.live/3fbWQES</a>.</p>
			<p class="callout">You must execute the entire Notebook in order to get the desired result.</p>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor145"/>Cleaning Text Data</h1>
			<p>A key component of all successful modeling exercises is a clean dataset that has been appropriately and sufficiently preprocessed for the specific data type and analysis being performed. Text data is no exception, as it is virtually unusable in its raw form. It does not matter what algorithm is being run: if the data isn't properly prepared, the results will be at best meaningless and at worst misleading. As the saying goes, <em class="italic">garbage in, garbage out.</em> For topic modeling, the goal of data cleaning is to isolate the words in each document that could be relevant by removing everything that could be obstructive.</p>
			<p>Data cleaning and preprocessing is almost always specific to the dataset, meaning that each dataset will require a unique set of cleaning and preprocessing steps selected to specifically handle the issues in it. With text data, cleaning and preprocessing steps can include language filtering, removing URLs and screen names, lemmatizing, and stop word removal, among others. We will explore these in detail in the upcoming sections and implement these ideas in the forthcoming exercises, where a dataset featuring news headlines will be cleaned for topic modeling.</p>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor146"/>Data Cleaning Techniques</h2>
			<p>To reiterate a previous point, the goal of cleaning text for topic modeling is to isolate the words in each document that could be relevant to finding the abstract topics of the corpus. This means removing common words, short words (generally more common), numbers, and punctuation. No hard and fast process exists for cleaning data, so it is important to understand the typical problem points in the type of data being cleaned and do extensive exploratory work.</p>
			<p>Let's now discuss some of the text data cleaning techniques that we will employ. One of the first things that needs to be done when doing any modeling task involving text is to determine the language(s) of the text. In this dataset, most of the headlines are English, so we will remove the non-English headlines for simplicity. Building models on non-English text data requires additional skill sets, the least of which is fluency in the language being modeled.</p>
			<p>The next crucial step in data cleaning is to remove all elements of the documents that are either not relevant to word-based models or are potential sources of noise that could obscure the results. Elements needing removal could include website addresses, punctuation, numbers, and stop words. <strong class="bold">Stop words</strong> are basically simple, commonly used words (including <em class="italic">we</em>, <em class="italic">are</em>, and <em class="italic">the</em>). It is important to note that there is no definitive dictionary of stop words; instead, every dictionary varies slightly. Despite the differences, each dictionary contains a number of common words that are assumed to be topic agnostic. Topic models try to identify words that are both frequent and infrequent enough to be descriptive of an abstract topic. </p>
			<p>The removal of website addresses has a similar motivation. Specific website addresses will appear very rarely, but even if one specific website address appears enough to be linked to a topic, website addresses are not interpretable in the same way as words. Removing irrelevant information from the documents reduces the amount of noise that could either prevent model convergence or obscure results.</p>
			<p><strong class="bold">Lemmatization</strong>, like language detection, is an important component of all modeling activities involving text. It is the process of reducing words to their base form as a way to group words that should all be the same but are not because of various changes in the tense or the part of speech. Consider the words <em class="italic">running</em>, <em class="italic">runs</em>, and <em class="italic">ran</em>. All three of these words have the base form of <em class="italic">run</em>. A great aspect of lemmatizing is that it looks at all the words in a sentence (in other words, it considers the context), before determining how to alter each word. Lemmatization, like most of the preceding cleaning techniques, simply reduces the amount of noise in the data, so that we can identify clean and interpretable topics. </p>
			<p>Now, with a basic knowledge of textual cleaning techniques, let's apply these techniques to real-world data. </p>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor147"/>Exercise 7.03: Cleaning Data Step by Step</h2>
			<p>In this exercise, we will learn how to implement some key techniques for cleaning text data. Each technique will be explained as we work through the exercise. After every cleaning step, the example headline is output using <strong class="source-inline">print</strong>, so we can watch the evolution from raw data to model-ready data:</p>
			<ol>
				<li value="1">Select the sixth headline as the example on which we will build and test the cleaning process. The sixth headline is not a random choice; it was selected because it contains specific problems that will be addressed during the cleaning process:<p class="source-code">example = raw[5]</p><p class="source-code">print(example)</p><p>The output is as follows:</p><div id="_idContainer205" class="IMG---Figure"><img src="image/B15923_07_09.jpg" alt="Figure 7.9: The sixth headline&#13;&#10;"/></div><p class="figure-caption">Figure 7.9: The sixth headline</p></li>
				<li>Use the <strong class="source-inline">langdetect</strong> library to detect the language of each headline. If the language is anything other than English (<strong class="source-inline">en</strong>), remove that headline from the dataset. The <strong class="source-inline">detect</strong> function simply detects the language of the text that is passed into it. When the function fails to detect a language, which it periodically does, simply set the language to <strong class="source-inline">none</strong> for removal later on: <p class="source-code">def do_language_identifying(txt):</p><p class="source-code">Â Â Â Â try: the_language = langdetect.detect(txt)</p><p class="source-code">Â Â Â Â except: the_language = 'none'</p><p class="source-code">Â Â Â Â return the_language</p><p class="source-code">print("DETECTED LANGUAGE:\n{lang}\n"\</p><p class="source-code">Â Â Â Â Â Â .format(lang=do_language_identifying(example)))</p><p>The output is as follows:</p><p class="source-code">DETECTED LANGUAGE:</p><p class="source-code">en</p></li>
				<li>Split the string containing the headline into pieces, called <strong class="bold">tokens</strong>, using the white spaces. The returned object is a list of words and numbers that make up the headline. Breaking the headline string into tokens makes the cleaning and preprocessing process simpler. There are multiple types of tokenizers available. Note that NLTK itself provides various types of tokenizers. Each of the tokenizers considers different ways to split the sentence into tokens. The simplest one is splitting the text based on white spaces.<p class="source-code">example = example.split(" ")</p><p class="source-code">print(example)</p><p>The output is as follows:</p><div id="_idContainer206" class="IMG---Figure"><img src="image/B15923_07_10.jpg" alt="Figure 7.10: String split using white spaces&#13;&#10;"/></div><p class="figure-caption">Figure 7.10: String split using white spaces</p></li>
				<li>Identify all URLs using a regular expression search for tokens containing <strong class="source-inline">http://</strong> or <strong class="source-inline">https://</strong>. Replace the URLs with the <strong class="source-inline">'URL'</strong> string:<p class="source-code">example = ['URL' if bool(regex.search("http[s]?://", i)) \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â else i for i in example]</p><p class="source-code">print(example)</p><p>The output is as follows:</p><div id="_idContainer207" class="IMG---Figure"><img src="image/B15923_07_11.jpg" alt="Figure 7.11: URLs replaced with the URL string&#13;&#10;"/></div><p class="figure-caption">Figure 7.11: URLs replaced with the URL string</p></li>
				<li>Replace all punctuation and newline symbols (<strong class="source-inline">\n</strong>) with empty strings using regular expressions:<p class="source-code">example = [regex.sub("[^\\w\\s]|\n", "", i) for i in example]</p><p class="source-code">print(example)</p><p>The output is as follows:</p><div id="_idContainer208" class="IMG---Figure"><img src="image/B15923_07_12.jpg" alt="Figure 7.12: Punctuation replaced with empty strings using regular expressions&#13;&#10;"/></div><p class="figure-caption">Figure 7.12: Punctuation replaced with empty strings using regular expressions</p></li>
				<li>Replace all numbers with empty strings using regular expressions:<p class="source-code">example = [regex.sub("^[0-9]*$", "", i) for i in example]</p><p class="source-code">print(example)</p><p>The output is as follows:</p><div id="_idContainer209" class="IMG---Figure"><img src="image/B15923_07_13.jpg" alt="Figure 7.13: Numbers replaced with empty strings&#13;&#10;"/></div><p class="figure-caption">Figure 7.13: Numbers replaced with empty strings</p></li>
				<li>Change all uppercase letters to lowercase. Converting everything to lowercase is not a mandatory step, but it does help reduce complexity. With everything lowercase, there is less to keep track of and therefore less chance of error:<p class="source-code">example = [i.lower() if i not in ["URL"] else i for i in example]</p><p class="source-code">print(example)</p><p>The output is as follows:</p><div id="_idContainer210" class="IMG---Figure"><img src="image/B15923_07_14.jpg" alt="Figure 7.14: Uppercase letters converted to lowercase&#13;&#10;"/></div><p class="figure-caption">Figure 7.14: Uppercase letters converted to lowercase</p></li>
				<li>Remove the <strong class="source-inline">'URL'</strong> string that was added as a placeholder in <em class="italic">Step 4</em>. The previously added <strong class="source-inline">'URL'</strong> string is not actually needed for modeling. If it seems harmless to leave it in, consider that the <strong class="source-inline">'URL'</strong> string could appear naturally in a headline and we do not want to artificially boost its number of appearances. Also, the <strong class="source-inline">'URL'</strong> string does not appear in every headline, so by leaving it in, we could be unintentionally creating a connection between the <strong class="source-inline">'URL'</strong> strings and a topic:<p class="source-code">example = [i for i in example if i not in ["URL",""]]</p><p class="source-code">print(example)</p><p>The output is as follows:</p><div id="_idContainer211" class="IMG---Figure"><img src="image/B15923_07_15.jpg" alt="Figure 7.15: String URL removed&#13;&#10;"/></div><p class="figure-caption">Figure 7.15: String URL removed</p></li>
				<li>Load in the <strong class="source-inline">stopwords</strong> dictionary from <strong class="source-inline">nltk</strong> and print it:<p class="source-code">list_stop_words = nltk.corpus.stopwords.words("english")</p><p class="source-code">list_stop_words = [regex.sub("[^\\w\\s]", "", i) \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â for i in list_stop_words]</p><p class="source-code">print(list_stop_words)</p><p>The output is as follows:</p><div id="_idContainer212" class="IMG---Figure"><img src="image/B15923_07_16.jpg" alt="Figure 7.16: List of stop words&#13;&#10;"/></div><p class="figure-caption">Figure 7.16: List of stop words</p><p>Before using the dictionary, it is important to reformat the words to match the formatting of our headlines. That involves confirming that everything is lowercase and without punctuation.</p></li>
				<li>Now that we have correctly formatted the <strong class="source-inline">stopwords</strong> dictionary, use it to remove all stop words from the headline:<p class="source-code">example = [i for i in example if i not in list_stop_words]</p><p class="source-code">print(example)</p><p>The output is as follows:</p><div id="_idContainer213" class="IMG---Figure"><img src="image/B15923_07_17.jpg" alt="Figure 7.17: Stop words removed from the headline&#13;&#10;"/></div><p class="figure-caption">Figure 7.17: Stop words removed from the headline</p></li>
				<li>Perform lemmatization by defining a function that can be applied to each headline individually. Lemmatizing requires the <strong class="source-inline">wordnet</strong> dictionary to be loaded. The <strong class="source-inline">morphy</strong> function takes each individual word in a text and returns its standard form if it recognizes it. For example, if the word input is <em class="italic">running</em> or <em class="italic">ran</em>, the <strong class="source-inline">morphy</strong> function would return <em class="italic">run</em>:<p class="source-code">def do_lemmatizing(wrd):</p><p class="source-code">Â Â Â Â out = nltk.corpus.wordnet.morphy(wrd)</p><p class="source-code">Â Â Â Â return (wrd if out is None else out)</p><p class="source-code">example = [do_lemmatizing(i) for i in example]</p><p class="source-code">print(example)</p><p>The output is as follows:</p><div id="_idContainer214" class="IMG---Figure"><img src="image/B15923_07_18.jpg" alt="Figure 7.18: Output after performing lemmatization&#13;&#10;"/></div><p class="figure-caption">Figure 7.18: Output after performing lemmatization</p></li>
				<li>Remove all words with a length of four or less from the list of tokens. The assumption around this step is that short words are, in general, more common and therefore will not drive the types of insights we are looking to extract from the topic models. Note that removing words of certain lengths is not a technique that should be used all the time; it is for specific cases only. For example, short words can sometimes be very indicative of topics such as in the case of identifying animals (for example, dog, cat, bird).<p class="source-code">example = [i for i in example if len(i) &gt;= 5]</p><p class="source-code">print(example)</p><p>The output is as follows:</p></li>
			</ol>
			<div>
				<div id="_idContainer215" class="IMG---Figure">
					<img src="image/B15923_07_19.jpg" alt="Figure 7.19: Headline number six post-cleaning&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.19: Headline number six post-cleaning</p>
			<p>Now that we have worked through the cleaning and preprocessing steps individually on one headline, we need to apply those steps to every one of the nearly 100,000 headlines. The most efficient way to do that is to write a function that contains all the steps outlined above and apply that function to every document in the corpus in some iterative fashion. That process is undertaken in the next exercise.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/34gLGKa">https://packt.live/34gLGKa</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/3fbWQES">https://packt.live/3fbWQES</a>.</p>
			<p class="callout">You must execute the entire Notebook in order to get the desired result.</p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor148"/>Exercise 7.04: Complete Data Cleaning</h2>
			<p>In this exercise, we will consolidate <em class="italic">Steps 2</em> to <em class="italic">12</em> from <em class="italic">Exercise 7.03</em>, <em class="italic">Cleaning Data Step by Step</em>, into one function that we can apply to every headline. The function will take one headline in string format as an input and the output will be a cleaned headline as a list of tokens. The topic models require that documents be formatted as strings instead of as lists of tokens, so in <em class="italic">Step 4</em>, the lists of tokens are converted back into strings:</p>
			<ol>
				<li value="1">Define a function that contains all the individual steps of the cleaning process from <em class="italic">Exercise 7.03</em>, <em class="italic">Cleaning Data Step by step</em>:<p class="source-code-heading">Exercise7.01-Exercise7.12.ipynb</p><p class="source-code">def do_headline_cleaning(txt):</p><p class="source-code">Â Â Â Â Â Â # identify language of tweet</p><p class="source-code">Â Â Â Â Â Â # return null if language not English</p><p class="source-code">Â Â Â Â lg = do_language_identifying(txt)</p><p class="source-code">Â Â Â Â if lg != 'en': </p><p class="source-code">Â Â Â Â Â Â Â Â return None</p><p class="source-code">Â Â Â Â Â Â # split the string on whitespace</p><p class="source-code">Â Â Â Â out = txt.split(" ")</p><p class="source-code">Â Â Â Â Â Â # identify urls</p><p class="source-code">Â Â Â Â Â Â # replace with URL</p><p class="source-code">Â Â Â Â out = ['URL' if bool(regex.search("http[s]?://", i)) \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â else i for i in out]</p><p class="source-code">Â Â Â Â Â Â # remove all punctuation</p><p class="source-code">Â Â Â Â out = [regex.sub("[^\\w\\s]|\n", "", i) for i in out]</p><p class="source-code">Â Â Â Â Â Â # remove all numerics</p><p class="source-code">Â Â Â Â out = [regex.sub("^[0-9]*$", "", i) for i in out]</p><p class="source-code-link">The complete code for this step can be found at <a href="https://packt.live/34gLGKa">https://packt.live/34gLGKa</a>.</p></li>
				<li>Execute the function on each headline. The <strong class="source-inline">map</strong> function in Python is a nice way to apply a user-defined function to each element of a list. Convert the <strong class="source-inline">map</strong> object to a list and assign it to the <strong class="source-inline">clean</strong> variable. The <strong class="source-inline">clean</strong> variable is a list of lists:<p class="source-code">tick = time()</p><p class="source-code">clean = list(map(do_headline_cleaning, raw))</p><p class="source-code">print(time()-tick)</p></li>
				<li>In <strong class="source-inline">do_headline_cleaning</strong>, <strong class="source-inline">None</strong> is returned if the language of the headline is detected as being any language other than English. The elements of the final cleaned list should only be lists, not <strong class="source-inline">None</strong>, so remove all <strong class="source-inline">None</strong> types. Use <strong class="source-inline">print</strong> to display the first five cleaned headlines and the length of the <strong class="source-inline">clean</strong> variable:<p class="source-code">clean = list(filter(None.__ne__, clean))</p><p class="source-code">print("HEADLINES:\n{lines}\n".format(lines=clean[:5]))</p><p class="source-code">print("LENGTH:\n{length}\n".format(length=len(clean)))</p><p>The output is as follows:</p><div id="_idContainer216" class="IMG---Figure"><img src="image/B15923_07_20.jpg" alt="Figure 7.20: Example headlines and the length of the headline list&#13;&#10;"/></div><p class="figure-caption">Figure 7.20: Example headlines and the length of the headline list</p></li>
				<li>For every individual headline, concatenate the tokens using a white space separator. The headlines should now be an unstructured collection of words, nonsensical to the human reader, but ideal for topic modeling:<p class="source-code">clean_sentences = [" ".join(i) for i in clean]</p><p class="source-code">print(clean_sentences[0:10])</p><p>The cleaned headlines should resemble the following:</p><div id="_idContainer217" class="IMG---Figure"><img src="image/B15923_07_21.jpg" alt="Figure 7.21: Headlines cleaned for modeling&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 7.21: Headlines cleaned for modeling</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/34gLGKa">https://packt.live/34gLGKa</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/3fbWQES">https://packt.live/3fbWQES</a>.</p>
			<p class="callout">You must execute the entire Notebook in order to get the desired result.</p>
			<p>To recap, what the cleaning and preprocessing work effectively does is strip out the noise from the data so that the model can hone in on elements of the data that could actually drive insights. For example, words that are agnostic to any topic should not be informing topics, but by accident alone, if left in, could be. </p>
			<p>In an effort to avoid what we could call <em class="italic">fake signal</em>, we remove those words. Likewise, since topic models cannot discern context, punctuation is irrelevant and is therefore removed. Even if the model could find the topics without removing the noise from the data, the uncleaned data could have thousands to millions of extra words and random characters to parse (depending on the number of documents in the corpus), which could significantly increase the computational demands. So, data cleaning is an integral part of topic modeling. You will practice this in the following activity. </p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor149"/>Activity 7.01: Loading and Cleaning Twitter Data</h2>
			<p>In this activity, we will load and clean Twitter data for modeling to be done in subsequent activities. Our usage of the headline data is ongoing, so let's complete this activity in a separate Jupyter notebook, but with all the same requirements and imported libraries.</p>
			<p>The goal is to take the raw tweet data, clean it, and produce the same output that we did in <em class="italic">Step 4</em> of the previous exercise. The output should be a list whose length is similar to the number of rows in the raw data file, but potentially not equal to it. This is because tweets can get dropped in the cleaning process for many reasons, such as the tweet being written in a language other than English. Each element of the list should represent one tweet and should contain just the words in the tweet that might be relevant to topic formation.</p>
			<p>Here are the steps to complete the activity:</p>
			<ol>
				<li value="1">Import the necessary libraries.</li>
				<li>Load the LA Times health Twitter data (<strong class="source-inline">latimeshealth.txt</strong>) from <a href="https://packt.live/2Xje5xF">https://packt.live/2Xje5xF</a>.<p class="callout-heading">Note</p><p class="callout">This dataset is sourced from <a href="https://archive.ics.uci.edu/ml/datasets/Health+News+in+Twitter">https://archive.ics.uci.edu/ml/datasets/Health+News+in+Twitter</a> (UCI Machine Learning Repository [<a href="http://archive.ics.uci.edu/ml">http://archive.ics.uci.edu/ml</a>]. Irvine, CA: University of California, School of Information and Computer Science).</p><p class="callout">Citation: Karami, A., Gangopadhyay, A., Zhou, B., &amp; Kharrazi, H. (2017). Fuzzy approach topic discovery in health and medical corpora. International Journal of Fuzzy Systems, 1-12.</p><p class="callout">It is also available on GitHub at <a href="https://packt.live/2Xje5xF">https://packt.live/2Xje5xF</a>.</p></li>
				<li>Run a quick exploratory analysis to ascertain data size and structure.</li>
				<li>Extract the tweet text and convert it to a list object.</li>
				<li>Write a function to perform language detection and tokenization on white spaces, and then replace the screen names and URLs with <strong class="source-inline">SCREENNAME</strong> and <strong class="source-inline">URL</strong>, respectively. The function should also remove punctuation, numbers, and the <strong class="source-inline">SCREENNAME</strong> and <strong class="source-inline">URL</strong> replacements. Convert everything to lowercase, except <strong class="source-inline">SCREENNAME</strong> and <strong class="source-inline">URL</strong>. It should remove all stop words, perform lemmatization, and keep words with five or more letters only.</li>
				<li>Apply the function defined in <em class="italic">Step 5</em> to every tweet.</li>
				<li>Remove elements of the output list equal to <strong class="source-inline">None</strong>.</li>
				<li>Turn the elements of each tweet back into a string. Concatenate using white space.</li>
				<li>Keep the notebook open for future activities.<p class="callout-heading">Note</p><p class="callout">All the activities in this chapter need to be performed in the same notebook.</p><p>The output will be as follows: </p><div id="_idContainer218" class="IMG---Figure"><img src="image/B15923_07_22.jpg" alt="Figure 7.22: Tweets cleaned for modeling&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 7.22: Tweets cleaned for modeling</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found on page 478.</p>
			<h1 id="_idParaDest-147"><a id="_idTextAnchor150"/>Latent Dirichlet Allocation</h1>
			<p>In 2003, David Blei, Andrew Ng, and Michael Jordan published their article on the topic modeling algorithm known as <strong class="bold">Latent Dirichlet Allocation</strong> (<strong class="bold">LDA</strong>). LDA is a generative probabilistic model. This means that the modeling process starts with the text and works backward through the process that is assumed to have generated it in order to identify the parameters of interest. In this case, it is the topics that generated the data that are of interest. The process discussed here is the most basic form of LDA, but for learning, it is also the most comprehensible.</p>
			<p>There are M documents available for topic modeling within the corpus. Each document can be considered as the sequence of <em class="italic">N</em> words, i.e., a sequence (<em class="italic">w</em><span class="subscript">1</span>,<em class="italic">w</em><span class="subscript">2</span>â€¦ <em class="italic">w</em><span class="subscript">N</span>).</p>
			<p>For each document in the corpus, the assumed generative process is:</p>
			<ol>
				<li value="1">Select <img src="image/B15923_07_Formula_01.png" alt="A picture containing tableware&#10;&#10;Description automatically generated"/>, where <em class="italic">N</em> is the number of words and Î» is the parameter controlling the Poisson distribution.</li>
				<li>Select <img src="image/B15923_07_Formula_02.png" alt="A drawing of a face&#10;&#10;Description automatically generated"/>, where <img src="image/B15923_07_Formula_03.png" alt=" distribution o"/> is the distribution of topics.</li>
				<li>For each <em class="italic">N</em> words, <em class="italic">W</em><span class="subscript">n</span>, select topic <img src="image/B15923_07_Formula_04.png" alt="A drawing of a face&#10;&#10;Description automatically generated"/>, and select word <em class="italic">W</em><span class="subscript">n</span> from <img src="image/B15923_07_Formula_05.png" alt="A picture containing clipart&#10;&#10;Description automatically generated"/>.</li>
			</ol>
			<p>Let's go through the generative process in a bit more detail. The preceding three steps repeat for every document in the corpus. The initial step is to choose the number of words in the document by sampling from, in most cases, the <em class="italic">Poisson</em> distribution. It is important to note that, because N is independent of the other variables, the randomness associated with its generation is mostly ignored in the derivation of the algorithm.</p>
			<p>Coming after the selection of <em class="italic">N</em> is the generation of the topic mixture or distribution of topics, unique to each document. Think of this as a per-document list of topics with probabilities representing the amount of the document represented by each topic. Consider three topics: A, B, and C. An example document could be 100% topic A, 75% topic B and 25% topic C, or an infinite number of other combinations.</p>
			<p>Lastly, the specific words in the document are selected via a probability statement conditioned on the selected topic and the distribution of words for that topic. Note that documents are not really generated in this way, but it is a reasonable proxy.</p>
			<p>This process can be thought of as a distribution over distributions. A document is selected from the collection (distribution) of documents, and one topic is selected (via the multinomial distribution) from the probability distribution of topics for that document, generated by the Dirichlet distribution.</p>
			<div>
				<div id="_idContainer224" class="IMG---Figure">
					<img src="image/B15923_07_23.jpg" alt="Figure 7.23: Graphical representation of LDA&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.23: Graphical representation of LDA</p>
			<p>The most straightforward way to build the formula representing the LDA solution is through a graphical representation. This particular representation is referred to as a plate notation graphical model, as it uses plates to represent the two iterative steps in the process. </p>
			<p>You will recall that the generative process was executed for every document in the corpus, so the outermost plate (labeled <em class="italic">M</em>) represents iterating over each document. Similarly, the iteration over words in <em class="italic">Step 3</em> is represented by the innermost plate of the diagram, labeled <em class="italic">N</em>. </p>
			<p>The circles represent the parameters, distributions, and results. The shaded circle, labeled <em class="italic">w</em>, is the selected word, which is the only known piece of data and, as such, is used to reverse-engineer the generative process. Besides <em class="italic">w</em>, the other four variables in the diagram are defined as follows:</p>
			<ul>
				<li><img src="image/B15923_07_Formula_06.png" alt="A picture containing scissors, tool&#13;&#10;&#13;&#10;Description automatically generated"/>: Hyperparameter for the topic-document Dirichlet distribution.</li>
				<li><img src="image/B15923_07_Formula_07.png" alt="A picture containing furniture&#13;&#10;&#13;&#10;Description automatically generated"/>: Distribution of words for each topic.</li>
				<li><img src="image/B15923_07_Formula_08.png" alt="Description automatically generated"/>: This is the latent variable for the topic.</li>
				<li><img src="image/B15923_07_Formula_09.png" alt=" This is the latent variable for the "/>: This is the latent variable for the distribution of topics for each document.</li>
			</ul>
			<p><img src="image/B15923_07_Formula_10.png" alt="A picture containing scissors, tool&#10;&#10;Description automatically generated"/> and <img src="image/B15923_07_Formula_11.png" alt="A picture containing furniture&#10;&#10;Description automatically generated"/> control the frequency of topics in documents and the frequency of words in topics. If <img src="image/B15923_07_Formula_12.png" alt="A picture containing scissors, tool&#10;&#10;Description automatically generated"/> increases, the documents become increasingly similar as the number of topics in each document increases. On the other hand, if <img src="image/B15923_07_Formula_13.png" alt="A picture containing scissors, tool&#10;&#10;Description automatically generated"/> decreases, the documents become increasingly dissimilar as the number of topics in each document decreases. The <img src="image/B15923_07_Formula_14.png" alt="A picture containing furniture&#10;&#10;Description automatically generated"/> parameter behaves similarly. If <img src="image/B15923_07_Formula_15.png" alt="A picture containing furniture&#10;&#10;Description automatically generated"/> increases, more words from the document are used to model a topic while a lower <img src="image/B15923_07_Formula_16.png" alt="A picture containing furniture&#10;&#10;Description automatically generated"/> causes a smaller number of words to be used for a topic. Given the complexity of the distributions in LDA, there is no direct solution, so some sort of approximation algorithm is required to generate the results. The standard approximation algorithm for LDA is discussed in the nextÂ section.</p>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor151"/>Variational Inference</h2>
			<p>The big issue with LDA is that the evaluation of the conditional probabilities (the distributions) is unmanageable, so instead of computing them directly, the probabilities are approximated. Variational inference is one of the simpler approximation algorithms, but it has an extensive derivation that requires significant knowledge of probability. In order to spend more time on the application of LDA, this section will give some high-level details on how variational inference is applied in this context but will not fully explore the algorithm.</p>
			<p>Let's take a moment to work through the variational inference algorithm intuitively. Start by randomly assigning each word in each document in the corpus to one of the topics. Then, for each document and each word in each document separately, calculate two proportions. Those proportions would be the proportion of words in the document that are currently assigned to the topic, <em class="italic">P(Topic|Document)</em> and the proportion of assignments across all documents of a specific word to the topic, <em class="italic">P(Word|Topic)</em>. Multiply the two proportions and use the resulting proportion to assign the word to a new topic. Repeat this process until a steady state is reached where topic assignments are not changing significantly. These assignments are then used to estimate the within-document topic mixture and the within-topic word mixture.</p>
			<div>
				<div id="_idContainer236" class="IMG---Figure">
					<img src="image/B15923_07_24.jpg" alt="Figure 7.24: The variational inference process&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.24: The variational inference process</p>
			<p>The thought process behind variational inference is that, if the actual distribution is intractable, then a simpler distribution, let's call it the variational distribution, very close to true distribution, which is tractable, should be found so that inference becomes possible. In other words, since inferring the actual distribution is impossible due to the complexity of the actual distribution, we try instead to find a simpler distribution that is an excellent approximation of the actual distribution.</p>
			<p>Let's take a momentary break from the theory for an example. Variational inference is like trying to view animals at a crowded zoo. The animals at the zoo are in an enclosed habitat, which, in this example, is the posterior distribution. Visitors cannot actually get into the habitat, so the visitors have to settle for viewing the habitat from the closest possible position, which is the posterior approximation (i.e. the best approximation of the habitat). If there are a lot of people at the zoo, it can be difficult to get to that optimal vantage point. People generally start at the back of the crowd and strategically move their way toward that optimal vantage point. The path the visitors follow to move from the back of the crowd to the optimal vantage point is the optimization path. Variational inference is simply the process of getting as close to the desired point as possible knowing that the desired point cannot actually be reached.</p>
			<p>To start, select a family of distributions (i.e. binomial, gaussian, exponential, and so on), <em class="italic">q</em>, conditioned on new variational parameters. The parameters are optimized so that the original distribution, which is actually the posterior distribution for those people familiar with Bayesian statistics, and the variational distribution are as close as possible. The variational distribution will be close enough to the original posterior distribution to be used as a proxy, making any inference done on it applicable to the original posterior distribution. The generic formula for the family of distributions, <em class="italic">q</em>, is as follows:</p>
			<div>
				<div id="_idContainer237" class="IMG---Figure">
					<img src="image/B15923_07_25.jpg" alt="Figure 7.25: Formula for the family of distributions, q&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.25: Formula for the family of distributions, q</p>
			<p>There is a large collection of potential variational distributions that can be used as an approximation for the posterior distribution. An initial variational distribution is selected from the collection, which acts as the starting point for an optimization process that iteratively moves closer and closer to the optimal distribution. The optimal parameters are the parameters of the distribution that best approximate the posterior. The similarity of the two distributions is measured using <strong class="bold">Kullback-Leibler</strong> (<strong class="bold">KL</strong>) divergence. KL divergence represents the expected amount of error generated if we approximate one distribution with another. The distribution with optimal parameters will have the smallest KL divergence when measured against the true distribution.</p>
			<p>Once the optimal distribution has been identified, which means the optimal parameters have been identified, it can be leveraged to produce the output matrices and execute any required inference.</p>
			<h2 id="_idParaDest-149"><a id="_idTextAnchor152"/>Bag of Words</h2>
			<p>Text cannot be passed directly into any machine learning algorithm; it first needs to be encoded numerically. A straightforward way of working with text in machine learning is via a bag-of-words model, which removes all information regarding the order of the words and focuses strictly on the degree of presence (meaning the count or frequency) of each word.</p>
			<p>The Python <strong class="source-inline">sklearn</strong> library can be leveraged to transform the cleaned vector created in the previous exercise into the structure that the LDA model requires. Since LDA is a probabilistic model, we do not want to do any scaling or weighting of the word occurrences; instead, we opt to input just the raw counts.</p>
			<p>The input to the bag-of-words model will be the list of cleaned strings that were returned from <em class="italic">Exercise 7.04</em>, <em class="italic">Complete Data Cleaning</em>. The output will be the document number, the word as its numeric encoding, and a count of the number of times that word appears in that document. These three items will be presented as a tuple and an integer. </p>
			<p>The tuple will be something like (0, 325), where 0 is the document number and 325 is the numerically encoded word. Note that 325 will be the encoding of that word across all documents. The integer would then be the count. The bag-of-words models we will be running in this chapter are from <strong class="source-inline">sklearn</strong> and are called <strong class="source-inline">CountVectorizer</strong> and <strong class="source-inline">TfIdfVectorizer</strong>. The first model returns the raw counts and the second returns a scaled value, which we will discuss a bit later.</p>
			<p>A critical note is that the results of both topic models being covered in this chapter can vary from run to run, even when the data is the same, because of randomness. Neither the probabilities in LDA nor the optimization algorithms are deterministic, so do not be surprised if your results differ slightly from the results shown from here on out. In the next exercise, we will run the count vectorizer to numerically encode our documents, so that we can continue on to topic modeling using LDA.</p>
			<h2 id="_idParaDest-150"><a id="_idTextAnchor153"/>Exercise 7.05: Creating a Bag-of-Words Model Using the Count Vectorizer</h2>
			<p>In this exercise, we will run the <strong class="source-inline">CountVectorizer</strong> in <strong class="source-inline">sklearn</strong> to convert our previously created cleaned vector of headlines into a bag-of-words data structure. In addition, we will define some variables that will be used throughout the modeling process:</p>
			<ol>
				<li value="1">Define <strong class="source-inline">number_words</strong>, <strong class="source-inline">number_docs</strong>, and <strong class="source-inline">number_features</strong>. The first two variables control the visualization of the LDA results. The <strong class="source-inline">number_features</strong> variable controls the number of words that will be kept in the feature space:<p class="source-code">number_words = 10</p><p class="source-code">number_docs = 10</p><p class="source-code">number_features = 1000</p></li>
				<li>Run the count vectorizer and print the output. There are three crucial inputs, which are <strong class="source-inline">max_df</strong>, <strong class="source-inline">min_df</strong>, and <strong class="source-inline">max_features</strong>. These parameters further filter the number of words in the corpus down to those that will most likely influence the model.<p>Words that only appear in a small number of documents are too rare to be attributable to any topic, so <strong class="source-inline">min_df</strong> is used to throw away words that appear in fewer than the specified number of documents. Words that appear in too many documents are not specific enough to be linked to specific topics, so <strong class="source-inline">max_df</strong> is used to throw away words that appear in more than the specified percentage of documents.</p><p>Lastly, we do not want to overfit the model, so the number of words used to fit the model is limited to the most frequently occurring specified number (<strong class="source-inline">max_features</strong>) of words:</p><p class="source-code">vectorizer1 = sklearn.feature_extraction.text\</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â .CountVectorizer(analyzer="word",\</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â max_df=0.5,\</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â min_df=20,\</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â max_features=number_features)</p><p class="source-code">clean_vec1 = vectorizer1.fit_transform(clean_sentences)</p><p class="source-code">print(clean_vec1[0])</p><p>The output is as follows:</p><div id="_idContainer238" class="IMG---Figure"><img src="image/B15923_07_26.jpg" alt="Figure 7.26: The bag-of-words data structure&#13;&#10;"/></div><p class="figure-caption">Figure 7.26: The bag-of-words data structure</p></li>
				<li>Extract the feature names and the words from the vectorizer. The model is only fed the numerical encodings of the words, so having the feature names vector merge with the results will make interpretation easier:<p class="source-code">feature_names_vec1 = vectorizer1.get_feature_names()</p></li>
			</ol>
			<p>This exercise involved the enumeration of the documents for use in the LDA model. The required format is a bag of words. That is, a bag-of-words model is simply a listing of all the words that appear in each document with a count of the number of times each word appears in each specific document. Having accomplished this task using <strong class="source-inline">sklearn</strong>, it is time to explore the process of evaluating LDA models.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/34gLGKa">https://packt.live/34gLGKa</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/3fbWQES">https://packt.live/3fbWQES</a>.</p>
			<p class="callout">You must execute the entire Notebook in order to get the desired result.</p>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor154"/>Perplexity</h2>
			<p>Models generally have metrics that can be leveraged to evaluate their performance. Topic models are no different, although performance, in this case, has a slightly different definition. In regression and classification, predicted values can be compared to actual values from which clear measures of performance can be calculated.</p>
			<p>With topic models, prediction is less reliable, because the model only knows the words it was trained on and new documents may not contain any of those words, despite featuring the same topics. Due to that difference, topic models are evaluated using a metric specific to language models, called <strong class="bold">perplexity</strong>. </p>
			<p>Perplexity, abbreviated to PP, measures the number of different equally most probable words that can follow any given word on average. Let's consider two words as an example: <em class="italic">the</em> and <em class="italic">announce</em>. The word <em class="italic">the</em> can preface an enormous number of equally most probable words, while the number of equally most probable words that can follow the word <em class="italic">announce</em> is significantly lessâ€”albeit still a large number. </p>
			<p>The idea is that words that, on average, can be followed by a smaller number of equally most probable words are more specific and can be more tightly tied to topics. As such, lower perplexity scores imply better language models. Perplexity is very similar to entropy, but perplexity is typically used because it is easier to interpret. As we will see momentarily, it can be used to select the optimal number of topics. With <em class="italic">m</em> being the number of words in the sequence of words, perplexity is defined as:</p>
			<div>
				<div id="_idContainer239" class="IMG---Figure">
					<img src="image/B15923_07_27.jpg" alt="Figure 7.27: Formula of perplexity&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.27: Formula of perplexity</p>
			<p>In this formula, <em class="italic">w</em><span class="subscript">1</span><em class="italic">, â€¦, w</em><span class="subscript">m</span> are the words making up some document in the test dataset. The joint probability of those words, <em class="italic">P(w</em><span class="subscript">1</span><em class="italic">, â€¦, w</em><span class="subscript">m</span><em class="italic">)</em>, is a measure of how well the test document fits in the existing model. Higher probabilities suggest stronger models. The probability is raised to the <em class="italic">-1/m</em> power to normalize the score by the number of words in each document and to make lower values more optimal. Both these changes increase the interpretability of the score. The perplexity score, like root mean squared error, is not very meaningful as a standalone metric. It tends to be used as a comparison metric. That is, several models are built for which perplexity scores are calculated and compared to identify the best model with which to move forward. </p>
			<p>As stated previously, LDA has two required inputs. The first is the documents themselves, and the second is the number of topics. Selecting an appropriate number of topics can be very tricky. One approach to finding the optimal number of topics is to search over several numbers of topics and select the number of topics that corresponds to the smallest perplexity score. In machine learning, this approach is referred to as grid search. In the next exercise, we will put grid search to work to find the optimal number of topics.</p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor155"/>Exercise 7.06: Selecting the Number of Topics</h2>
			<p>In this exercise, we use the perplexity scores for LDA models fit on varying numbers of topics to determine the number of topics with which to move forward. Keep in mind that the original dataset had the headlines sorted into four topics. Let's see whether this approach returns four topics:</p>
			<ol>
				<li value="1">Define a function that fits an LDA model on various numbers of topics and computes the perplexity score. Return two items: a DataFrame that has the number of topics with its perplexity score and the number of topics with the minimum perplexity score as an integer:<p class="source-code">def perplexity_by_ntopic(data, ntopics):</p><p class="source-code">Â Â Â Â output_dict = {"Number Of Topics": [], \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â "Perplexity Score": []}</p><p class="source-code">Â Â Â Â for t in ntopics:</p><p class="source-code">Â Â Â Â Â Â Â Â lda = sklearn.decomposition.LatentDirichletAllocation(\</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â n_components=t, \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â learning_method="online", \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â random_state=0)</p><p class="source-code">Â Â Â Â Â Â Â Â lda.fit(data)</p><p class="source-code">Â Â Â Â Â Â Â Â output_dict["Number Of Topics"].append(t)</p><p class="source-code">Â Â Â Â Â Â Â Â output_dict["Perplexity Score"]\</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â .append(lda.perplexity(data))</p><p class="source-code">Â Â Â Â Â Â Â Â output_df = pandas.DataFrame(output_dict)</p><p class="source-code">Â Â Â Â Â Â Â Â index_min_perplexity = output_df["Perplexity Score"]\</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â .idxmin()</p><p class="source-code">Â Â Â Â Â Â Â Â output_num_topics = output_df.loc[\</p><p class="source-code">Â Â Â Â Â Â Â Â index_min_perplexity,  # index \</p><p class="source-code">Â Â Â Â Â Â Â Â "Number Of Topics"  # column</p><p class="source-code">Â Â Â Â Â Â Â Â ]</p><p class="source-code">Â Â Â Â return (output_df, output_num_topics)</p></li>
				<li>Execute the function defined in <em class="italic">Step 1</em>. The <strong class="source-inline">ntopics</strong> input is a list of numbers of topics that can be of any length and contain any values. Print out the DataFrame:<p class="source-code">df_perplexity, optimal_num_topics = \</p><p class="source-code">perplexity_by_ntopic(clean_vec1, ntopics=[1, 2, 3, 4, 6, 8, 10])</p><p class="source-code">print(df_perplexity)</p><p>The output is as follows:</p><div id="_idContainer240" class="IMG---Figure"><img src="image/B15923_07_28.jpg" alt="Figure 7.28: DataFrame containing the number of topics and perplexity score&#13;&#10;"/></div><p class="figure-caption">Figure 7.28: DataFrame containing the number of topics and perplexity score</p></li>
				<li>Plot the perplexity scores as a function of the number of topics. This is just another way to view the results contained in the DataFrame from <em class="italic">Step 2</em>:<p class="source-code">df_perplexity.plot.line("Number Of Topics", "Perplexity Score")</p><p>The plot appears as follows:</p><div id="_idContainer241" class="IMG---Figure"><img src="image/B15923_07_29.jpg" alt="Figure 7.29: Line plot view of perplexity as a function of the number of topics&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 7.29: Line plot view of perplexity as a function of the number of topics</p>
			<p>As the DataFrame and plot show, the optimal number of topics using perplexity is three. Having the number of topics set to four yielded the second-lowest perplexity. Thus, while the results did not exactly match the information contained in the original dataset, the results are close enough to engender confidence in the grid search approach to identify the optimal number of topics. There could be several reasons that the grid search returned three instead of four, which we will dig into in an upcoming exercise.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/34gLGKa">https://packt.live/34gLGKa</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/3fbWQES">https://packt.live/3fbWQES</a>.</p>
			<p class="callout">You must execute the entire Notebook in order to get the desired result.</p>
			<p>Now that we've selected the optimal number of topics, we will use that number of topics to build our official LDA model. That model will then be used to create visualizations and define the list of topics present in the corpus.</p>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor156"/>Exercise 7.07: Running LDA</h2>
			<p>In this exercise, we'll implement LDA and examine the results. LDA outputs two matrices. The first is the topic-document matrix and the second is the word-topic matrix. We will look at these matrices as returned from the model and as nicely formatted tables that are easier to digest:</p>
			<ol>
				<li value="1">Fit an LDA model using the optimal number of topics found in <em class="italic">Exercise 7.06</em>, <em class="italic">Selecting the Number of Topics</em>:<p class="source-code">lda = sklearn.decomposition.LatentDirichletAllocation\</p><p class="source-code">Â Â Â Â Â Â (n_components=optimal_num_topics,\</p><p class="source-code">Â Â Â Â Â Â Â learning_method="online",\</p><p class="source-code">Â Â Â Â Â Â Â random_state=0)</p><p class="source-code">lda.fit(clean_vec1)</p><p>The output is as follows:</p><div id="_idContainer242" class="IMG---Figure"><img src="image/B15923_07_30.jpg" alt="Figure 7.30: The LDA model&#13;&#10;"/></div><p class="figure-caption">Figure 7.30: The LDA model</p></li>
				<li>Output the topic-document matrix and its shape to confirm that it aligns with the number of topics and the number of documents. Each row of the matrix is the per-document distribution of topics:<p class="source-code">lda_transform = lda.transform(clean_vec1)</p><p class="source-code">print(lda_transform.shape)</p><p class="source-code">print(lda_transform)</p><p>The output is as follows:</p><p class="source-code">(92946, 3)</p><p class="source-code">[[0.04761958 0.90419577 0.04818465]</p><p class="source-code"> [0.04258906 0.04751535 0.90989559]</p><p class="source-code"> [0.16656181 0.04309434 0.79034385]</p><p class="source-code"> ...</p><p class="source-code"> [0.0399815  0.51492894 0.44508955]</p><p class="source-code"> [0.06918206 0.86099065 0.06982729]</p><p class="source-code"> [0.48210053 0.30502833 0.21287114]]</p></li>
				<li>Output the word-topic matrix and its shape to confirm that it aligns with the number of features (words) specified in <em class="italic">Exercise 7.05</em>, <em class="italic">Creating a Bag-of-Words Model Using the Count Vectorizer</em>, and the number of topics input. Each row is basically the prevalence of assignments to that topic of each word. The prevalence score can be transformed into the per-topic distribution of words:<p class="source-code">lda_components = lda.components_</p><p class="source-code">print(lda_components.shape)</p><p class="source-code">print(lda_components)</p><p>The output is as follows:</p><p class="source-code">(3, 1000)</p><p class="source-code">[[3.35570079e-01 1.98879573e+02 9.82489014e+00 ... 3.35388004e-01</p><p class="source-code">Â Â 2.04173562e+02 4.03130268e-01]</p><p class="source-code">Â [2.74824227e+02 3.94662558e-01 3.63412044e-01 ... 3.45944379e-01</p><p class="source-code">Â Â 1.77517291e+02 4.61625408e+02]</p><p class="source-code">Â [3.37041234e-01 7.36749100e+01 2.05707096e+02 ... 2.31714093e+02</p><p class="source-code">Â Â 1.21765267e+02 7.71397922e-01]]</p></li>
				<li>Define a function that formats the two output matrices into easy-to-read tables:<p class="source-code-heading">Exercise7.01-Exercise7.12.ipynb</p><p class="source-code">def get_topics(mod, vec, names, docs, ndocs, nwords):</p><p class="source-code">Â Â Â Â # word to topic matrix</p><p class="source-code">Â Â Â Â W = mod.components_</p><p class="source-code">Â Â Â Â W_norm = W / W.sum(axis=1)[:, numpy.newaxis]</p><p class="source-code">Â Â Â Â # topic to document matrix</p><p class="source-code">Â Â Â Â H = mod.transform(vec)</p><p class="source-code">Â Â Â Â W_dict = {}</p><p class="source-code">Â Â Â Â H_dict = {}</p><p class="source-code-link">The complete code for this step can be found at <a href="https://packt.live/34gLGKa">https://packt.live/34gLGKa</a>.</p><p>The function may be tricky to navigate, so let's walk through it. Start by creating the <em class="italic">W </em>and <em class="italic">H</em> matrices, which includes converting the assignment counts of <em class="italic">W</em> into the per-topic distribution of words. Then, iterate over the topics. Inside each iteration, identify the top words and documents associated with each topic. Convert the results into two DataFrames.</p></li>
				<li>Execute the function defined in <em class="italic">Step 4</em>:<p class="source-code">W_df, H_df = get_topics(mod=lda, \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â vec=clean_vec1, \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â names=feature_names_vec1, \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â docs=raw, \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ndocs=number_docs, \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â nwords=number_words)</p></li>
				<li>Print out the word-topic DataFrame. It shows the top 10 words (by distribution value) that are associated with each topic. From this DataFrame, we can identify the abstract topics that the word groupings represent. More on abstract topics will follow:<p class="source-code">print(W_df)</p><p>The output is as follows:</p><div id="_idContainer243" class="IMG---Figure"><img src="image/B15923_07_31.jpg" alt="Figure 7.31: Word-topic table&#13;&#10;"/></div><p class="figure-caption">Figure 7.31: Word-topic table</p></li>
				<li>Print out the topic-document DataFrame. This shows the 10 documents to which each topic is most closely related. The values are from the per-document distribution of topics:<p class="source-code">print(H_df)</p><p>The output is as follows:</p><div id="_idContainer244" class="IMG---Figure"><img src="image/B15923_07_32.jpg" alt="Figure 7.32: Topic-document table&#13;&#10;"/></div><p> </p></li>
			</ol>
			<p class="figure-caption">Figure 7.32: Topic-document table</p>
			<p>The results of the word-topic DataFrame show that the abstract topics are Barack Obama, the economy, and Microsoft. What is interesting is that the word grouping describing the economy contains references to Palestine. All four topics specified in the original dataset are represented in the word-topic DataFrame output, but not in the fully distinct manner expected. We could be facing one of two problems. </p>
			<p>First, the topic referencing both the economy and Palestine could be under-cooked, which means increasing the number of topics may fix the issue. The other potential problem is that LDA does not handle correlated topics well. In <em class="italic">Exercise 7.09</em>, <em class="italic">Trying Four Topics</em>, we will try expanding the number of topics, which will give us a better idea of why one of the word groupings is seemingly a mixture of topics.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/34gLGKa">https://packt.live/34gLGKa</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/3fbWQES">https://packt.live/3fbWQES</a>.</p>
			<p class="callout">You must execute the entire Notebook in order to get the desired result.</p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor157"/>Visualization</h2>
			<p>The output of LDA models in Python using <strong class="source-inline">sklearn</strong> can be difficult to interpret in raw form. As is the case in most modeling exercises, visualizations can be a great benefit when it comes to interpreting and communicating model results. One Python library, <strong class="source-inline">pyLDAvis</strong>, integrates directly with the <strong class="source-inline">sklearn</strong> model object to produce straightforward graphics. This visualization tool returns a histogram showing the words that are the most closely related to each topic and a biplot, frequently used in PCA, where each circle corresponds to a topic. From the biplot, we know how prevalent each topic is across the entire corpus, which is reflected by the area of the circle, and the similarity of the topics, which is reflected by the closeness of the circles. </p>
			<p>The ideal scenario is to have the circles spread throughout the plot and be of reasonable and consistent size. That is, we want the topics to be distinct and to appear uniformly across the corpus. In addition to the <strong class="source-inline">pyLDAvis</strong> graphics, we will leverage the t-SNE model, discussed in a prior chapter, to produce a two-dimensional representation of the topic-document matrix, a matrix where each row represents one document and each column represents the probability of that topic describing the document.</p>
			<p>Having completed the LDA model fitting, let's create some graphics to help us dig into the results.</p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor158"/>Exercise 7.08: Visualizing LDA</h2>
			<p>Visualization is a helpful tool for exploring the results of topic models. In this exercise, we will look at three different visualizations. Those visualizations are basic histograms and specialty visualizations using t-SNE and PCA:</p>
			<ol>
				<li value="1">Run and display <strong class="source-inline">pyLDAvis</strong>. This plot is interactive. Clicking on each circle updates the histogram to show the top words related to that specific topic. The following is one view of this interactive plot:<p class="source-code">lda_plot = pyLDAvis.sklearn\</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â .prepare(lda, clean_vec1, vectorizer1, R=10)</p><p class="source-code">pyLDAvis.display(lda_plot)</p><p>The plot appears as follows:</p><div id="_idContainer245" class="IMG---Figure"><img src="image/B15923_07_33.jpg" alt="Figure 7.33: A histogram and biplot for the LDA model&#13;&#10;"/></div><p class="figure-caption">Figure 7.33: A histogram and biplot for the LDA model</p></li>
				<li>Define a function that fits a t-SNE model and then plots the results. After defining it, the pieces of the function will be described in detail, so that the steps are clear:<p class="source-code-heading">Exercise7.01-Exercise7.12.ipynb</p><p class="source-code">def plot_tsne(data, threshold):</p><p class="source-code">Â Â Â Â # filter data according to threshold</p><p class="source-code">Â Â Â Â index_meet_threshold = numpy.amax(data, axis=1) &gt;= threshold</p><p class="source-code">Â Â Â Â lda_transform_filt = data[index_meet_threshold]</p><p class="source-code">Â Â Â Â # fit tsne model</p><p class="source-code">Â Â Â Â # x-d -&gt; 2-d, x = number of topics</p><p class="source-code">Â Â Â Â tsne = sklearn.manifold.TSNE(n_components=2, \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â verbose=0, \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â random_state=0, \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â angle=0.5, \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â init='pca')</p><p class="source-code">Â Â Â Â tsne_fit = tsne.fit_transform(lda_transform_filt)</p><p class="source-code">Â Â Â Â # most probable topic for each headline</p><p class="source-code">Â Â Â Â most_prob_topic = []</p><p class="source-code-link">The complete code for this step can be found at <a href="https://packt.live/34gLGKa">https://packt.live/34gLGKa</a>.</p><p><strong class="bold">Step 1</strong>: The function starts by filtering down the topic-document matrix using an input threshold value. There are tens of thousands of headlines, and any plot incorporating all the headlines is going to be difficult to read and therefore not helpful. So, this function only plots a document if one of the distribution values is greater than or equal to the input threshold value: </p><p class="source-code">index_meet_threshold = numpy.amax(data, axis=1) &gt;= threshold</p><p class="source-code">lda_transform_filt = data[index_meet_threshold]</p><p><strong class="bold">Step 2</strong>: Once the data is filtered down, run t-SNE, where the number of components is two, so that we can plot the results in two dimensions:</p><p class="source-code">tsne = sklearn.manifold.TSNE(n_components=2, \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â verbose=0, \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â random_state=0, \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â angle=0.5, \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â init='pca')</p><p class="source-code">tsne_fit = tsne.fit_transform(lda_transform_filt)</p><p><strong class="bold">Step 3</strong>: Create a vector with an indicator of which topic is most related to each document. This vector will be used to color-code the plot by topic: </p><p class="source-code">most_prob_topic = []</p><p class="source-code">for i in range(tsne_fit.shape[0]):</p><p class="source-code">Â Â Â Â most_prob_topic.append(lda_transform_filt[i].argmax())</p><p><strong class="bold">Step 4</strong>: To understand the distribution of topics across the corpus and the impact of threshold filtering, the function returns the length of the topic vector as well as the topics themselves with the number of documents to which that topic has the largest distribution value:</p><p class="source-code">print("LENGTH:\n{}\n".format(len(most_prob_topic)))</p><p class="source-code">unique, counts = numpy.unique(numpy.array(most_prob_topic), \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return_counts=True)</p><p class="source-code">print("COUNTS:\n{}\n".format(numpy.asarray((unique, counts)).T))</p><p><strong class="bold">Step 5</strong>: Create and return the plot:</p><p class="source-code">color_list = ['b', 'g', 'r', 'c', 'm', 'y', 'k']</p><p class="source-code">for i in list(set(most_prob_topic)):</p><p class="source-code">Â Â Â Â indices = [idx for idx, val in enumerate(most_prob_topic) \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if val == i]</p><p class="source-code">Â Â Â Â matplotlib.pyplot.scatter(x=tsne_fit[indices, 0], \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â y=tsne_fit[indices, 1], \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â s=0.5, c=color_list[i], \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â label='Topic' + str(i), \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â alpha=0.25)</p><p class="source-code">matplotlib.pyplot.xlabel('x-tsne')</p><p class="source-code">matplotlib.pyplot.ylabel('y-tsne')</p><p class="source-code">matplotlib.pyplot.legend(markerscale=10)</p></li>
				<li>Execute the function:<p class="source-code">plot_tsne(data=lda_transform, threshold=0.75)</p><p>The output is as follows:</p><div id="_idContainer246" class="IMG---Figure"><img src="image/B15923_07_34.jpg" alt="Figure 7.34: t-SNE plot with metrics around the distribution of the topics across the corpus&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 7.34: t-SNE plot with metrics around the distribution of the topics across the corpus</p>
			<p>The visualizations show that the LDA model with three topics is producing good results overall. In the biplot, the circles are of a medium size, which suggests that the topics appear consistently across the corpus and the circles also have good spacing. The t-SNE plot shows clear clusters supporting the separation between the circles represented in the biplot. The only glaring issue, which was previously discussed, is that one of the topics has words that do not seem to belong to that topic.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/34gLGKa">https://packt.live/34gLGKa</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/3fbWQES">https://packt.live/3fbWQES</a>.</p>
			<p class="callout">You must execute the entire Notebook in order to get the desired result.</p>
			<p>In the next exercise, let's rerun the LDA using four topics.</p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor159"/>Exercise 7.09: Trying Four Topics</h2>
			<p>In this exercise, LDA is run with the number of topics set to four. The motivation for doing this is to try and solve what might be an under-cooked topic from the three-topic LDA model that has words related to both Palestine and the economy. We will run through the steps first and then explore the results at the end:</p>
			<ol>
				<li value="1">Run an LDA model with the number of topics equal to four:<p class="source-code">lda4 = sklearn.decomposition.LatentDirichletAllocation(\</p><p class="source-code">Â Â Â Â Â Â Â n_components=4,  # number of topics data suggests \</p><p class="source-code">Â Â Â Â Â Â Â learning_method="online", \</p><p class="source-code">Â Â Â Â Â Â Â random_state=0)</p><p class="source-code">lda4.fit(clean_vec1)</p><p>The output is as follows:</p><div id="_idContainer247" class="IMG---Figure"><img src="image/B15923_07_35.jpg" alt="Figure 7.35: The LDA model&#13;&#10;"/></div><p class="figure-caption">Figure 7.35: The LDA model</p></li>
				<li>Execute the <strong class="source-inline">get_topics</strong> function defined earlier to produce the more readable word-topic and topic-document tables:<p class="source-code">W_df4, H_df4 = get_topics(mod=lda4, \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â vec=clean_vec1, \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â names=feature_names_vec1, \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â docs=raw, \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ndocs=number_docs, \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â nwords=number_words)</p></li>
				<li>Print the word-topic table:<p class="source-code">print(W_df4)</p><p>The output is as follows:</p><div id="_idContainer248" class="IMG---Figure"><img src="image/B15923_07_36.jpg" alt="Figure 7.36: The word-topic table using the four-topic LDA model&#13;&#10;"/></div><p class="figure-caption">Figure 7.36: The word-topic table using the four-topic LDA model</p></li>
				<li>Print the document-topic table:<p class="source-code">print(H_df4)</p><p>The output is as follows:</p><div id="_idContainer249" class="IMG---Figure"><img src="image/B15923_07_37.jpg" alt="Figure 7.37: The document-topic table using the four-topic LDA model&#13;&#10;"/></div><p class="figure-caption">Figure 7.37: The document-topic table using the four-topic LDA model</p></li>
				<li>Display the results of the LDA model using <strong class="source-inline">pyLDAvis</strong>:<p class="source-code">lda4_plot = pyLDAvis.sklearn\</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â .prepare(lda4, clean_vec1, vectorizer1, R=10)</p><p class="source-code">pyLDAvis.display(lda4_plot)</p><p>The plot is as follows:</p><div id="_idContainer250" class="IMG---Figure"><img src="image/B15923_07_38.jpg" alt="Figure 7.38: A histogram and biplot describing the four-topic LDA model&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 7.38: A histogram and biplot describing the four-topic LDA model</p>
			<p>Looking at the word-topic table, we see that the four topics found by this model align with the four topics specified in the original dataset. Those topics are Barack Obama, Palestine, Microsoft, and the economy. The question now is, why did the model built using four topics have a higher perplexity score than the model with three topics? That answer comes from the visualization produced in <em class="italic">Step 5</em>. </p>
			<p>The biplot has circles of reasonable size, but two of those circles are quite close together, which suggests that those two topics (Microsoft and the economy) are very similar. In this case, the similarity actually makes intuitive sense. Microsoft is a major global company that impacts and is impacted by the economy. The next step, if we were to make one, would be to run the t-SNE plot to check whether the clusters in the t-SNE plot overlap.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/34gLGKa">https://packt.live/34gLGKa</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/3fbWQES">https://packt.live/3fbWQES</a>.</p>
			<p class="callout">You must execute the entire Notebook in order to get the desired result.</p>
			<p>Let's now apply our knowledge of LDA to another dataset.</p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor160"/>Activity 7.02: LDA and Health Tweets</h2>
			<p>In this activity, we'll apply LDA to the health tweets data loaded and cleaned in <em class="italic">Activity 7.01</em>, <em class="italic">Loading and Cleaning Twitter Data</em>. Remember to use the same notebook used in that activity. Once the steps have been executed, discuss the results of the model. Do these word groupings make sense?</p>
			<p>For this activity, let's imagine that we are interested in acquiring a high-level understanding of the major public health topics. That is, what people are talking about in the world of health. We have collected some data that could shed light on this inquiry. The easiest way to identify the major topics in the dataset, as we have discussed, is topic modeling.</p>
			<p>Here are the steps to complete the activity:</p>
			<ol>
				<li value="1">Specify the <strong class="source-inline">number_words</strong>, <strong class="source-inline">number_docs</strong>, and <strong class="source-inline">number_features</strong>Â variables.</li>
				<li>Create a bag-of-words model and assign the feature names to another variable for use later on.</li>
				<li>Identify the optimal number of topics.</li>
				<li>Fit the LDA model using the optimal number of topics.</li>
				<li>Create and print the word-topic table.</li>
				<li>Print the document-topic table.</li>
				<li>Create a biplot visualization.</li>
				<li>Keep the notebook open for future modeling.<p>The output will be as follows:</p><div id="_idContainer251" class="IMG---Figure"><img src="image/B15923_07_39.jpg" alt="Figure 7.39: A histogram and biplot for the LDA model trained on health tweets&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 7.39: A histogram and biplot for the LDA model trained on health tweets</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found on page 482.</p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor161"/>Exercise 7.10: Creating a Bag-of-Words Model Using TF-IDF</h2>
			<p>In this exercise, we will create a bag-of-words model using TF-IDF:</p>
			<ol>
				<li value="1">Run the TF-IDF vectorizer and print out the first few rows:<p class="source-code">vectorizer2 = sklearn.feature_extraction.text.TfidfVectorizer\</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â (analyzer="word",\</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â max_df=0.5, \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â min_df=20, \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â max_features=number_features,\</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â smooth_idf=False)</p><p class="source-code">clean_vec2 = vectorizer2.fit_transform(clean_sentences)</p><p class="source-code">print(clean_vec2[0])</p><p>The output is as follows:</p><div id="_idContainer252" class="IMG---Figure"><img src="image/B15923_07_40.jpg" alt="Figure 7.40: Output of the TF-IDF vectorizer&#13;&#10;"/></div><p class="figure-caption">Figure 7.40: Output of the TF-IDF vectorizer</p></li>
				<li>Return the feature names (the actual words in the corpus dictionary) to use when analyzing the output. You will recall that we did the same thing when we ran <strong class="source-inline">CountVectorizer</strong> in <em class="italic">Exercise7.05</em>, <em class="italic">Creating a Bag-of-Words Model Using the Count Vectorizer</em>:<p class="source-code">feature_names_vec2 = vectorizer2.get_feature_names()</p><p class="source-code">feature_names_vec2</p><p>A section of the output is as follows:</p><p class="source-code">['abbas',</p><p class="source-code">Â 'ability',</p><p class="source-code">Â 'accelerate',</p><p class="source-code">Â 'accept',</p><p class="source-code">Â 'access',</p><p class="source-code">Â 'accord',</p><p class="source-code">Â 'account',</p><p class="source-code">Â 'accused',</p><p class="source-code">Â 'achieve',</p><p class="source-code">Â 'acknowledge',</p><p class="source-code">Â 'acquire',</p><p class="source-code">Â 'acquisition',</p><p class="source-code">Â 'across',</p><p class="source-code">Â 'action',</p><p class="source-code">Â 'activist',</p><p class="source-code">Â 'activity',</p><p class="source-code">Â 'actually',</p></li>
			</ol>
			<p>In this exercise, we summarized the corpus in the form of a bag-of-words model. Weights were computed for each document word combination. This bag of words output will return later on during the fitting on our next topic model. The next section will introduce NMF.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/34gLGKa">https://packt.live/34gLGKa</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/3fbWQES">https://packt.live/3fbWQES</a>.</p>
			<p class="callout">You must execute the entire Notebook in order to get the desired result.</p>
			<h1 id="_idParaDest-159"><a id="_idTextAnchor162"/>Non-Negative Matrix Factorization</h1>
			<p>Unlike LDA, <strong class="bold">Non-Negative Matrix Factorization</strong> (<strong class="bold">NMF</strong>) is not a probabilistic model. instead, it is, as the name implies, an approach involving linear algebra. Using matrix factorization as an approach to topic modeling was introduced by Daniel D. Lee and H. Sebastian Seung in 1999. The approach falls into the decomposition family of models that includes PCA, the modeling technique introduced in <em class="italic">Chapter 4</em>, <em class="italic">Introduction to Dimensionality Reduction and PCA</em>.</p>
			<p>The major differences between PCA and NMF are that PCA requires components to be perpendicular while allowing them to be either positive or negative. NMF requires that matrix components be non-negative, which should make sense if you think of this requirement in the context of the data. Topics cannot be negatively related to documents, and words cannot be negatively related to topics. </p>
			<p>If you are not convinced, try to interpret a negative weight associating a topic with a document. It would be something like, topic T makes up -30% of document D; but what does that even mean? It is nonsensical, so NMF has non-negative requirements for every part of the matrix factorization.</p>
			<p>Let's define the matrix to be factorized, <em class="italic">X</em>, as a term-document matrix where the rows are words and the columns are documents. Each element of matrix <em class="italic">X</em> is either the number of occurrences of word <em class="italic">i</em> (the row) in document <em class="italic">j</em> (the column) or some other quantification of the relationship between word <em class="italic">i</em> and document <em class="italic">j</em>. The matrix, <em class="italic">X</em>, is naturally a sparse matrix as most elements in the term-document matrix will be zero, since each document only contains a limited number of words. There will be more on creating this matrix and deriving the quantifications later.</p>
			<div>
				<div id="_idContainer253" class="IMG---Figure">
					<img src="image/B15923_07_41.jpg" alt="Figure 7.41: The matrix factorization &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.41: The matrix factorization </p>
			<p>The matrix factorization takes the form <img src="image/B15923_07_Formula_17.png" alt="where the two "/> , where the two component matrices, <em class="italic">W</em> and <em class="italic">H</em>, represent the topics as collections of words and the topic weights for each document, respectively. More specifically, <em class="italic">W</em><span class="subscript">nxk</span> is a word by topic matrix, while <em class="italic">H</em><span class="subscript">kxm</span> is a topic by document matrix and, as stated earlier, <em class="italic">X</em><span class="subscript">nxm</span> is a word by document matrix. </p>
			<p>A nice way to think of this factorization is as a weighted sum of word groupings defining abstract topics. The equivalency symbol in the formula for the matrix factorization is an indicator that the factorization <em class="italic">WH</em> is an approximation, and thus, the product of those two matrices will not reproduce the original term-document matrix exactly.</p>
			<p>The goal, as it was with LDA, is to find the approximation that is closest to the original matrix. Like <em class="italic">X</em>, both <em class="italic">W</em> and <em class="italic">H</em> are sparse matrices as each topic is only related to a few words, and each document is a mixture of only a small number of topicsâ€”one topic in many cases.</p>
			<h2 id="_idParaDest-160"><a id="_idTextAnchor163"/>The Frobenius Norm</h2>
			<p>The goal of solving NMF is the same as that of LDA: find the best approximation. To measure the distance between the input matrix and the approximation, NMF can use virtually any distance measure, but the standard is the Frobenius norm, also known as the Euclidean norm. The Frobenius norm is the sum of the element-wise squared </p>
			<p>errors mathematically expressed as <img src="image/B15923_07_Formula_18.png" alt="C:\Users\user\Downloads\B15923_07_Formula_18.png"/>.</p>
			<p>With the measure of distance selected, the next step is to define the objective function. The minimization of the Frobenius norm will return the best approximation of the original term-document matrix and, thus, the most reasonable topics. Note that the objective function is minimized with respect to <em class="italic">W</em> and <em class="italic">H</em> so that both matrices </p>
			<p>are non-negative. It is expressed as <img src="image/B15923_07_Formula_19.png" alt="C:\Users\user\Downloads\B15923_07_Formula_19.png"/>.</p>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor164"/>The Multiplicative Update Algorithm</h2>
			<p>The optimization algorithm used to solve NMF by Lee and Seung in their 1999 paper is the Multiplicative Update algorithm, and it is still one of the most commonly used solutions. It will be implemented in the exercises and activities later in the chapter. </p>
			<p>The update rules, for both <em class="italic">W</em> and <em class="italic">H</em>, are derived by expanding the objective function and taking the partial derivatives with respect to <em class="italic">W</em> and<em class="italic"> H</em>. The derivatives are not difficult but do, require fairly extensive linear algebra knowledge, and are time-consuming, so let's skip the derivatives and just state the updates. Note that, in the update rules, <em class="italic">i</em> is the current iteration and <em class="italic">T</em> means the transpose of the matrix. The first update rule is as follows:</p>
			<div>
				<div id="_idContainer257" class="IMG---Figure">
					<img src="image/B15923_07_42.jpg" alt="Figure 7.42: First update rule&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.42: First update rule</p>
			<p>The second update rule is as follows:</p>
			<div>
				<div id="_idContainer258" class="IMG---Figure">
					<img src="image/B15923_07_43.jpg" alt="Figure 7.43: Second update rule&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.43: Second update rule</p>
			<p><em class="italic">W</em> and <em class="italic">H</em> are updated iteratively until the algorithm converges. The objective function can also be shown to be non-increasing; that is, with each iterative update of <em class="italic">W</em> and <em class="italic">H</em>, the objective function gets closer to the minimum. Note that the multiplicative update optimizer, if the update rules are reorganized, is a rescaled gradient descent algorithm. </p>
			<p>The final component of building a successful NMF algorithm is initializing the <em class="italic">W</em> and <em class="italic">H</em> component matrices so that the multiplicative update works quickly. A popular approach to initializing matrices is <strong class="bold">Singular Value Decomposition</strong> (<strong class="bold">SVD</strong>), which is a generalization of Eigen decomposition. </p>
			<p>In the implementation of NMF undertaken in the forthcoming exercises, the matrices are initialized via non-negative Double Singular Value Decomposition, which is basically a more advanced version of SVD that is strictly non-negative. The full details of these initialization algorithms are not important for understanding NMF. Just note that initialization algorithms are used as a starting point for the optimization algorithms and can drastically speed up convergence.</p>
			<h2 id="_idParaDest-162"><a id="_idTextAnchor165"/>Exercise 7.11: Non-negative Matrix Factorization</h2>
			<p>In this exercise, we'll fit the NMF algorithm and output the same two result tables we previously did with LDA. Those tables are the word-topic table, which shows the top 10 words associated with each topic, and the document-topic table, which shows the top 10 documents associated with each topic. </p>
			<p>There are two additional parameters in the NMF algorithm function that we have not previously discussed, which are <strong class="source-inline">alpha</strong> and <strong class="source-inline">l1_ratio</strong>. If an overfit model is of concern, these parameters control how (<strong class="source-inline">l1_ratio</strong>) and the extent to which (<strong class="source-inline">alpha</strong>) regularization is applied to the objective function:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">More details can be found in the documentation for the scikit-learn library (<a href="https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.NMF.html">https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.NMF.html</a>).</p>
			<ol>
				<li value="1">Define the NMF model and call the <strong class="source-inline">fit</strong> function using the output of the TF-IDF vectorizer:<p class="source-code">nmf = sklearn.decomposition.NMF(n_components=4, \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â init="nndsvda", \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â solver="mu", \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â beta_loss="frobenius", \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â random_state=0, \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â alpha=0.1, \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â l1_ratio=0.5)</p><p class="source-code">nmf.fit(clean_vec2)</p><p>The output is as follows:</p><div id="_idContainer259" class="IMG---Figure"><img src="image/B15923_07_44.jpg" alt="Figure 7.44: Defining the NMF model&#13;&#10;"/></div><p class="figure-caption">Figure 7.44: Defining the NMF model</p></li>
				<li>Run the <strong class="source-inline">get_topics</strong> functions to produce the two output tables:<p class="source-code">W_df, H_df = get_topics(mod=nmf, \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â vec=clean_vec2, \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â names=feature_names_vec2, \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â docs=raw, \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ndocs=number_docs, \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â nwords=number_words)</p></li>
				<li>Print the <strong class="source-inline">W</strong> table:<p class="source-code">print(W_df)</p><p>The output is as follows:</p><div id="_idContainer260" class="IMG---Figure"><img src="image/B15923_07_45.jpg" alt="Figure 7.45: The word-topic table containing probabilities&#13;&#10;"/></div><p class="figure-caption">Figure 7.45: The word-topic table containing probabilities</p></li>
				<li>Print the <strong class="source-inline">H</strong> table:<p class="source-code">print(H_df)</p><p>The output is as follows:</p><div id="_idContainer261" class="IMG---Figure"><img src="image/B15923_07_46.jpg" alt="Figure 7.46: The document-topic table containing probabilities&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 7.46: The document-topic table containing probabilities</p>
			<p>The word-topic table contains word groupings that suggest the same abstract topics that the four-topic LDA model produced in <em class="italic">Exercise 7.09</em>, <em class="italic">Trying Four Topics</em>. However, the interesting part of the comparison is that some of the individual words contained in these groupings are new or in a new place in the grouping. This is not surprising given that the methodologies are distinct. Given the alignment with the topics specified in the original dataset, we have shown that both of these methodologies are effective tools for extracting the underlying topic structure of the corpus.</p>
			<p>As we did with our previously fit LDA model, we will visualize the results of our NMF model.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/34gLGKa">https://packt.live/34gLGKa</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/3fbWQES">https://packt.live/3fbWQES</a>.</p>
			<p class="callout">You must execute the entire Notebook in order to get the desired result.</p>
			<h2 id="_idParaDest-163"><a id="_idTextAnchor166"/>Exercise 7.12: Visualizing NMF</h2>
			<p>The purpose of this exercise is to visualize the results of NMF. Visualizing the results gives insight into the distinctness of the topics and the prevalence of each topic in the corpus. In this exercise, we'll do the visualizing using t-SNE, which was discussed fully in <em class="italic">Chapter 6</em>, <em class="italic">t-Distributed Stochastic Neighbor Embedding</em>:</p>
			<ol>
				<li value="1">Run <strong class="source-inline">transform</strong> on the cleaned data to get the topic-document allocations. Print both the shape and an example of the data:<p class="source-code">nmf_transform = nmf.transform(clean_vec2)</p><p class="source-code">print(nmf_transform.shape)</p><p class="source-code">print(nmf_transform)</p><p>The output is as follows:</p><p class="source-code">(92946, 4)</p><p class="source-code">[[5.12653315e-02 3.60582233e-15 3.19729419e-34 8.17267206e-16]</p><p class="source-code">Â [7.43734737e-04 2.04138105e-02 6.85552731e-15 2.11679327e-03]</p><p class="source-code">Â [2.92397552e-15 1.94083984e-02 4.76691813e-21 1.24269313e-18]</p><p class="source-code">Â ...</p><p class="source-code">Â [9.83404082e-06 3.41225477e-03 6.14009658e-04 3.23919592e-02]</p><p class="source-code">Â [6.51294966e-07 1.32359509e-07 3.32509174e-08 6.14671536e-02]</p><p class="source-code">Â [4.53925928e-05 1.16401194e-04 1.84755839e-02 2.00616344e-03]]</p></li>
				<li>Run the <strong class="source-inline">plot_tsne</strong> function to fit a t-SNE model and plot the results:<p class="source-code">plot_tsne(data=nmf_transform, threshold=0)</p><p>The plot appears as follows:</p><div id="_idContainer262" class="IMG---Figure"><img src="image/B15923_07_47.jpg" alt="Figure 7.47: t-SNE plot with metrics summarizing the topic distribution across the corpus&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 7.47: t-SNE plot with metrics summarizing the topic distribution across the corpus</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The results can differ slightly because of the optimization algorithms that support both LDA and NMF. Many of the functions do not have a seed setting capability.</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/34gLGKa">https://packt.live/34gLGKa</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/3fbWQES">https://packt.live/3fbWQES</a>.</p>
			<p class="callout">You must execute the entire Notebook in order to get the desired result.</p>
			<p>The t-SNE plot, with no threshold specified, shows some topic overlap and a clear discrepancy in the topic frequency across the corpus. These two facts explain why, when using perplexity, the optimal number of topics was three. There seems to be some correlation between topics that the model can't fully accommodate. Even with the correlation between topics, the model is finding the topics it should when the number of topics is set to four.</p>
			<p>To recap, NMF is a non-probabilistic topic model that seeks to answer the same question LDA is trying to answer. It uses a popular concept of linear algebra known as matrix factorization, which is the process of breaking a large and intractable matrix down into smaller and more easily interpretable matrices that can be leveraged to answer many questions about the data. Remember that the non-negative requirement is not rooted in mathematics, but in the data itself. It does not make sense for the components of any document to be negative. </p>
			<p>In many cases, NMF does not perform as well as LDA, because LDA incorporates prior distributions that add an extra layer of information to help inform the topic word groupings. However, we know that there are cases, especially when the topics are highly correlated, when NMF is the better performer. One of those cases was the headline data on which all the exercises were based.</p>
			<p>Let's now try to apply our new knowledge of NMF to the Twitter dataset used in the previous activities.</p>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor167"/>Activity 7.03: Non-negative Matrix Factorization</h2>
			<p>This activity is the summation of the topic modeling analysis done on the health Twitter data loaded and cleaned in <em class="italic">Activity 7.01</em>, <em class="italic">Loading and Cleaning Twitter Data</em>, and on which LDA was done in <em class="italic">Activity 7.02</em>, <em class="italic">LDA and Health Tweets</em>. The execution of NMF is straightforward and requires limited coding. We can take this opportunity to play with the parameters of the model while thinking about the limitations and benefits of NMF.</p>
			<p>Here are the steps to complete the activity:</p>
			<ol>
				<li value="1">Create the appropriate bag-of-words model and output the feature names as another variable.</li>
				<li>Define and fit the NMF algorithm using the number of topics (<strong class="source-inline">n_components</strong>) value from <em class="italic">Activity 7.02</em>, <em class="italic">LDA and Health Tweets</em>.</li>
				<li>Get the topic-document and word-topic tables. Take a few minutes to explore the word groupings and try to define the abstract topics. Can you quantify the meanings of the word groupings? Do the word groupings make sense? Are the results similar to those produced using LDA?</li>
				<li>Adjust the model parameters and rerun <em class="italic">Step 3</em> and <em class="italic">Step 4</em>. How do the results change?<p>The output will be as follows:</p><div id="_idContainer263" class="IMG---Figure"><img src="image/B15923_07_48.jpg" alt="Figure 7.48: The word-topic table with probabilities&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 7.48: The word-topic table with probabilities</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found on page 487.</p>
			<h1 id="_idParaDest-165"><a id="_idTextAnchor168"/>Summary</h1>
			<p>When faced with the task of extracting information from an as yet unseen large collection of documents, topic modeling is a great approach, as it provides insights into the underlying structure of the documents. That is, topic models find word groupings using proximity, not context. </p>
			<p>In this chapter, we have learned how to apply two of the most common and most effective topic modeling algorithms: latent Dirichlet allocation and non-negative matrix factorization. You should now feel comfortable cleaning raw text documents using several different techniques; techniques that can be utilized in many other modeling scenarios. We continued by learning how to convert the cleaned corpus into the appropriate data structure of per-document raw word counts or word weights by applying bag-of-words models. </p>
			<p>The main focus of the chapter was fitting the two topic models, including optimizing the number of topics, converting the output to easy-to-interpret tables, and visualizing the results. With this information, you should be able to apply fully functioning topic models to derive value and insights for your business.</p>
			<p>In the next chapter, we will change direction entirely. We will deep dive into market basket analysis.</p>
		</div>
		<div>
			<div id="_idContainer265" class="Content">
			</div>
		</div>
	</body></html>