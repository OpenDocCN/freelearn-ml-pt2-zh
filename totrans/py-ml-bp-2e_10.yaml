- en: Build a Recommendation Engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like so many things, it was born of frustration and stiff cocktails. It was
    a Saturday, and the two young men were once again stuck without a date for the
    night. As they sat pouring drinks and sharing laments, the two Harvard freshmen
    began to flesh out an idea. What if, instead of relying on random chance to meet
    the right girl, they could use a computer algorithm?
  prefs: []
  type: TYPE_NORMAL
- en: The key to matching people up, they felt, would be to create a set of questions
    that provided the sort of information everyone is really looking for on those
    first awkward dates. By matching people using these questionnaires, you could
    eliminate dates that could best be avoided. The process would be super efficient.
  prefs: []
  type: TYPE_NORMAL
- en: The idea was to market their new service to college students in Boston and around
    the country. And in short order, that's exactly what they did.
  prefs: []
  type: TYPE_NORMAL
- en: Soon after, the digital matchmaking service they built went on to become a huge
    success. It received national media attention and generated tens of thousands
    of matches over the course of the next few years. The company was so successful,
    in fact, it was eventually bought out by a larger company that wanted to use its
    technology.
  prefs: []
  type: TYPE_NORMAL
- en: If you think I'm talking about **OkCupid**, you would be wrong—and off by about
    40 years. The company I'm speaking of did all of this beginning in 1965—a time
    when computing matches was done using punch cards on an IBM 1401 mainframe. It
    also took three days just to run the computations.
  prefs: []
  type: TYPE_NORMAL
- en: But oddly enough, there's a connection between OkCupid and its 1965 precursor,
    Compatibility Research, Inc. The co-founder of Compatibility Research is Jeff
    Tarr, whose daughter, Jennifer Tarr, is the wife of OkCupid's co-founder Chris
    Coyne. Small world indeed.
  prefs: []
  type: TYPE_NORMAL
- en: But why is any of this relevant to a chapter on building a recommendation engine?
    Because it's quite likely that this was in fact the first one. And while most
    people tend to think of recommendation engines as tools for finding closely related
    products or music and movies they're likely to appreciate, the original incarnation
    was to find potential mates. And as a model for thinking about how these systems
    work, it provides a good frame of reference.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we're going to explore the different varieties of recommendation
    systems. We'll see how they're implemented commercially and how they work. Finally,
    we'll implement our own recommendation engine for finding GitHub repositories.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Collaborative filtering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Content-based filtering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hybrid systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a recommendation engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collaborative filtering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In early 2012, a story broke about a man who had come into a Target store in
    Minneapolis to complain about a book of coupons sent to his home. He was in fact
    quite incensed about these coupons, which had been addressed to his daughter,
    a high school student at the time. And although it might seem like an odd reaction
    to a potential money-saving opportunity, learning that the coupons were exclusively
    for products such as prenatal vitamins, diapers, baby formula, cribs, and so on
    might change your view.
  prefs: []
  type: TYPE_NORMAL
- en: The manager, upon hearing the complaint, apologized profusely. He felt bad enough,
    in fact, that he called several days later to follow up and explain how this could
    have happened. But before the manager was able to even begin his apology, the
    father began to apologize to the manager. As it turned out, his daughter was in
    fact pregnant and her shopping habits had given her away.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm that gave her away was likely based—at least in part—on one type
    of algorithm used in recommendation engines called **collaborative filtering**.
  prefs: []
  type: TYPE_NORMAL
- en: So, what's collaborative filtering?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Collaborative filtering is based on the idea that, somewhere out there in the
    world, you have a taste doppelganger—someone who shares the same notions about
    how good *Star Wars* is and how awful *Love Actually* is.
  prefs: []
  type: TYPE_NORMAL
- en: The idea is that you've rated some set of items in a way that's very similar
    to the way this other person, this doppelganger, has rated them, but then each
    of you has rated additional items that the other hasn't. Because you've established
    that your tastes are similar, recommendations can be generated from the items
    your doppelganger has rated highly but which you haven't rated and vice versa.
    It's in a way much like digital matchmaking, but with the outcome being songs
    or products you would like, rather than actual people.
  prefs: []
  type: TYPE_NORMAL
- en: So, in the case of our pregnant high schooler, when she bought the right combination
    of unscented lotions, cotton balls, and vitamin supplements, she likely found
    herself paired up with people who went on to buy cribs and diapers at some point
    later.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go through an example to see how this works in practice.
  prefs: []
  type: TYPE_NORMAL
- en: We'll start with what's called a **utility matrix**. This is similar to a **term-document
    matrix** but, instead of terms and documents, we'll be representing products and
    users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we''ll assume that we have customers *A-D* and a set of products that
    they''ve rated on a scale from 0 to 5:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Customer** | **Snarky''s Potato Chips** | **SoSo Smooth** **Lotion** |
    **Duffly** **Beer** | **BetterTap** **Water** | **XXLargeLivin''** **Football
    Jersey** | **Snowy** **Cotton**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Balls** | **Disposos''** **Diapers** |'
  prefs: []
  type: TYPE_NORMAL
- en: '| **A** | 4 |  | 5 | 3 | 5 |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| **B** |  | 4 |  | 4 |  | 5 |  |'
  prefs: []
  type: TYPE_TB
- en: '| **C** | 2 |  | 2 |  | 1 |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| **D** |  | 5 |  | 3 |  | 5 | 4 |'
  prefs: []
  type: TYPE_TB
- en: 'We''ve seen previously that, when we want to find similar items, we could use
    cosine similarity. Let''s try that here. We''ll find the user most like user *A*.
    Because we have a sparse vector containing many unrated items, we''ll have to
    input something for those missing values. We''ll just go with 0 here. We''ll start
    by comparing user *A* to user *B*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5672e7bc-e966-477e-9ab0-95cdadabfaec.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the two don't have a high similarity rating, which makes sense
    as they have no ratings in common.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now look at user C compared to user *A*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/608f4fa0-0045-464c-b0a4-493eaa5c34ad.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we see that they have a high similarity rating (remember 1 is perfect
    similarity), despite the fact they rated the same products very differently. Why
    are we getting these results? The problem lies with our choice of using 0 for
    the unrated products. It's registering as strong (negative) agreement on those
    unrated products. 0 isn't neutral in this case.
  prefs: []
  type: TYPE_NORMAL
- en: So, how can we fix this?
  prefs: []
  type: TYPE_NORMAL
- en: What we can do instead of just using 0 for the missing values is to re-center
    each user's ratings so that the mean rating is 0, or neutral. We do this by taking
    each user rating and subtracting the mean for all ratings of that user. For example,
    for user *A*, the mean is 17/4, or 4.25\. We then subtract that from every individual
    rating that user *A* provided.
  prefs: []
  type: TYPE_NORMAL
- en: Once that's been done, we then continue on to find the mean for every other
    user and subtract it from each of their ratings until every user has been processed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This procedure will result in a table like the following. You will notice each
    user row sums to 0 (ignore the rounding issues here):'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Customers** | **Snarky''s Potato Chips** | **SoSo Smooth** **Lotion** |
    **Duffly** **Beer** | **BetterTap** **Water** | **XXLargeLivin''** **Football
    Jersey** | **Snowy** **Cotton**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Balls** | **Disposos''** **Diapers** |'
  prefs: []
  type: TYPE_NORMAL
- en: '| **A** | -.25 |  | .75 | -1.25 | .75 |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| **B** |  | -.33 |  | -.33 |  | .66 |  |'
  prefs: []
  type: TYPE_TB
- en: '| **C** | .33 |  | .33 |  | -.66 |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| **D** |  | .75 |  | -1.25 |  | .75 | -.25 |'
  prefs: []
  type: TYPE_TB
- en: Let's now try our cosine similarity on our newly centered data. We'll do user
    *A* compared to user *B* and *C* again.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s compare user *A* to user *B*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0f996df4-2bae-40a3-8a4d-e42e49ed0faa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let''s try between users *A* and *C*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/be39db7c-65c3-435f-8a0e-e1def4064051.png)'
  prefs: []
  type: TYPE_IMG
- en: What we can see is that the similarity between *A* and *B* increased slightly,
    while the similarity between *A* and *C* decreased dramatically. This is exactly
    as we would hope.
  prefs: []
  type: TYPE_NORMAL
- en: This centering process, besides helping us deal with missing values, also has
    the side benefit of helping us to deal with difficult or easy raters since now
    everyone is centered around a mean of 0\. This formula, you may notice, is equivalent
    to the Pearson correlation coefficient and, just like with that coefficient, the
    values fall between `-1` and `1`.
  prefs: []
  type: TYPE_NORMAL
- en: Predicting the rating for the product
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now take this framework and use it to predict the rating for a product.
    We'll limit our example to three users, person *X*, person *Y*, and person *Z*.
    We'll predict the rating of a product that person *X* hasn't rated, but that persons
    *Y* and *Z*, who are very similar to *X*, have rated.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with our base ratings for each user, as shown in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Customers** | **Snarky''s Potato Chips** | **SoSo Smooth** **Lotion** |
    **Duffly** **Beer** | **BetterTap** **Water** | **XXLargeLivin''** **Football
    Jersey** | **Snowy** **Cotton**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Balls** | **Disposos''** **Diapers** |'
  prefs: []
  type: TYPE_NORMAL
- en: '| **X** |  | 4 |  | 3 |  | 4 |  |'
  prefs: []
  type: TYPE_TB
- en: '| **Y** |  | 3.5 |  | 2.5 |  | 4 | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| **Z** |  | 4 |  | 3.5 |  | 4.5 | 4.5 |'
  prefs: []
  type: TYPE_TB
- en: 'Next, we''ll center the ratings:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Customers** | **Snarky''s Potato Chips** | **SoSo Smooth** **Lotion** |
    **Duffly** **Beer** | **BetterTap** **Water** | **XXLargeLivin''** **Football
    Jersey** | **Snowy** **Cotton**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Balls** | **Disposos''** **Diapers** |'
  prefs: []
  type: TYPE_NORMAL
- en: '| **X** |  | .33 |  | -.66 |  | .33 | ? |'
  prefs: []
  type: TYPE_TB
- en: '| **Y** |  | 0 |  | -1 |  | .5 | .5 |'
  prefs: []
  type: TYPE_TB
- en: '| **Z** |  | -.125 |  | -.625 |  | .375 | .375 |'
  prefs: []
  type: TYPE_TB
- en: Now, we'd like to know what rating user *X* might be likely to give **Disposos'
    Diapers**. Using the ratings from user *Y* and user *Z*, we can calculate this
    by taking the weighted average according to their centered cosine similarity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first get that figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a5611a3e-2da1-4821-a782-a64680fd5565.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s get that figure for user *Z*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2bf43f2d-e87c-46aa-a3c4-048480370cb7.png)'
  prefs: []
  type: TYPE_IMG
- en: So, now we have a figure for the similarity between user *X* and user *Y* (`0.42447212`)
    and user *Z* (`0.46571861`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting it all together, we weight each users rating by their similarity to
    *X*, and then divide by the total similarity, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*(.42447212 * (4) + .46571861 * (4.5) ) / (.42447212 + .46571861) = 4.26*'
  prefs: []
  type: TYPE_NORMAL
- en: And we can see that the expected rating of user *X* for **Disposos' Diapers**
    is 4.26\. (Better send a coupon!)
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, so far, we''ve looked only at user-to-user collaborative filtering, but
    there''s another method we can use. In practice, this method outperforms user-to-user
    filtering; it''s called **item-to-item filtering**. Here''s how the method works:
    rather than match each user up with other similar users based on their past ratings,
    each rated item is compared against all other items to find the most similar ones,
    again using centered cosine similarity.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at how this would work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again we have a utility matrix; this time, we''ll look at users'' ratings of
    songs. The users are along the columns and the songs are along the rows, shown
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Entity** | **U1** | **U2** | **U3** | **U4** | **U5** |'
  prefs: []
  type: TYPE_TB
- en: '| **S1** | 2 |  | 4 |  | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| **S2** |  | 3 |  | 3 |  |'
  prefs: []
  type: TYPE_TB
- en: '| **S3** | 1 |  | 5 |  | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| **S4** |  | 4 | 4 | 4 |  |'
  prefs: []
  type: TYPE_TB
- en: '| **S5** | 3 |  |  |  | 5 |'
  prefs: []
  type: TYPE_TB
- en: Now, suppose we would like to know the rating that user 3 will assign to song
    5\. Instead of looking for similar users, we'll look for songs that are similar
    based upon how they were rated across the users.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we start by centering each song row, and calculating the cosine similarity
    for each versus our target row, which is *S5*, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Entity** | **U1** | **U2** | **U3** | **U4** | **U5** | **CntrdCoSim**
    |'
  prefs: []
  type: TYPE_TB
- en: '| **S1** | -1.66 |  | .33 |  | 1.33 | .98 |'
  prefs: []
  type: TYPE_TB
- en: '| **S2** |  | 0 |  | 0 |  | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| **S3** | -2.33 |  | 1.66 |  | .66 | .72 |'
  prefs: []
  type: TYPE_TB
- en: '| **S4** |  | 0 | 0 | 0 |  | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| **S5** | -1 |  | ? |  | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: You can see the far right column has been calculated with the centered cosine
    similarity for each row versus row *S5*.
  prefs: []
  type: TYPE_NORMAL
- en: We next need to select a number, *k*, that's the number of the nearest neighbors
    we'll use to rate songs for user 3\. We use *k = 2* in our simple example.
  prefs: []
  type: TYPE_NORMAL
- en: You can see that song *S1* and song *S3* are the most similar, so we'll use
    those two along with the ratings user 3 had for *S1* and *S3* (4 and 5, respectively).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now calculate the rating:'
  prefs: []
  type: TYPE_NORMAL
- en: '*(.98 * (4) + .72 * (5)) / (.98 + .72) = 4.42*'
  prefs: []
  type: TYPE_NORMAL
- en: So, based on this item-to-item collaborative filtering, we can see user 3 is
    likely to rate song *S5* very highly at 4.42 from our calculations.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier, I said that user-to-user filtering is less effective than item-to-item
    filtering. Why might that be?
  prefs: []
  type: TYPE_NORMAL
- en: There's a good chance you have friends who really enjoy some of things that
    you enjoy as well, but then each of you has other areas of interest that the other
    has absolutely no interest in.
  prefs: []
  type: TYPE_NORMAL
- en: For example, perhaps you both love *Game of Thrones*, but your friend also loves
    Norwegian death metal. You, however, would rather be dead than listen to Norwegian
    death metal. If you're similar in many ways—excluding the death metal—with user-to-user
    recommendations, you're still going to see a lot of recommendations for bands
    with names that include words such as *flaming*, *axe*, *skull*, and *bludgeon*.
    With item-to-item filtering, most likely, you would be spared those suggestions.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we've looked at users and items as a single entity when making comparisons,
    but now let's move on to look at another method that decomposes our users and
    items into what might be called **feature baskets**.
  prefs: []
  type: TYPE_NORMAL
- en: Content-based filtering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a musician himself, Tim Westergren had spent years on the road listening
    to other talented musicians, wondering why they could never get ahead. Their music
    was good—just as good as anything you might hear on the radio—and yet, somehow,
    they just never caught their big break. He imagined it must be because their music
    just never got in front of enough of the right people.
  prefs: []
  type: TYPE_NORMAL
- en: Tim eventually quit his job as a musician and took another job as a composer
    for movie scores. It was there that he began to think of each piece of music as
    having a distinct structure that could be decomposed into constituent parts—a
    form of musical DNA.
  prefs: []
  type: TYPE_NORMAL
- en: After giving it some thought, he began to consider creating a company around
    this idea of building a **musical genome**. He ran the concept by one of his friends,
    who had previously created and sold a company. The friend loved Tim's idea. So
    much so, in fact, that he began helping him to write a business plan and gather
    the initial funding round for the project. It was a go.
  prefs: []
  type: TYPE_NORMAL
- en: Over the next several years, they employed a small army of musicians who meticulously
    codified almost 400 distinct musical features for over a million pieces of music.
    Each feature was rated on a 0 to 5 point scale by hand (or maybe by ear is a better
    way to say it). Each three- or four-minute song took nearly a half hour to classify.
  prefs: []
  type: TYPE_NORMAL
- en: The features included things such as how gravelly the lead singers' voice was
    or how many beats per minute the tempo was. It took nearly a year for their first
    prototype to be completed. Built entirely in Excel using a VBA macro, it took
    nearly four minutes just to return a single recommendation. But in the end, it
    worked and it worked well.
  prefs: []
  type: TYPE_NORMAL
- en: That company is now known as Pandora music, and chances are you've either heard
    of it or used its products as it has millions of daily users around the world.
    It's without a doubt a triumphant example of content-based filtering.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than treat each song as a single indivisible unit, as in content-based
    filtering, the songs become feature vectors that can be compared using our friend
    cosine similarity.
  prefs: []
  type: TYPE_NORMAL
- en: Another benefit is that not only are the songs subject to being decomposed into
    feature vectors, but the listeners can be as well. Each listener's taste profile
    becomes a vector in this space so that measurements can be made between their
    taste profiles and the songs themselves.
  prefs: []
  type: TYPE_NORMAL
- en: For Tim Westergren, this was the magic, because rather than rely on the popularity
    of the music like so many recommendations are, the recommendations from this system
    were made based upon the inherent structural similarity. Maybe you've never heard
    of song *X*, but if you like song *Y*, then you should like song *X* because it's
    *genetically* almost identical. That's content-based filtering.
  prefs: []
  type: TYPE_NORMAL
- en: Hybrid systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've now looked at the two primary forms of recommender systems, but you should
    know that, in any large-scale production environment, you're likely to see recommendations
    that leverage both of these. This is known as a **hybrid system**, and the reason
    hybrid systems are preferred is that they help eliminate the drawbacks that can
    be present when using either system alone. The two systems together create a more
    robust solution.
  prefs: []
  type: TYPE_NORMAL
- en: Let's examine the pros and cons of each type.
  prefs: []
  type: TYPE_NORMAL
- en: Collaborative filtering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The pros of collaborative filtering are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: There's no need to hand-craft features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The cons are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Doesn't work well without a large number of items and users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sparsity when the number of items far exceeds the number that could be purchased
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Content-based filtering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The pros of content-based filtering are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It doesn't require a large number of users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The cons are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining the right features can be a challenge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lack of serendipity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, content-based filtering is a better choice when you haven't
    built up a large user base but, as you grow, adding on collaborative filtering
    can help introduce more serendipity into the recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you're familiar with the types and inner-workings of recommendation
    engines, let's begin constructing one of our own.
  prefs: []
  type: TYPE_NORMAL
- en: Building a recommendation engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One thing I love to stumble upon is a really useful GitHub repository. You can
    find repositories that contain everything from hand-curated tutorials on machine
    learning to libraries that will save you dozens of lines of code when using **Elasticsearch**.
    The trouble is, finding these libraries is far more difficult than it should be.
    Fortunately, we now have the knowledge to leverage the GitHub API in a way that
    will help us to find these code gems.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to be using the GitHub API to create a recommendation engine based
    on collaborative filtering. The plan is to get all of the repositories I've starred
    over time and to then get all of the creators of those repositories to find what
    repositories they've starred. Once that's done, we'll find which users are most
    similar to me (or you, if you're running this for your own repository, which I
    suggest). Once we have the most similar users, we can use the repositories they've
    starred and that I haven't to generate a set of recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll import the libraries we''ll need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You'll need to have opened an account with GitHub and to have starred a number
    of repositories for this to work for your GitHub handle, but you won't actually
    need to sign up for the developer program. You can get an authorization token
    from your profile, which will allow you to use the API. You can also get it to
    work with this code, but the limits are too restrictive to make it usable for
    our example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To create a token for use with the API, go to the following URL at [https://github.com/settings/tokens](https://github.com/settings/tokens).
    There, you will see a button in the upper-right corner like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6093907c-b461-403b-b45a-1e54166869ad.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You''ll need to click on that Generate new token button. Once you''ve done
    that, you need to select the permissions, I chose just public_repo. Then, finally,
    copy the token it gives you for use in the following code. Be sure to enclose
    both in quotes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll create the function that will pull the names of every repository you''ve
    starred:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: There's a lot going on in there, but, essentially, we're querying the API to
    get our own starred repositories. GitHub uses pagination rather than return everything
    in one call. Because of this, we'll need to check the `.links` that are returned
    from each response. As long as there is a next link to call, we'll continue to
    do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'We just need to call that function we created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can see the full list of starred repositories:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will result in output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d5f6c6d1-d138-4a60-8863-fce88149a145.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We need to parse out the user names for each of the libraries we starred so
    that we can retrieve the libraries they starred:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This will result in output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d61cd8d7-6229-474c-8904-b38d4e680787.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have the handles for all of the users we starred, we''ll need to
    retrieve all of the repositories they starred. The following function will do
    just that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This function works in nearly the same way as the function we called earlier,
    but calls a different endpoint. It'll add their starred repositories to a dict
    we'll use later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s call it now. It may take a few minutes to run, depending on the number
    of repositories each user has starred. I actually had one that starred over 4,000
    repositories:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will result in output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/98699917-fcac-48cc-99db-1f272910481d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice that I turned the list of starred users into a set before I called it.
    I noticed some duplication that resulted from starring multiple repositories under
    one user handle, so it makes sense to follow these steps to reduce extra calls:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to build a feature set that includes all of the starred repositories
    of everyone we have starred:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll convert that into a set to remove duplicates that may be present from
    multiple users starring the same repositories:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see how many that produces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code should result in output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b1945589-999e-41b7-8532-67ae6570a9c7.png)'
  prefs: []
  type: TYPE_IMG
- en: I had starred 170 repositories, and together the users of those repositories
    starred over 27,000 unique repositories. You can imagine if we went one degree
    further out how many we might see.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the full feature set, or repository vocabulary, we need to
    run every user to create a binary vector that contains a `1` for every repository
    they''ve starred and a `0` for every repository they haven''t:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: What we just did was check for every user whether they had starred every repository
    in our repository vocabulary. If they did, they received a `1`, if they didn't,
    they received a `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we have a 27,098 item binary vector for each user—all 170 of
    them. Let''s now put this into a `DataFrame`. The row index will be the user handles
    we starred, and the columns will be the repository vocabulary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will generate output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/13164eb3-0140-47d5-b8d9-e0bb7ae78ff7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, in order to compare ourselves to the other users, we need to add our
    own row to this frame. Here, I add my user handle, but you should add your own:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will generate output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/88bf2a5c-5bd1-4ac6-b737-18bb530ac824.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We now need add the appropriate column names and to concatenate this to our
    other `DataFrame`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will result in output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/877967fd-8853-45f8-80e8-e32663d021a3.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see in the previous screenshot that I've been added into the `DataFrame`.
  prefs: []
  type: TYPE_NORMAL
- en: 'From here, we just need to calculate the similarity between ourselves and the
    other users we''ve starred. We''ll do that now using the `pearsonr` function which
    we''ll need to import from SciPy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will generate output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/08e99592-0732-40f3-b1f3-5dba3b2360fa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'What we''ve just done is compare our vector, the last one in the `DataFrame`,
    to every other user''s vector to generate a centered cosine similarity (Pearson
    correlation coefficient). Some values are by necessity `NaN`, as they''ve starred
    no repositories, and hence result in division by zero in the calculation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now sort these values to return the index of the users who are most
    similar:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will result in output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4e0c87e0-5c41-4154-8298-c1b8c54a0d1c.png)'
  prefs: []
  type: TYPE_IMG
- en: So there we have it, those are the most similar users, and hence the ones that
    we can use to recommend repositories we might enjoy. Let's take a look at these
    users and what they have starred that we might like.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can ignore that first user with a perfect similarity score; that''s our
    own repository. Going down the list, the three nearest matches are user 6, user
    42, and user 116\. Let''s look at each:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will result in output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7e4949d8-0add-4d51-83f2-e9c940281dba.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take a look at who this is and their repository. From [https://github.com/cchi](https://github.com/cchi),
    I can see who the repository belongs to the following user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4171a7e8-7065-45b6-98ce-4464443fc815.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is actually Charles Chi, a former colleague of mine from Bloomberg, so
    this is no surprise. Let''s see what he has starred:'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of ways to do this; we can either use our code, or just
    click under their picture on stars. Let''s do both for this one, just to compare
    and make sure everything matches up. First, let''s do it via code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b2363349-f1b3-4e15-acab-0ad246dfbb49.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We see 30 starred repositories. Let''s compare those to the ones from GitHub''s
    site:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a67bbc65-7c4e-4a76-9d6c-c8ffc54cfa5a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here we can see they''re identical, and you''ll notice you can ID the repositories
    that we''ve both starred: they are the ones labelled Unstar.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unfortunately, with just 30 starred repositories, there aren't a lot of repositories
    to generate recommendations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next user in terms of similarity is 42, Artem Golubin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e826b79-e99b-468e-9bf5-ea87d04475a1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And his GitHub profile below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2fd46a81-dbcc-4aec-9dae-74db19f2f4c1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here we see the repositories he has starred:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/688655ef-721a-4503-8cb7-d90fd6ca56c1.png)'
  prefs: []
  type: TYPE_IMG
- en: Artem has starred over 500 repositories, so there are definitely some recommendations
    to be found there.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'And finally, let''s look at the third most similar user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/80d07cbf-9bc3-4acc-8fc5-026dec03b83a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This user, Kevin Markham, has starred around 60 repositories:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d7801ab7-37c5-4a81-b8df-0bd6a2a39ef8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see the starred repositories in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2f7d43f9-fa57-4307-94f9-780a6c73fbdf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is definitely fertile ground for generating recommendations. Let''s now
    do just that; let''s use the links from these three to produce some recommendations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to gather the links to the repositories they''ve starred and that I
    haven''t. We''ll create a `DataFrame` that has the repositories I''ve starred
    as well as the three most similar users to me:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0c9c7b37-46ef-45c0-acd3-6edcdb94bb6a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Don''t worry if it looks like it''s all zeros; this is a sparse matrix so most
    will be 0\. Let''s see whether there are any repositories we''ve all starred:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fa2dbf18-0845-4435-92e9-f9c1b1db9616.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, we all seem to love scikit-learn and machine learning repositories—no
    surprise there. Let''s see what they might have all starred that I missed. We''ll
    start by creating a frame that excludes me, and then we''ll query it for commonly
    starred repositories:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aa86dd2f-5706-4d00-88d5-4c6329d650de.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Okay, so it looks like I haven''t been missing anything super obvious. Let''s
    see if there any repositories that at least two out of three users starred. To
    find this, we''ll just sum across the rows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will result in output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9160ebd7-e513-4038-ad8a-8eff7cd4c253.png)'
  prefs: []
  type: TYPE_IMG
- en: This looks promising. There are lots of good ML and AI repositories, and I'm
    honestly ashamed I never starred fuzzywuzzy as I use that quite frequently.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, I have to say I'm impressed with the results. These are definitely
    repositories that interest me, and I'll be checking them out.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we've generated the recommendations using collaborative filtering and
    done some light additional filtering using aggregation. If we wanted to go further,
    we could order the recommendation based upon the total number of stars they received.
    This could be achieved by making another call to the GitHub API. There's an endpoint
    that provides this information.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing we could do to improve the results is to add in a layer of content-based
    filtering. This is the hybridization step we discussed earlier. We would need
    to create a set of features from our own repository that was indicative of the
    types of things we would be interested in. One way to do this would be to create
    a feature set by tokenizing the names of the repositories we have starred along
    with their descriptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a look at my starred repositories:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f755b271-db4e-45e1-9e4f-8aa9779c097b.png)'
  prefs: []
  type: TYPE_IMG
- en: As you might imagine, this would generate a set of word features that we could
    use to vet the repositories of those we found using collaborative filtering. This
    would include a lot of words such as *Python*, *Machine Learning*, and *Data Science*.
    This would ensure that users who are less similar to ourselves are still providing
    recommendations that are based on our own interests. It would also reduce the
    serendipity of the recommendations, which is something to consider. Perhaps there's
    something unlike anything I have currently that I would love to see. It's certainly
    a possibility.
  prefs: []
  type: TYPE_NORMAL
- en: What would that content-based filtering step look like in terms of a DataFrame?
    The columns would be word features (n-grams) and the rows would be the repositories
    generated from our collaborative filtering step. We would just run the similarity
    process once again using our own repository for comparison.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we learned about recommendation engines. We learned about
    the two primary types of systems in use today: collaborative filtering and content-based
    filtering. We also learned how they can be used together to form a hybrid system.
    We also discussed the pros and cons of each type of system. And finally, we learned
    step by step how to build a recommendation engine from scratch using the GitHub
    API.'
  prefs: []
  type: TYPE_NORMAL
- en: I hope you build your own recommendation engine using the guidance in this chapter,
    and I hope you find resources that are useful to you. I know I've found a number
    of things I will certainly be using. Best of luck to you on your journey!
  prefs: []
  type: TYPE_NORMAL
