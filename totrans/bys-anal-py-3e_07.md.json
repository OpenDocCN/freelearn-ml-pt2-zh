["```py\nnp.random.seed(42) \nx = np.linspace(0, 1, 10) \ny = np.random.normal(0, 1, len(x)) \nplt.plot(x, y, 'o-', label='the first one') \ny = np.zeros_like(x) \n\nfor i in range(len(x)): \n    y[i] = np.random.normal(y[i-1], 1) \nplt.plot(x, y, 'o-', label='the second one') \nplt.legend()\n```", "```py\ndef exp_quad_kernel(x, knots, ℓ=1): \n    \"\"\"exponentiated quadratic kernel\"\"\" \n    return np.array([np.exp(-(x-k)**2 / (2*ℓ**2)) for k in knots])\n```", "```py\n# A one-dimensional column vector of inputs. \nX = x[:, None] \n\nwith pm.Model() as model_reg: \n    # hyperprior for lengthscale kernel parameter \n    ℓ = pm.InverseGamma(\"ℓ\", 7, 17) \n    # instanciate a covariance function \n    cov = pm.gp.cov.ExpQuad(1, ls=ℓ) \n    # instanciate a GP prior \n    gp = pm.gp.Marginal(cov_func=cov) \n    σ = pm.HalfNormal('σ', 25) \n    # Class representing that the observed data is a GP plus Gaussian noise \n    y_pred = gp.marginal_likelihood('y_pred', X=X, y=y, sigma=σ) \n\n    idata_reg = pm.sample()\n```", "```py\nX_new = np.linspace(np.floor(x.min()), np.ceil(x.max()), 100)[:,None] \nwith model_reg: \n    f_pred = gp.conditional('f_pred', X_new)\n```", "```py\nwith model_reg: \n    idata_subset = idata_reg.sel(draw=slice(0, None, 100)) \n    pred_samples = pm.sample_posterior_predictive(idata_subset, \n                                                  var_names=[\"f_pred\"]) \n\nf_pred = (pred_samples. \n         posterior_predictive.stack(samples=(\"chain\", \"draw\"))['f_pred']. \n         values)\n```", "```py\npz.maxent(pz.InverseGamma(), 1, 5, 0.95)\n```", "```py\nwith pm.Model() as model_iris: \n    ℓ = pm.InverseGamma('ℓ', *get_ig_params(x_1)) \n    cov = pm.gp.cov.ExpQuad(1, ℓ) \n    gp = pm.gp.Latent(cov_func=cov) \n    f = gp.prior(\"f\", X=X_1) \n    # logistic inverse link function and Bernoulli likelihood \n    y_ = pm.Bernoulli(\"y\", p=pm.math.sigmoid(f), observed=y) \n    idata_iris = pm.sample()\n```", "```py\nwith pm.Model() as model_iris2: \n    ℓ = pm.InverseGamma('ℓ', *get_ig_params(x_1)) \n    c = pm.Normal('c', x_1.min()) \n    τ = pm.HalfNormal('τ', 5) \n    cov = (pm.gp.cov.ExpQuad(1, ℓ) + \n           τ * pm.gp.cov.Linear(1, c) + \n           pm.gp.cov.WhiteNoise(1E-5)) \n    gp = pm.gp.Latent(cov_func=cov) \n    f = gp.prior(\"f\", X=X_1) \n    # logistic inverse link function and Bernoulli likelihood \n    y_ = pm.Bernoulli(\"y\", p=pm.math.sigmoid(f), observed=y) \n    idata_iris2 = pm.sample()\n```", "```py\nwith pm.Model() as model_space_flu: \n    ℓ = pm.InverseGamma('ℓ', *get_ig_params(age)) \n    cov = pm.gp.cov.ExpQuad(1, ℓ) + pm.gp.cov.WhiteNoise(1E-5) \n    gp = pm.gp.Latent(cov_func=cov) \n    f = gp.prior('f', X=age) \n    y_ = pm.Bernoulli('y', p=pm.math.sigmoid(f), observed=space_flu) \n    idata_space_flu = pm.sample()\n```", "```py\n# discretize data \nyears = int((coal_df.max() - coal_df.min()).iloc[0]) \nbins = years // 4 \nhist, x_edges = np.histogram(coal_df, bins=bins) \n# Compute the location of the centers of the discretized data \nx_centers = x_edges[:-1] + (x_edges[1] - x_edges[0]) / 2 \n# xdata needs to be 2D for BART \nx_data = x_centers[:, None] \n# express data as the rate number of disasters per year \ny_data = hist\n```", "```py\nwith pm.Model() as model_coal: \n    ℓ = pm.InverseGamma('ℓ', *get_ig_params(x_edges)) \n    cov = pm.gp.cov.ExpQuad(1, ls=ℓ) + pm.gp.cov.WhiteNoise(1E-5) \n    gp = pm.gp.Latent(cov_func=cov) \n    f = gp.prior('f', X=x_data) \n    y_pred = pm.Poisson('y_pred', mu=pm.math.exp(f), observed=y_data) \n    idata_coal = pm.sample()\n```", "```py\n# discretize spatial data \nbins = 20 \nhist, x1_edges, x2_edges = np.histogram2d( \n    rw_df[1].values, rw_df[0].values, bins=bins) \n# compute the location of the centers of the discretized data \nx1_centers = x1_edges[:-1] + (x1_edges[1] - x1_edges[0]) / 2 \nx2_centers = x2_edges[:-1] + (x2_edges[1] - x2_edges[0]) / 2 \n# arrange xdata into proper shape for GP \nx_data = [x1_centers[:, None], x2_centers[:, None]] \n# arrange ydata into proper shape for GP \ny_data = hist.flatten().astype(int)\n```", "```py\nwith pm.Model() as model_rw: \n    ℓ = pm.InverseGamma('ℓ', *get_ig_params(x_data), shape=2) \n    cov_func1 = pm.gp.cov.ExpQuad(1, ls=ℓ[0]) \n    cov_func2 = pm.gp.cov.ExpQuad(1, ls=ℓ[1]) \n\n    gp = pm.gp.LatentKron(cov_funcs=[cov_func1, cov_func2]) \n    f = gp.prior('f', Xs=x_data) \n\n    y = pm.Poisson('y', mu=pm.math.exp(f), observed=y_data) \n    idata_rw = pm.sample()\n```", "```py\nclass ExpQuadHaversine(pm.gp.cov.Stationary): \n    def __init__(self, input_dims, ls, ls_inv=None, r=6371, active_dims=None): \n        super().__init__(input_dims, ls=ls, ls_inv=ls_inv, active_dims=active_dims) \n        self.r = r # earth radius in km \n\n    def haversine_distance(self, X): \n        lat = np.radians(X[:, 0]) \n        lon = np.radians(X[:, 1]) \n        latd = lat[:,None] - lat \n        lond = lon[:,None] - lon \n        d = pt.cos(lat[:,None]) * pt.cos(lat) \n        a = pt.sin(latd / 2)** 2 + d * pt.sin(lond / 2)** 2 \n        c = 2 * pt.arctan2(pt.sqrt(a), pt.sqrt(1 - a)) \n        return self.r * c \n\n    def full(self, X, _): \n        return pt.exp(-0.5 * self.haversine_distance(X)**2)\n```", "```py\nwith pm.Model() as model_islands: \n    η = pm.Exponential('η', 2) \n    ℓ = pm.InverseGamma('ℓ', *get_ig_params(islands_dist)) \n\n    cov = η * ExpQuadHaversine(2, ls=ℓ) \n    gp = pm.gp.Latent(cov_func=cov) \n    f = gp.prior('f', X=X) \n\n    *α* = pm.Normal('*α*', 0, 5) \n    *β* = pm.Normal('*β*', 0, 1) \n    μ = pm.math.exp(*α* + *β* * log_pop + f) \n    _ = pm.Poisson('tt_pred', μ, observed=total_tools) \n\n    idata_islands = pm.sample()\n```", "```py\nwith pm.Model() as model_hsgp: \n    ℓ = pm.InverseGamma('ℓ', *get_ig_params(X)) \n\n    cov = pm.gp.cov.ExpQuad(1, ls=ℓ) \n    gp = pm.gp.HSGP(m=[10], c=1.5, cov_func=cov) \n\n    f = gp.prior('f', X=X) \n    *α* = pm.HalfNormal('*α*', 1) \n    _ = pm.NegativeBinomial(\"obs\", np.exp(f), *α*, observed=y) \n\n    idata_hsgp = pm.sample()\n```", "```py\nbmb.Model(\"rented ∼ 0 + hsgp(hour, m=10, c=1.5)\", bikes, \n          family=\"negativebinomial\")\n```", "```py\nprior_gp = { \n    \"sigma\": bmb.Prior(\"Gamma\", mu=1, sigma=0.01), \n    \"ell\": bmb.Prior(\"InverseGamma\", **get_ig_params(X)) \n} \npriors = { \n    \"hsgp(hour, m=10, c=1.5)\": prior_gp, \n    \"alpha\": bmb.Prior(\"HalfNormal\", sigma=1) \n} \n\nmodel_hsb = bmb.Model(\"rented ∼ 0 + hsgp(hour, m=10, c=1.5)\", bikes, \n                      family=\"negativebinomial\", \n                      priors=priors) \n\nidata_hsb = model_hsb.fit()\n```"]