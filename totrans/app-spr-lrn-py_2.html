<html><head></head><body>
		<div id="_idContainer077" class="Content">
			<h1 id="_idParaDest-40"><em class="italics"><a id="_idTextAnchor041"/>Chapter 2</em></h1>
		</div>
		<div id="_idContainer078" class="Content">
			<h1 id="_idParaDest-41"><a id="_idTextAnchor042"/>Exploratory Data Analysis and Visualization</h1>
		</div>
		<div id="_idContainer079" class="Content">
			<h2>Learning Objectives</h2>
			<p>By the end of the chapter, you will be able to:</p>
			<ul>
				<li class="bullets">Explain the importance of data exploration and communicate the summary statistics of a dataset</li>
				<li class="bullets">Visualize patterns in missing values in data and be able to replace null values appropriately</li>
				<li class="bullets">Identify continuous features and categorical features</li>
				<li class="bullets">Visualize distributions of values across individual variables</li>
				<li class="bullets">Describe and analyze relationships between different types of variables using correlation and visualizations</li>
			</ul>
			<p>This chapter takes us through how to perform exploration and analysis on a new dataset.</p>
		</div>
		<div id="_idContainer118" class="Content">
			<h2 id="_idParaDest-42"><a id="_idTextAnchor043"/><a id="_idTextAnchor044"/>Introduction</h2>
			<p>Say we have a problem statement that involves predicting whether a particular earthquake caused a tsunami or not. How do we decide what model to use? What do we know about the data we have? Nothing! But if we don't know and understand our data, chances are we'll end up building a model that's not very interpretable or reliable.</p>
			<p>When it comes to data science, it's important to have a thorough understanding of the data we're dealing with, in order to generate features that are highly informative and, consequently, to build accurate and powerful models.</p>
			<p>In order to gain this understanding, we perform an exploratory analysis on the data to see what the data can tell us about the relationships between the features and the target variable. Getting to know our data will even help us interpret the model we build and identify ways we can improve its accuracy.</p>
			<p>The approach we take to achieve this is to allow the data to reveal its structure or model, which helps gain some new, often unsuspected, insight into the data. Let's learn more about this approach.</p>
			<h3 id="_idParaDest-43"><a id="_idTextAnchor045"/>Exploratory Data Analysis (EDA)</h3>
			<p><strong class="keyword">Exploratory data analysis</strong> (<strong class="keyword">EDA</strong>) is defined as an approach to analyzing datasets to summarize their main characteristics, often with visual methods.</p>
			<p>The purpose of EDA is to:</p>
			<ul>
				<li>Discover patterns within a dataset</li>
				<li>Spot anomalies</li>
				<li>Form hypotheses about the behavior of data</li>
				<li>Validate assumptions</li>
			</ul>
			<p>Everything from basic summary statistics to complex visualizations help us gain an intuitive understanding of the data itself, which is highly important when it comes to forming new hypotheses about the data and uncovering what parameters affect the target variable. Often, discovering how the target variable varies across a single feature gives us an indication of how important a feature might be, and a variation across a combination of several features helps us come up with ideas for new informative features to engineer.</p>
			<p>Most exploration and visualization is intended to understand the relationship between the features and the target variable. This is because we want to find out what relationships exist (or don't exist) between the data we have and the values we want to predict.</p>
			<p>A very basic domain knowledge is usually necessary to be able to understand both the problem statement itself as well as what the data is telling us. In this chapter, we'll look at the ways we can get to know more about the data we have by analyzing the features we have.</p>
			<p>EDA can tell us about:</p>
			<ul>
				<li>Features that are unclean, have missing values, or have outliers</li>
				<li>Features that are informative and are a good indicator of the target</li>
				<li>The kind of relationships features have with the target</li>
				<li>Further features that the data might need that we don't already have</li>
				<li>Edge cases you might need to account for separately</li>
				<li>Filters you might need to apply on the dataset</li>
				<li>The presence of incorrect or fake data points</li>
			</ul>
			<p>Now that we've looked at why EDA is important and what it can tell us, let's talk about what exactly EDA involves. EDA can involve anything from looking at basic summary statistics to visualizing complex trends over multiple variables. However, even simple statistics and plots can be powerful tools, as they may reveal important facts about the data that could change our modeling perspective. When we see plots representing data, we are able to easily detect trends and patterns, compared to just raw data and numbers. These visualizations further allow us to ask questions such as "How?" and "Why?", and form hypotheses about the dataset that can be validated by further visualizations. This is a continuous process that leads to a deeper understanding of the data. This chapter will introduce you to some of the basic tools that can be used to explore any dataset while keeping in mind the ultimate problem statement.</p>
			<p>We'll start by walking through some basic summary statistics and how to interpret them, followed by a section on finding, analyzing, and dealing with missing values. Then we'll look at univariate relationships, that is, distributions and the behavior of individual variables. This will be followed by the final section on exploring relationships between variables. In this chapter, you will be introduced to types of plots that can be used to gain a basic overview of the dataset and its features, as well as how to gain insights by creating visualizations that combine several features, and we'll then work through some examples on how they can be used.</p>
			<p>The dataset that we will use for our exploratory analysis and visualizations has been taken from the <em class="italics">Significant Earthquake Database</em> from NOAA, available as a public dataset on Google BigQuery (<strong class="inline">table ID: 'bigquery-public-data.noaa_significant_earthquakes.earthquakes'</strong>). We will be using a subset of the columns available, the metadata for which is available at <a href="https://console.cloud.google.com/bigquery?project=packt-data&amp;folder&amp;organizationId&amp;p=bigquery-public-data&amp;d=noaa_significant_earthquakes&amp;t=earthquakes&amp;page=table">https://console.cloud.google.com/bigquery?project=packt-data&amp;folder&amp;organizationId&amp;p=bigquery-public-data&amp;d=noaa_significant_earthquakes&amp;t=earthquakes&amp;page=table</a>, and loading it into a pandas DataFrame to perform the exploration. We'll primarily be using Matplotlib for most of our visualizations, along with Seaborn and Missingno for some. It is to be noted, however, that Seaborn merely provides a wrapper over Matplotlib's functionalities, so anything that is plotted using Seaborn can also be plotted using Matplotlib. We'll try to keep things interesting by mixing up visualizations from both libraries.</p>
			<p>The exploration and analysis will be conducted keeping in mind a sample problem statement: <em class="italics">Given the data we have, we want to predict whether an earthquake caused a tsunami or not</em>. This will be a classification problem (more on this in <em class="italics">Chapter 4</em>, <em class="italics">Classification</em>) where the target variable is the <strong class="inline">flag_tsunami</strong> column.</p>
			<h3 id="_idParaDest-44"><a id="_idTextAnchor046"/>Exercise 10: Importing Libraries for Data Exploration</h3>
			<p>Before we begin, let's first import the required libraries, which we will be using for most of our data manipulations and visualizations:</p>
			<ol>
				<li>In a Jupyter notebook, import the following libraries:<p class="snippet">import json</p><p class="snippet">import pandas as pd</p><p class="snippet">import numpy as np</p><p class="snippet">import missingno as msno</p><p class="snippet">from sklearn.impute import SimpleImputer</p><p class="snippet">%matplotlib inline</p><p class="snippet">import matplotlib.pyplot as plt</p><p class="snippet">import seaborn as sns</p><p>The <strong class="inline">%matplotlib inline</strong> command allows Jupyter to display the plots inline within the notebook itself.</p></li>
				<li>We can also read in the metadata containing the data types for each column, which are stored in the form of a JSON file. Do this using the following command. This command opens the file in readable format and uses the <strong class="inline">json</strong> library to read the file into a dictionary:<p class="snippet">with open('dtypes.json', 'r') as jsonfile:</p><p class="snippet">    dtyp = json.load(jsonfile)</p></li>
			</ol>
			<p>Now, let's get started.</p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor047"/>Summary Statistics and Central Values</h2>
			<p>In order to find out what our data really looks like, we use a technique known as <strong class="keyword">data profiling</strong>. This is defined as the process of examining the data available from an existing information source (for example, a database or a file) and collecting statistics or informative summaries about that data. The goal is to make sure that you understand your data well and are able to identify any challenges that the data may pose early on in the project, which is done by summarizing the dataset and assessing its structure, content, and quality.</p>
			<p>Data profiling includes collecting descriptive statistics and data types. Here are a few commands that are commonly used to get a summary of a dataset:</p>
			<ul>
				<li><strong class="inline">data.info()</strong>: This command tells us how many non-null values there are there in each column, along with the data type of the values (non-numeric types are represented as <strong class="inline">object</strong> types).</li>
				<li><strong class="inline">data.describe()</strong>: This gives us basic summary statistics for all the numerical columns in the DataFrame, such as the count of non-null values, minimum and maximum, the mean and standard deviation, and the quarter-wise percentiles for all numerical features. If there are any string-type features, it does not include a summary of those.</li>
				<li><strong class="inline">data.head()</strong> and <strong class="inline">data.tail()</strong>: These commands display the first five and last five rows of the DataFrame respectively. While the previous commands give us a general idea of the dataset, it is a good idea to get a closer look at the actual data itself, which can be done using these commands.</li>
			</ul>
			<h3 id="_idParaDest-46"><a id="_idTextAnchor048"/>Standard Deviation</h3>
			<p>The standard deviation represents how widespread the distribution of the values of <em class="italics">x</em> are.</p>
			<p>For a set of numerical values, xi, the standard deviation is given by:</p>
			<div>
				<div id="_idContainer080" class="IMG---Figure">
					<img src="image/C12622_02_01.jpg" alt="Figure 2.1: Standard deviation equation"/>
				</div>
			</div>
			<h6>Figure 2.1: Standard deviation equation</h6>
			<p>Here, 𝝈 is the standard deviation, <em class="italics">N</em> is the number of data points, and 𝝁 is the mean.</p>
			<p>Say we have a set of 10 values, <em class="italics">x = [0,1,1,2,3,4,2,2,0,1]</em>. The mean, 𝝁, will be the sum of these values, divided by 10. That is, 𝝁 = 1.6:</p>
			<div>
				<div id="_idContainer081" class="IMG---Figure">
					<img src="image/C12622_02_02.jpg" alt="Figure 2.2: Mean square values for x"/>
				</div>
			</div>
			<h6>Figure 2.2: Mean square values for x</h6>
			<p>Then, standard deviation = sqrt(14.4/10) = 1.2.</p>
			<h3 id="_idParaDest-47"><a id="_idTextAnchor049"/>Percentiles</h3>
			<p>For a set of values, the <em class="italics">n</em><em class="italics">th</em> percentile is equal to the value that is greater than <em class="italics">n%</em> of values in the set. For example, the 50<em class="italics">th</em> percentile is the value in the dataset that has as many values greater than it as it does that are less than it. Additionally, the fiftieth percentile of a dataset is also known as its median, and the twenty-fifth and seventy-fifth percentiles are also known as the lower and upper quartiles.</p>
			<p>Say we have the same set of 10 values as earlier, <em class="italics">x = [0,1,1,2,3,4,2,2,0,1]</em>. Let's first sort this list of values. Upon sorting, we have <em class="italics">x = [0,0,1,1,1,2,2,2,3,4]</em>. To find the twenty-fifth percentile, let's first calculate the index at which the value occurs: <em class="italics">i = (p/100) * n)</em>, where <em class="italics">p = 25</em> and <em class="italics">n = 10</em>. Then, <em class="italics">i = 2.5</em>.</p>
			<p>Since <em class="italics">i</em> is not an integer, we round it up to 3 and take the third element in the list as the twenty-fifth percentile. The twenty-fifth percentile in the given list would then be <em class="italics">1</em>, which is the third element in our sorted list.</p>
			<h3 id="_idParaDest-48"><a id="_idTextAnchor050"/>Exercise 11: Summary Statistics of Our Dataset</h3>
			<p>In this exercise, we will use the summary statistics functions we read about previously to get a basic idea of our dataset:</p>
			<ol>
				<li value="1">Read the earthquakes data into a <strong class="inline">data</strong> pandas DataFrame and use the <strong class="inline">dtyp</strong> dictionary we read using the <strong class="inline">json</strong> library in the previous exercise to specify the data types of each column in the CSV:<p class="snippet">data = pd.read_csv('earthquake_data.csv', dtype=dtyp)</p></li>
				<li>Use the <strong class="inline">data.info()</strong> function to get an overview of the dataset:<p class="snippet">data.info()</p><p>The output will be as follows:</p><div id="_idContainer082" class="IMG---Figure"><img src="image/C12622_02_03.jpg" alt="Figure 2.3: Overview of the dataset"/></div><h6>Figure 2.3: Overview of the dataset</h6></li>
				<li>Print the first five and last five rows of the dataset. The first five rows are printed as follows:<p class="snippet">data.head()</p><p>The output will be as shown here:</p><div id="_idContainer083" class="IMG---Figure"><img src="image/C12622_02_04.jpg" alt="Figure 2.4: The first five rows"/></div><h6>Figure 2.4: The first five rows</h6><p>The last five rows are printed as follows:</p><p class="snippet">data.tail()</p><p>The output will be as shown here:</p><div id="_idContainer084" class="IMG---Figure"><img src="image/C12622_02_05.jpg" alt="Figure 2.5: The last five rows"/></div><h6>Figure 2.5: The last five rows</h6><p>We can see in these outputs that there are 28 columns, but not all of them are displayed. Only the first 10 and last 10 columns are displayed, with the ellipses representing the fact that there are columns in between that are not displayed.</p></li>
				<li>Use <strong class="inline">data.describe()</strong> to find the summary statistics of the dataset. Run <strong class="inline">data.describe().T</strong>:<p class="snippet">data.describe().T</p><p>Here, <strong class="inline">.T</strong> indicates that we're taking a transpose of the DataFrame to which it is applied, that is, turning the columns into rows and vice versa. Applying it to the <strong class="inline">describe()</strong> function allows us to see the output more easily with each row in the transposed DataFrame now corresponding to the statistics for a single feature.</p><p>We should get an output like this:</p></li>
			</ol>
			<div>
				<div id="_idContainer085" class="IMG---Figure">
					<img src="image/C12622_02_06.jpg" alt="Figure 2.6: Summary statistics"/>
				</div>
			</div>
			<h6>Figure 2.6: Summary statistics</h6>
			<p>Notice here that the <strong class="inline">describe()</strong> function only shows the statistics for columns with numerical values. This is because we cannot calculate the statistics for the columns having non-numerical values.</p>
			<h2 id="_idParaDest-49">Miss<a id="_idTextAnchor051"/>ing Values</h2>
			<p>When there is no value (that is, a null value) recorded for a particular feature in a data point, we say the data is missing. Having missing values in a real dataset is inevitable; no dataset is ever perfect. However, it is important to understand why the data is missing, and if there is a factor that has affected the loss of data. Appreciating and recognizing this allows us to handle the remaining data in an appropriate manner. For example, if the data is missing randomly, then it's highly likely that the remaining data is still representative of the population. However, if the missing data is not random in nature and we assume that it is, it could bias our analysis and subsequent modeling.</p>
			<p>Let's look at the common reasons (or mechanisms) for missing data:</p>
			<ul>
				<li><strong class="keyword">Missing Completely at Random</strong> (<strong class="keyword">MCAR</strong>): Values in a dataset are said to be MCAR if there is no correlation whatsoever between the value missing and any other recorded variable or external parameter. This means that the remaining data is still representative of the population, though this is rarely the case and taking missing data to be completely random is usually an unrealistic assumption.<p>For example, in a study that involves determining the reason for obesity among K12 children, MCAR is when the parents forgot to take their kids to the clinic for the study.</p></li>
				<li><strong class="keyword">Missing at Random</strong> (<strong class="keyword">MAR</strong>): If the case where the data is missing is related to the data that was recorded rather than the data that was not, then the data is said to be MAR. Since it's unfeasible to statistically verify whether data is MAR, we'd have to depend on whether it's a reasonable possibility or not.<p>Using the K12 study, missing data in this case is due to parents moving to a different city, hence the children had to leave the study;  <em class="italics">missingness</em> has nothing to do with the study itself.</p></li>
				<li><strong class="keyword">Missing Not at Random</strong> (<strong class="keyword">MNAR</strong>): Data that is neither MAR nor MCAR is said to be MNAR. This is the case of a non-ignorable non-response, that is, the value of the variable that's missing is related to the reason it is missing.<p>Continuing with the example of the case study, data would be MNAR if the parents were offended by the nature of the study and did not want their children to be bullied, so they withdrew their kids from the study.</p></li>
			</ul>
			<h3 id="_idParaDest-50">Find<a id="_idTextAnchor052"/>ing Missing Values</h3>
			<p>So, now that we know why it's important to familiarize ourselves with the reasons behind why our data is missing, let's talk about how we can find these missing values in a dataset. For a pandas DataFrame, this is most commonly done using the <strong class="inline">.isnull()</strong> method on a DataFrame to create a mask of the null values (that is, a DataFrame of Boolean values) indicating where the null values exist—a <strong class="inline">True</strong> value at any position indicates a null value, while a <strong class="inline">False</strong> value indicates the existence of a valid value at that position.</p>
			<h4>Note</h4>
			<p class="callout">The <strong class="inline">.isnull()</strong> method can be used interchangeably with the <strong class="inline">.isna()</strong> method for pandas DataFrames. Both these methods do exactly the same thing—the reason there are two methods to do the same thing is because pandas DataFrames were originally based on R DataFrames, and hence have reproduced much of the syntax and ideas in the latter.</p>
			<p>It may not be immediately obvious whether the missing data is random or not: discovering the nature of missing values across features in a dataset is possible through two common visualization techniques:</p>
			<ul>
				<li><strong class="keyword">Nullity matrix</strong>: This is a data-dense display that lets us quickly visualize the patterns in data completion. It gives us a quick glance at how the null values within a feature (and across features) are distributed, how many there are, and how often they appear with other features.</li>
				<li><strong class="keyword">Nullity-correlation heatmap</strong>: This heatmap visually describes the nullity relationship (or a data completeness relationship) between each pair of features, that is, it measures how strongly the presence or absence of one variable affects the presence of another.<p>Akin to regular correlation, nullity correlation values range from -1 to 1: the former indicating that one variable appears when the other definitely does not, and the latter indicating the simultaneous presence of both variables. A value of 0 implies that one variable having a null value has no effect on the other being null.</p></li>
			</ul>
			<h3 id="_idParaDest-51">Exer<a id="_idTextAnchor053"/>cise 12: Visualizing Missing Values</h3>
			<p>Let's analyze the nature of the missing values by first looking at the count and percentage of missing values for each feature, then plotting a nullity matrix and correlation heatmap using the <strong class="inline">missingno</strong> library in Python:</p>
			<ol>
				<li value="1">Calculate the count and percentage of missing values in each column and arrange these in decreasing order. We will use the <strong class="inline">.isnull()</strong> function on the DataFrame to get a mask. The count of null values in each column can then be found using the <strong class="inline">.sum()</strong> function over the mask DataFrame. Similarly, the fraction of null values can be found using <strong class="inline">.mean()</strong> over the mask DataFrame and multiplied by 100 to convert it into a percentage.<p>Then, we combine the total and percentage of null values into a single DataFrame using the <strong class="inline">pd.concat()</strong> function, and subsequently sort the rows by percentage of missing values and print the DataFrame:</p><p class="snippet">mask = data.isnull()</p><p class="snippet">total = mask.sum()</p><p class="snippet">percent = 100*mask.mean()</p><p class="snippet">missing_data = pd.concat([total, percent], axis=1,join='outer',</p><p class="snippet">               keys=['count_missing', 'perc_missing'])</p><p class="snippet">missing_data.sort_values(by='perc_missing', ascending=False, inplace=True)</p><p class="snippet">missing_data</p><p>The output will be as follows:</p><div id="_idContainer086" class="IMG---Figure"><img src="image/C12622_02_07.jpg" alt="Figure 2.7: Count and percentage of missing values in each column"/></div><h6>Figure 2.7: Count and percentage of missing values in each column</h6><p>Here, we can see that the <strong class="inline">state</strong>, <strong class="inline">total_damage_millions_dollars</strong>, and <strong class="inline">damage_millions_dollars</strong> columns have over 90% missing values, which means that data for less than 10% of data points in the dataset are available for these columns. On the other hand, <strong class="inline">year</strong>, <strong class="inline">flag_tsunami</strong>, <strong class="inline">country</strong>, and <strong class="inline">region_code</strong> have no missing values.</p></li>
				<li>Plot the nullity matrix. First, we find the list of columns that have any null values in them using the <strong class="inline">.any()</strong> function on the mask DataFrame from the previous step. Then, we use the <strong class="inline">missingno</strong> library to plot the nullity matrix for a random sample of 500 data points from our dataset, for only those columns that have missing values:<p class="snippet">nullable_columns = data.columns[mask.any()].tolist()</p><p class="snippet">msno.matrix(data[nullable_columns].sample(500))</p><p class="snippet">plt.show()</p><p>The output will be as follows:</p><div id="_idContainer087" class="IMG---Figure"><img src="image/C12622_02_08.jpg" alt="Figure 2.8: The nullity matrix"/></div><h6>Figure 2.8: The nullity matrix</h6><p>Here, black lines represent non-nullity while the white lines indicate the presence of a null value in that column. At a glance, <strong class="inline">location_name</strong> appears to be completely populated (we know from the previous step that there is, in fact, only one missing value in this column), while <strong class="inline">latitude</strong> and <strong class="inline">longitude</strong> seem mostly complete, but spottier.</p><p>The spark line at the right summarizes the general shape of the data completeness and points out the rows with the maximum and minimum nullity in the dataset.</p></li>
				<li>Plot the nullity correlation heatmap. We will plot the nullity correlation heatmap using the <strong class="inline">missingno</strong> library for our dataset, for only those columns that have missing values:<p class="snippet">msno.heatmap(data[nullable_columns], figsize=(18,18))</p><p class="snippet">plt.show()</p><p>The output will be as follows:</p></li>
			</ol>
			<div>
				<div id="_idContainer088" class="IMG---Figure">
					<img src="image/C12622_02_09.jpg" alt="Figure 2.9: The nullity correlation heatmap"/>
				</div>
			</div>
			<h6>Figure 2.9: The nullity correlation heatmap</h6>
			<p>Here, we can also see some boxes labeled <strong class="bold">&lt;1</strong> or <strong class="bold">&gt;-1</strong>: this just means that the correlation value in those cases are close to being exactingly negative or positive, but still not quite perfectly so. We can see a value of <strong class="bold">&lt;1</strong> between <strong class="inline">injuries</strong> and <strong class="inline">total_injuries</strong>, which tells us that there are a few records that have one or the other, but not both. These types of cases will require special attention—if the correlation between the values of the variables themselves is high, it means that having both is not a value and one of the two can be dropped.</p>
			<h3 id="_idParaDest-52">Imputat<a id="_idTextAnchor054"/>ion Strategies for Missing Values</h3>
			<p>There are multiple ways of dealing with missing values in a column. The simplest way is to simply delete rows having missing values; however, this can result in the loss of valuable information from other columns. Another option is to impute the data, that is, replace the missing values with a valid value inferred from the known part of the data. The common ways in which this can be done are listed here:</p>
			<ul>
				<li>Create a new value that is distinct from the other values to replace the missing values in the column so as to differentiate those rows altogether. Then, use a non-linear machine learning algorithm (such as ensemble models or support vectors) that can separate the values out.</li>
				<li>Use an appropriate central value from the column (mean, median, or mode) to replace the missing values.</li>
				<li>Use a model (such as a K-nearest neighbors or a Gaussian mixture model) to learn the best value with which to replace the missing values.</li>
			</ul>
			<p>Python has a few functions that are useful for replacing null values in a column with a static value. One way to do this is using the inherent pandas <strong class="inline">.fillna(0)</strong> function: there is no ambiguity in imputation here—the static value with which to substitute the null data point in the column is the argument being passed to the function (the value in the brackets).</p>
			<p>However, if the number of null values in a column is significant and it's not immediately obvious what the appropriate central value is that can be used to replace each null value, then we can either delete the rows having null values or delete the column altogether from the modeling perspective, as it may not add any significant value. This can be done by using the <strong class="inline">.dropna()</strong> function on the DataFrame. The parameters that can be passed to the function are:</p>
			<ul>
				<li><strong class="inline">axis</strong>: This defines whether to drop rows or columns, which is determined by assigning the parameter a value of 0 or 1 respectively.</li>
				<li><strong class="inline">how</strong>: A value of <strong class="inline">all</strong> or <strong class="inline">any</strong> can be assigned to this parameter to indicate whether the row/column should contain all null values to drop the column, or whether to drop the column if there is at least one null value.</li>
				<li><strong class="inline">thresh</strong>: This defines the minimum number of null values the row/column should have in order to be dropped.</li>
			</ul>
			<p>Additionally, if an appropriate replacement for a null value for a categorical feature cannot be determined, a possible alternative to deleting the column is to create a new category in the feature that can represent the null values.</p>
			<h4>Note</h4>
			<p class="callout">If it is immediately obvious how a null value for a column can be replaced from an intuitive understanding or domain knowledge, then we can replace the value on the spot. In many cases, however, such inferences become more obvious at later stages in the exploration process. In these cases, we can substitute null values as and when we find an appropriate way to do so.</p>
			<h3 id="_idParaDest-53">Exercis<a id="_idTextAnchor055"/>e 13: Imputation Using pandas</h3>
			<p>Let's look at missing values and replace them with zeros in time-based (continuous) features having at least one null value (month, day, hour, minute, and second). We do this because for cases where we do not have recorded values, it would be safe to assume that the events take place at the beginning of the time duration.</p>
			<ol>
				<li value="1">Create a list containing the names of the columns whose values we want to impute:<p class="snippet">time_features = ['month', 'day', 'hour', 'minute', 'second']</p></li>
				<li>Impute the null values using <strong class="inline">.fillna()</strong>. We will replace the missing values in these columns with <strong class="inline">0</strong> using the inherent pandas <strong class="inline">.fillna()</strong> function and pass <strong class="inline">0</strong> as an argument to the function:<p class="snippet">data[time_features] = data[time_features].fillna(0)</p></li>
				<li>Use the <strong class="inline">.info()</strong> function to view null value counts for the imputed columns:<p class="snippet">data[time_features].info()</p><p>The output will be as follows:</p></li>
			</ol>
			<div>
				<div id="_idContainer089" class="IMG---Figure">
					<img src="image/C12622_02_10.jpg" alt="Figure 2.10: Null value counts"/>
				</div>
			</div>
			<h6>Figure 2.10: Null value counts</h6>
			<p>As we can see now, all values for our features in the DataFrame are now non-null.</p>
			<h3 id="_idParaDest-54">Exercise<a id="_idTextAnchor056"/> 14: Imputation Using scikit-learn</h3>
			<p>Let's replace the null values in the description-related categorical features using scikit-learn's <strong class="inline">SimpleImputer</strong> class. In <em class="italics">Exercise 12: Visualizing Missing Values</em>, we saw that almost all of these features comprised more than 50% of null values in the data. Replacing these null values with a central value might bias any model we try to build using the features, deeming them irrelevant. Let's instead replace the null values with a separate category, having value <strong class="inline">NA</strong>:</p>
			<ol>
				<li value="1">Create a list containing the names of the columns whose values we want to impute:<p class="snippet">description_features = [</p><p class="snippet">    'injuries_description', 'damage_description',</p><p class="snippet">    'total_injuries_description', 'total_damage_description'</p><p class="snippet">]</p></li>
				<li>Create an object of the <strong class="inline">SimpleImputer</strong> class. Here, we first create an <strong class="inline">imp</strong> object of the <strong class="inline">SimpleImputer</strong> class and initialize it with parameters that represent how we want to impute the data. The parameters we will pass to initialize the object are:<p><strong class="inline">missing_values</strong>: This is the placeholder for the missing values, that is, all occurrences of the values in the <strong class="inline">missing_values</strong> parameter will be imputed.</p><p><strong class="inline">strategy</strong>: This is the imputation strategy, which can be one of <strong class="inline">mean</strong>, <strong class="inline">median</strong>, <strong class="inline">most_frequent</strong> (that is, the mode), or <strong class="inline">constant</strong>. While the first three can only be used with numeric data and will replace missing values using the specified central value along each column, the last one will replace missing values with a constant as per the <strong class="inline">fill_value</strong> parameter.</p><p><strong class="inline">fill_value</strong>: This specifies the value with which to replace all occurrences of <strong class="inline">missing_values</strong>. If left to the default, the imputed value will be <strong class="inline">0</strong> when imputing numerical data and the <strong class="inline">missing_value</strong> string for strings or object data types:</p><p class="snippet">imp = SimpleImputer(missing_values=np.nan, strategy='constant', fill_value='NA')</p></li>
				<li>Perform the imputation. We will use <strong class="inline">imp.fit_transform()</strong> to actually perform the imputation. It takes the DataFrame with null values as input and returns the imputed DataFrame:<p class="snippet">data[description_features] = imp.fit_transform(data[description_features])</p></li>
				<li>Use the <strong class="inline">.info()</strong> function to view null value counts for the imputed columns:<p class="snippet">data[description_features].info()</p><p>The output will be as follows:</p></li>
			</ol>
			<div>
				<div id="_idContainer090" class="IMG---Figure">
					<img src="image/C12622_02_11.jpg" alt="Figure 2.11: The null value counts"/>
				</div>
			</div>
			<h6>Figure 2.11: The null value counts</h6>
			<h3 id="_idParaDest-55">Exercise <a id="_idTextAnchor057"/>15: Imputation Using Inferred Values</h3>
			<p>Let's replace the null values in the continuous <strong class="inline">damage_millions_dollars</strong> feature with information from the categorical <strong class="inline">damage_description</strong> feature. Although we may not know the exact dollar amount that was incurred, the categorical feature gives us information on the range of the amount that was incurred due to damage from the earthquake:</p>
			<ol>
				<li value="1">Find how many rows have null <strong class="inline">damage_millions_dollars</strong> values, and how many of those have non-null <strong class="inline">damage_description</strong> values:<p class="snippet">print(data[pd.isnull(data.damage_millions_dollars)].shape[0])</p><p class="snippet">print(data[pd.isnull(data.damage_millions_dollars) &amp; (data.damage_description != 'NA')].shape[0])</p><p>The output will be as follows:</p><div id="_idContainer091" class="IMG---Figure"><img src="image/C12622_02_12.jpg" alt=""/></div><h6>Figure 2.12: Count of rows with null values</h6><p>As we can see, 3,849 of 5,594 null values can be easily substituted with the help of another variable.</p></li>
				<li>Find the mean <strong class="inline">damage_millions_dollars</strong> value for each category. Since each of the categories in <strong class="inline">damage_description</strong> represent a range of values, we find the mean <strong class="inline">damage_millions_dollars</strong> value for each category from the non-null values already available. These provide a reasonable estimate for the most likely value for that category:<p class="snippet">category_means = data[['damage_description', 'damage_millions_dollars']].groupby('damage_description').mean()</p><p class="snippet">category_means</p><p>The output will be as follows:</p><div id="_idContainer092" class="IMG---Figure"><img src="image/C12622_02_13.jpg" alt="Figure 2.13: The mean damage_millions_dollars value for each category"/></div><h6>Figure 2.13: The mean damage_millions_dollars value for each category</h6></li>
				<li>Store the mean values as a dictionary. In this step, we will convert the DataFrame containing the mean values to a dictionary (a Python <strong class="inline">dict</strong> object) so that accessing them is convenient.<p>Additionally, since the value for the newly created <strong class="inline">NA</strong> category (the imputed value in the previous exercise) was <strong class="inline">NaN</strong> and the value for the <strong class="inline">0</strong> category was absent (no rows had <strong class="inline">damage_description</strong> equal to <strong class="inline">0</strong> in the dataset), we explicitly added these values in the dictionary as well:</p><p class="snippet">replacement_values = category_means.damage_millions_dollars.to_dict()</p><p class="snippet">replacement_values['NA'] = -1</p><p class="snippet">replacement_values['0'] = 0</p><p class="snippet">replacement_values</p><p>The output will be as follows:</p><div id="_idContainer093" class="IMG---Figure"><img src="image/C12622_02_14.jpg" alt="Figure 2.14: The dictionary of mean values"/></div><h6>Figure 2.14: The dictionary of mean values</h6></li>
				<li>Create a series of replacement values. For each value in the <strong class="inline">damage_description</strong> column, we map the categorical value onto the mean value using the <strong class="inline">map</strong> function. The <strong class="inline">.map()</strong> function is used to map the keys in the column to the corresponding values for each element from the <strong class="inline">replacement_values</strong> dictionary:<p class="snippet">imputed_values = data.damage_description.map(replacement_values)</p></li>
				<li>Replace null values in the column. We do this by using <strong class="inline">np.where</strong> as a ternary operator: the first argument is the mask, the second is the series from which to take the value if the mask is positive, and the third is the series from which to take the value if the mask is negative.<p>This ensures that the array returned by <strong class="inline">np.where</strong> only replaces the null values in <strong class="inline">damage_millions_dollars</strong> with values from the <strong class="inline">imputed_values</strong> series:</p><p class="snippet">data['damage_millions_dollars'] = np.where(condition=data.damage_millions_dollars.isnull(),</p><p class="snippet">                               x=imputed_values,</p><p class="snippet">                               y=data.damage_millions_dollars)</p></li>
				<li>Use the <strong class="inline">.info()</strong> function to view null value counts for the imputed columns:<p class="snippet">data[['damage_millions_dollars']].info()</p><p>The output will be as follows:</p></li>
			</ol>
			<div>
				<div id="_idContainer094" class="IMG---Figure">
					<img src="image/C12622_02_15.jpg" alt="Figure 2.15: The null value counts"/>
				</div>
			</div>
			<h6>Figure 2.15: The null value counts</h6>
			<p>We can see that, after replacement, there are no null values in the <strong class="inline">damage_millions_dollars</strong> column.</p>
			<h3 id="_idParaDest-56">Activity 2: S<a id="_idTextAnchor058"/>ummary Statistics and Missing Values</h3>
			<p>In this activity, we'll revise some of the summary statistics and missing value exploration we have looked at thus far in this chapter. We will be using a new dataset, taken from Kaggle's <em class="italics">House Prices: Advanced Regression Techniques</em> competition (available at <a href="https://www.kaggle.com/c/house-prices-advanced-regression-techniques/data">https://www.kaggle.com/c/house-prices-advanced-regression-techniques/data</a> or on GitHub at <a href="https://github.com/TrainingByPackt/Applied-Supervised-Learning-with-Python">https://github.com/TrainingByPackt/Applied-Supervised-Learning-with-Python</a>). While the Earthquakes dataset used in the exercises is aimed at solving a classification problem (when the target variable has only discrete values), the dataset we will use in the activities will be aimed at solving a regression problem (when the target variable takes on a range of continuous values). We'll use pandas functions to generate summary statistics and visualize missing values using a nullity matrix and nullity correlation heatmap.</p>
			<p>The steps to be performed are as follows:</p>
			<ol>
				<li value="1">Read the data.</li>
				<li>Use pandas' <strong class="inline">.info()</strong> and <strong class="inline">.describe()</strong> methods to view the summary statistics of the dataset.</li>
				<li>Find the total count and total percentage of missing values in each column of the DataFrame and display them for columns having at least one null value, in descending order of missing percentages.</li>
				<li>Plot the nullity matrix and nullity correlation heatmap.</li>
				<li>Delete the columns having more than 80% of values missing.</li>
				<li>Replace null values in the <strong class="inline">FireplaceQu</strong> column with <strong class="inline">NA</strong> values.<h4>Note</h4><p class="callout">The solution for this activity can be found on page 307.</p></li>
			</ol>
			<h2 id="_idParaDest-57">Distribution <a id="_idTextAnchor059"/>of Values</h2>
			<p>In this section, we'll look at how individual variables behave—what kind of values they take, what the distribution across those values is, and how those distributions can be represented visually.</p>
			<h3 id="_idParaDest-58">Target Variab<a id="_idTextAnchor060"/>le</h3>
			<p>The target variable can either have values that are continuous (in the case of a regression problem) or discrete (as in the case of a classification problem). The problem statement we're looking at in this chapter involves predicting whether or not an earthquake caused a tsunami, that is, the <strong class="inline">flag_tsunami</strong> variable, which takes on two discrete values only—making it a classification problem.</p>
			<p>One way of visualizing how many earthquakes resulted in tsunamis and how many didn't is a bar chart, where each bar represents a single discrete value of the variable, and the height of the bars is equal to the count of the data points having the corresponding discrete value. This gives us a good comparison of the absolute counts of each category.</p>
			<h3 id="_idParaDest-59">Exercise 16: <a id="_idTextAnchor061"/>Plotting a Bar Chart</h3>
			<p>Let's look at how many of the earthquakes in our dataset resulted in a tsunami. We will do this by using the <strong class="inline">value_counts()</strong> method over the column and directly using the <strong class="inline">.plot(kind='bar')</strong> function on the returned pandas series. Follow these steps:</p>
			<ol>
				<li value="1">Use <strong class="inline">plt.figure()</strong> to initiate the plotting:<p class="snippet">plt.figure(figsize=(8,6))</p></li>
				<li>Next, type in our primary plotting command:<p class="snippet">data.flag_tsunami.value_counts().plot(kind='bar')</p></li>
				<li>Set the display parameters and display the plot:<p class="snippet">plt.ylabel('Number of data points')</p><p class="snippet">plt.xlabel('flag_tsunami')</p><p class="snippet">plt.show()</p><p>The output will be as follows:</p></li>
			</ol>
			<div>
				<div id="_idContainer095" class="IMG---Figure">
					<img src="image/C12622_02_16.jpg" alt="Figure 2.16: Bar chart showing how many earthquakes resulted in a tsunami"/>
				</div>
			</div>
			<h6>Figure 2.16: Bar chart showing how many earthquakes resulted in a tsunami</h6>
			<p>From this bar plot, we can see that most of the earthquakes did not result in tsunamis, and that less than one-third of the earthquakes did. This shows us that the dataset is slightly imbalanced.</p>
			<p>Let's look more closely at what these Matplotlib commands do:</p>
			<ul>
				<li><strong class="inline">plt.figure(figsize=(8,6))</strong>: This command defines how big our plot should be, by providing width and height values. This is always the first command before any plotting command is written.</li>
				<li><strong class="inline">plt.xlabel()</strong> and <strong class="inline">plt.ylabel()</strong>: These commands take a string as input, and allow us to specify what the labels for the <em class="italics">X</em> and <em class="italics">Y</em> axes on the plot should be.</li>
				<li><strong class="inline">plt.show()</strong>: This is the final command written when plotting that displays the plot inline within the Jupyter notebook.</li>
			</ul>
			<h3 id="_idParaDest-60">Categorical Da<a id="_idTextAnchor062"/>ta</h3>
			<p>Categorical variables are ones that take discrete values representing different categories or levels of observation that can either be string objects, or integer values. For example, our target variable, <strong class="inline">flag_tsunami</strong>, is a categorical variable having two categories: <strong class="inline">Tsu</strong> and <strong class="inline">No</strong>.</p>
			<p>Categorical variables can be of two types:</p>
			<ul>
				<li><strong class="bold">Nominal variables</strong>: Variables in which the categories are labeled without any order of precedence are called nominal variables. An example of a nominal variable from our dataset would be <strong class="inline">location_name</strong>. The values that this variable takes cannot be said to be ordered, that is, one location is not <em class="italics">greater</em> than the other. Similarly, more examples of such a variable would be color, types of footwear, ethnicity type, and so on.</li>
				<li><strong class="bold">Ordinal variables</strong>: Variables that have some order associated with them are called ordinal variables. An example from our dataset would be <strong class="inline">damage_description</strong>, since each value represents an increasing value of damage incurred. Another example could be day of the week, which would have values from Monday to Sunday, which have some order associated with them and we know that Thursday comes after Wednesday but before Friday.<p>Although ordinal variables can be represented by object data types, they are often represented as numerical data types as well, often making it difficult to differentiate between them and continuous variables.</p></li>
			</ul>
			<p>One of the major challenges faced when dealing with categorical variables in a dataset is high cardinality, that is, a large number of categories or distinct values with each value appearing a relatively small number of times. For example, <strong class="inline">location_name</strong> has a large number of unique values, with each value occurring a small fraction of times in the dataset.</p>
			<p>Additionally, non-numerical categorical variables will always require some form of preprocessing to be converted into a numerical format so that they can be ingested for training by a machine learning model. It can be a challenge to encode categorical variables numerically without losing out on contextual information that despite being easy for humans to interpret (due to domain knowledge or otherwise just plain common sense), would be hard for a computer to automatically understand. For example, a geographical feature such as country or location name by itself would give no indication of the geographical proximity of different values, but that might just be an important feature—what if earthquakes that occur at locations in South-East Asia trigger more tsunamis than those that occur in Europe? There would be no way of capturing that information by merely numerically encoding the feature.</p>
			<h3 id="_idParaDest-61">Exercise 17: D<a id="_idTextAnchor063"/>atatypes for Categorical Variables</h3>
			<p>Let's find which variables in our Earthquake dataset are categorical and which are continuous. As we now know, categorical variables can also have numerical values, so having a numeric data type doesn't guarantee that a variable is continuous:</p>
			<ol>
				<li value="1">Find all the columns that are numerical and object types. We use the <strong class="inline">.select_dtypes()</strong> method on the DataFrame to create a subset DataFrame having numeric (<strong class="inline">np.number</strong>) and categorical (<strong class="inline">np.object</strong>) columns, and then print the column names for each. For numeric columns, use this:<p class="snippet">numeric_variables = data.select_dtypes(include=[np.number])</p><p class="snippet">numeric_variables.columns</p><p>The output will be as follows:</p><div id="_idContainer096" class="IMG---Figure"><img src="image/C12622_02_17.jpg" alt="Figure 2.17: All columns that are numerical "/></div><h6>Figure 2.17: All columns that are numerical </h6><p>For categorical columns, use this:</p><p class="snippet">object_variables = data.select_dtypes(include=[np.object])</p><p class="snippet">Object_variables.columns</p><p>The output will be as follows:</p><div id="_idContainer097" class="IMG---Figure"><img src="image/C12622_02_18.jpg" alt="Figure 2.18: All columns that are object types"/></div><h6>Figure 2.18: All columns that are object types</h6><p>Here, it is evident that the columns of object type are categorical variables. To differentiate between the categorical and continuous variables from the numeric columns, let's see how many unique values there are for each of these features.</p></li>
				<li>Find the number of unique values for numeric features. We use the <strong class="inline">select_dtypes</strong> method on the DataFrame to find the number of unique values in each column and sort the resulting series in ascending order. For numeric columns, use this:<p class="snippet">numeric_variables.nunique().sort_values()</p><p>The output will be as follows:</p></li>
			</ol>
			<div>
				<div id="_idContainer098" class="IMG---Figure">
					<img src="image/C12622_02_19.jpg" alt="Figure 2.19: Number of unique values for numeric features"/>
				</div>
			</div>
			<h6>Figure 2.19: Number of unique values for numeric features</h6>
			<p>For categorical columns, use this:</p>
			<p class="snippet">object_variables.nunique().sort_values()</p>
			<p>The output will be as follows:</p>
			<div>
				<div id="_idContainer099" class="IMG---Figure">
					<img src="image/C12622_02_20.jpg" alt="Figure 2.20: Number of unique values for categorical columns"/>
				</div>
			</div>
			<h6>Figure 2.20: Number of unique values for categorical columns</h6>
			<p>For the numeric variables, we can see that the top nine have significantly fewer unique values than the remaining rows, and it's likely that these are categorical variables. However, we must keep in mind that it is possible that some of them might just be continuous variables with a low range of rounded-up values. Also, <strong class="inline">month</strong> and <strong class="inline">day</strong> would not be considered categorical variables here.</p>
			<h3 id="_idParaDest-62">Exercise 18: Calcu<a id="_idTextAnchor064"/>lating Category Value Counts</h3>
			<p>For columns with categorical values, it would be useful to see what the unique values (categories) of the feature are, along with what the frequencies of these categories are, that is, how much does each distinct value occur in the dataset. Let's find the number of occurrences of each <strong class="inline">0</strong> to <strong class="inline">4</strong> label and <strong class="inline">NaN</strong> values for the <strong class="inline">injuries_description</strong> categorical variable:</p>
			<ol>
				<li value="1">Use the <strong class="inline">value_counts()</strong> function on the <strong class="inline">injuries_description</strong> column to find the frequency of each category. Using <strong class="inline">value_counts</strong> gives us the frequencies of each value in decreasing order in the form of a pandas series:<p class="snippet">counts = data.injuries_description.value_counts(dropna=False)</p><p class="snippet">counts</p><p>The output should be as follows:</p><div id="_idContainer100" class="IMG---Figure"><img src="image/C12622_02_21.jpg" alt="Figure 2.21: Frequency of each category"/></div><h6>Figure 2.21: Frequency of each category</h6></li>
				<li>Sort the values in increasing order of the ordinal variable. If we want the frequencies in the order of the values themselves, we can reset the index to give us a DataFrame and sort values by the index (that is, the ordinal variable):<p class="snippet">counts.reset_index().sort_values(by='index')</p></li>
			</ol>
			<div>
				<div id="_idContainer101" class="IMG---Figure">
					<img src="image/C12622_02_22.jpg" alt="Figure 2.22: Sorted values"/>
				</div>
			</div>
			<h6>Figure 2.22: Sorted values</h6>
			<h3 id="_idParaDest-63">Exercise 19: Plottin<a id="_idTextAnchor065"/>g a Pie Chart</h3>
			<p>Since our target variable in our sample data is categorical, the example in <em class="italics">Exercise 16: Plotting a Bar Chart</em> showed us one way of visualizing how the categorical values are distributed (using a bar chart). Another plot that can make it easy to see how each category functions as a fraction of the overall dataset is a pie chart. Let's plot a pie chart to visualize the distribution of the discrete values of the <strong class="inline">damage_description</strong> variable:</p>
			<ol>
				<li value="1">Format the data into the form that needs to be plotted. Here, we run <strong class="inline">value_counts()</strong> over the column and sort the series by index:<p class="snippet">counts = data.damage_description.value_counts()</p><p class="snippet">counts = counts.sort_index()</p></li>
				<li>Plot the pie chart. The <strong class="inline">plt.pie()</strong> category plots the pie chart using the count data. We will use the same three steps for plotting as described in <em class="italics">Exercise 16: Plotting a Bar Chart</em>:<p class="snippet">plt.figure(figsize=(10,10))</p><p class="snippet">plt.pie(counts, labels=counts.index)</p><p class="snippet">plt.title('Pie chart showing counts for\ndamage_description categories')</p><p class="snippet">plt.show()</p><p>The output will be:</p></li>
			</ol>
			<div>
				<div id="_idContainer102" class="IMG---Figure">
					<img src="image/C12622_02_23.jpg" alt="Figure 2.23: Pie chart showing counts for damage_description categories"/>
				</div>
			</div>
			<h6>Figure 2.23: Pie chart showing counts for damage_description categories</h6>
			<h3 id="_idParaDest-64"><a id="_idTextAnchor066"/>Continuous Data</h3>
			<p>Continuous variables can take any number of values and are usually integer (for example, number of deaths) or float data types (for example, the height of a mountain). It's useful to get an idea of the basic statistics of the values in the feature: the minimum, maximum, and percentile values we see from the output of the <strong class="inline">describe()</strong> function gives us a fair estimate of this.</p>
			<p>However, for continuous variables, it is also very useful to see how the values are distributed in the range they operate in. Since we cannot simply find the counts of individual values, instead we order the values in ascending order, group them into evenly-sized intervals, and find the counts for each interval. This gives us the underlying frequency distribution, and plotting this gives us a histogram, which allows us to examine the shape, central values, and amount of variability in the data.</p>
			<p>Histograms give us an easy view of the data that we're looking at. They tell us about the behavior of the values at a glance in terms of the underlying distribution (for example, a normal or exponential distribution), the presence of outliers, skewness, and more.</p>
			<h4>Note</h4>
			<p class="callout">It is easy to get confused between a bar chart and a histogram. The major difference is that a histogram is used to plot continuous data that has been binned to visualize the frequency distribution, while bar charts can be used for a variety of other use cases, including to represent categorical variables as we have done. Additionally, it is not just the height of the bar that indicates the frequency of that bin, but also the width of the bin itself, which is not the case in a bar chart.</p>
			<p>One of the most common frequency distributions is a Gaussian (or normal) distribution. This is a symmetric distribution that has a bell-shaped curve, which indicates that the values near the middle of the range have the highest occurrences in the dataset with a symmetrically decreasing frequency of occurrences as we move away from the middle. </p>
			<p>It is a probability distribution and the area under the curve equals one.</p>
			<div>
				<div id="_idContainer103" class="IMG---Figure">
					<img src="image/C12622_02_24.jpg" alt="Figure 2.24: Normal distribution"/>
				</div>
			</div>
			<h6>Figure 2.24: Normal distribution</h6>
			<p><strong class="bold">Skewness</strong></p>
			<p>A distributio<a id="_idTextAnchor067"/>n is said to be skewed if it is not symmetric in nature, and skewness measures the asymmetry of a variable about its mean. The value can be positive or negative (or undefined). In the former case, the tail is on the right-hand side of the distribution, while the latter indicates that the tail is on the left-hand side.</p>
			<p>However, it must be noted that a thick and short tail would have the same effect on the value of skewness as a long, thin tail.</p>
			<p><strong class="bold">Kurtosis</strong></p>
			<p>Kurtosis is a measure of the <em class="italics">tailedness</em> of the distribution of a variable and is used to measure the presence of outliers in one tail versus the other. A high value of kurtosis indicates a fatter tail and the presence of outliers. In a similar way to the concept of skewness, kurtosis also describes the shape of the distribution.</p>
			<h3 id="_idParaDest-65">Exercise 20: Plotting <a id="_idTextAnchor068"/>a Histogram</h3>
			<p>Let's plot the histogram for the <strong class="inline">eq_primary</strong> feature using the Seaborn library:</p>
			<ol>
				<li value="1">Use <strong class="inline">plt.figure()</strong> to initiate the plotting:<p class="snippet">plt.figure(figsize=(10,7))</p></li>
				<li><strong class="inline">sns.distplot()</strong> is the primary command that we will use to plot the histogram. The first parameter is the one-dimensional data over which to plot the histogram, the bins parameter defines the number and size of the bins. Use this as follows:<p class="snippet">sns.distplot(data.eq_primary.dropna(), bins=np.linspace(0,10,21))</p></li>
				<li>Display the plot using <strong class="inline">plt.show()</strong>:<p class="snippet">plt.show()</p><p>The output will be as follows:</p></li>
			</ol>
			<div>
				<div id="_idContainer104" class="IMG---Figure">
					<img src="image/C12622_02_25.jpg" alt="Figure 2.25: Histogram for the eq_primary feature"/>
				</div>
			</div>
			<h6>Figure 2.25: Histogra<a id="_idTextAnchor069"/>m for the eq_primary feature</h6>
			<p>The plot gives us a normed (or normalized) histogram, which means that the area under the bars of the histogram equals unity. Additionally, the line over the histogram is the <strong class="keyword">kernel density estimate</strong>, which gives us an idea of what the probability distribution for the variable would look like.</p>
			<p>From the plot, we can see that the values of <strong class="inline">eq_primary</strong> lie mostly between 5 and 8, which means that most earthquakes had a magnitude with a moderate to high value, with barely any earthquakes having a low or very high magnitude.</p>
			<h3 id="_idParaDest-66">Exercise 21: Skew and K<a id="_idTextAnchor070"/>urtosis</h3>
			<p>Let's calculate the skew and kurtosis values for all the features in the dataset using the core pandas functions available to us:</p>
			<ol>
				<li value="1">Use the <strong class="inline">.skew()</strong> DataFrame method to calculate the skew for all features and then sort the values in ascending order:<p class="snippet">data.skew().sort_values()</p><p>The output will be:</p><div id="_idContainer105" class="IMG---Figure"><img src="image/C12622_02_26.jpg" alt=""/></div><h6>Figure 2.26: Skew values for all the features in the dataset</h6></li>
				<li>Use the <strong class="inline">.kurt()</strong> DataFrame method to calculate the kurtosis for all features:<p class="snippet">data.kurt()</p><p>The output will be:</p></li>
			</ol>
			<div>
				<div id="_idContainer106" class="IMG---Figure">
					<img src="image/C12622_02_27.jpg" alt="Figure 2.27: Kurtosis values for all the features in the dataset"/>
				</div>
			</div>
			<h6>Figure 2.27: Kurtosis values for all the features in the dataset</h6>
			<p>Here, we can see that the kurtosis values for some variables deviate significantly from 0. This means that these columns have a long tail. But the values that are at the tail end of these variables (which indicate the number of people dead, injured, and the monetary value of damage), in our case, may be outliers that we may need to pay special attention to. Larger values might, in fact, indicate an additional force that added to the devastation caused by an earthquake, that is, a tsunami.</p>
			<h3 id="_idParaDest-67">Activity 3: Visually Repr<a id="_idTextAnchor071"/>esenting the Distribution of Values</h3>
			<p>In this activity, we will revise what we learned in the previous section about different types of data. We will use the same dataset we used in <em class="italics">Activity 2: Summary Statistics and Missing Values</em>, that is, <em class="italics">House Prices: Advanced Regression Techniques</em> (available at <a href="https://www.kaggle.com/c/house-prices-advanced-regression-techniques/data">https://www.kaggle.com/c/house-prices-advanced-regression-techniques/data</a> or on GitHub at <a href="https://github.com/TrainingByPackt/Applied-Supervised-Learning-with-Python">https://github.com/TrainingByPackt/Applied-Supervised-Learning-with-Python</a>). We'll use different types of plots to visually represent the distribution of values for this dataset.</p>
			<p>The steps to be performed are as follows:</p>
			<ol>
				<li value="1">Plot a histogram using Matplotlib for the target variable, <strong class="inline">SalePrice</strong>.</li>
				<li>Find the number of unique values within each column having an object type.</li>
				<li>Create a DataFrame representing the number of occurrences for each categorical value in the <strong class="inline">HouseStyle</strong> column.</li>
				<li>Plot a pie chart representing these counts.</li>
				<li>Find the number of unique values within each column having a number type.</li>
				<li>Plot a histogram using Seaborn for the <strong class="inline">LotArea</strong> variable.</li>
				<li>Calculate the skew and kurtosis values for the values in each column.<h4>Note</h4><p class="callout">The solution for this activity can be found on page 312.</p></li>
			</ol>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor072"/>Relationships within the Data</h2>
			<p>There are two reasons why it is important to find relationships between variables in the data:</p>
			<ul>
				<li>Finding which features are potentially important can be deemed essential, since finding ones that have a strong relationship with the target variable will aid in the feature selection process.</li>
				<li>Finding relationships between different features themselves can be useful, since variables in the dataset are usually never completely independent of every other variable and this can affect our modeling in a number of ways.</li>
			</ul>
			<p>Now, there are a number of ways we can visualize these relationships, and this really depends on the types of variable we are trying to find the relationship between, and how many we are considering as part of the equation or comparison.</p>
			<h3 id="_idParaDest-69">Relationship between Two <a id="_idTextAnchor073"/>Continuous Variables</h3>
			<p>To find a relationship between two continuous variables is basically to see how one varies as the value of the other is increased. The most common way to visualize this would be using a scatter plot, in which we take each variable along a single axis (the <em class="italics">X</em> and <em class="italics">Y</em> axes in a two-dimensional plane when we have two variables) and plot each data point using a marker in the <em class="italics">X-Y</em> plane. This visualization gives us a good idea of whether any kind of relationship exists between the two variables at all.</p>
			<p>If we want to quantize the relationship between the two variables, however, the most common method is to find the correlation between them. If the target variable is continuous and it has a high degree of correlation with another variable, this is an indication that the feature would be an important part of the model.</p>
			<p><strong class="bold">Pearson's Coefficient of <a id="_idTextAnchor074"/>Correlation</strong></p>
			<p><strong class="keyword">Pearson's Coefficient of Correlation</strong> is a correlation coefficient that is commonly used to show the linear relationship between a pair of variables. The formula returns a value between -1 and +1, where:</p>
			<ul>
				<li>+1 indicates a strong positive relationship</li>
				<li>-1 indicates a strong negative relationship</li>
				<li>0 indicates no relationship at all</li>
			</ul>
			<p>It's also useful to find correlations between pairs of features themselves. Although the presence of highly correlated features wouldn't worsen the model, they wouldn't necessarily make any model better, either. For the sake of simplicity, it is always better to keep only one from a set of highly correlated features.</p>
			<h4>Note</h4>
			<p class="callout">When fitting a linear model, having features that are highly correlated to each other can result in an unpredictable and widely varying model. This is because the coefficients of each feature in a linear model can be interpreted as the unit change in the target variable, keeping all other features constant. When a set of features are not independent (that is, are correlated), however, we cannot determine the effect of the independent changes to the target variable due to each feature, resulting in widely varying coefficients.</p>
			<p>To find the pairwise correlation for every numeric feature in a DataFrame with every other feature, we can use the <strong class="inline">.corr()</strong> function on the DataFrame.</p>
			<h3 id="_idParaDest-70">Exercise 22: Plotting a S<a id="_idTextAnchor075"/>catter Plot</h3>
			<p>Let's plot a scatter plot between the primary earthquake magnitude on the <em class="italics">X</em> axis and the corresponding number of injuries on the <em class="italics">Y</em> axis:</p>
			<ol>
				<li value="1">Filter out null values. Since we know that there are null values in both columns, let's first filter the data to include only the non-null rows:<p class="snippet">data_to_plot = data[~pd.isnull(data.injuries) &amp; ~pd.isnull(data.eq_primary)]</p></li>
				<li>Create and display the scatter plot. We will use Matplotlib's <strong class="inline">plt.scatter(x=..., y=...)</strong> as the primary command for plotting the data. The <strong class="inline">x</strong> and <strong class="inline">y</strong> parameters state which feature is to be considered along which axis. They take a single-dimensional data structure such as a list, a tuple, or a pandas series. We can also send the <strong class="inline">scatter</strong> function more parameters that define, say, the icon to use to plot an individual data point. For example, to use a red cross as the icon, we would need to send the following parameters: <strong class="inline">marker='x', c='r'</strong>:<p class="snippet">plt.figure(figsize=(12,9))</p><p class="snippet">plt.scatter(x=data_to_plot.eq_primary, y=data_to_plot.injuries)</p><p class="snippet">plt.xlabel('Primary earthquake magnitude')</p><p class="snippet">plt.ylabel('No. of injuries')</p><p class="snippet">plt.show()</p><p>The output will be as follows:</p></li>
			</ol>
			<div>
				<div id="_idContainer107" class="IMG---Figure">
					<img src="image/C12622_02_28.jpg" alt=""/>
				</div>
			</div>
			<h6>Figure 2.28: Scatter plot</h6>
			<p>From the plot, we can infer that although there doesn't seem to be a trend between the number of people who were injured and the earthquake magnitude, there are an increasing number of earthquakes with large injury counts as the magnitude increases. However, for the majority of earthquakes, there does not seem to be a relationship.</p>
			<h3 id="_idParaDest-71">Exercise 23: Correlation H<a id="_idTextAnchor076"/>eatmap</h3>
			<p>Let's plot a correlation heatmap between all the numeric variables in our dataset using Seaborn's <strong class="inline">sns.heatmap()</strong> function on the inter-feature correlation values in the dataset.</p>
			<p>The optional parameters passed to the <strong class="inline">sns.heatmap()</strong> function are <strong class="inline">square</strong> and <strong class="inline">cmap</strong>, which indicate that the plot should be such that each pixel is square and specify which color scheme to use, respectively:</p>
			<ol>
				<li value="1">Plot a basic heatmap with all the features:<p class="snippet">plt.figure(figsize = (12,10))</p><p class="snippet">sns.heatmap(data.corr(), square=True, cmap="YlGnBu")</p><p class="snippet">plt.show()</p><p>The output will be:</p><div id="_idContainer108" class="IMG---Figure"><img src="image/C12622_02_29.jpg" alt=""/></div><h6>Figure 2.29: Correlation heatmap</h6><p>We can see from the color bar on the right of the plot that the minimum value, around <strong class="inline">-0.2</strong>, is the lightest shade, which is a misrepresentation of the correlation values, which vary from -1 to 1.</p></li>
				<li>Plot a subset of features in a more customized heatmap. We will specify the upper and lower limits using the <strong class="inline">vmin</strong> and <strong class="inline">vmax</strong> parameters, and plot the heatmap again with annotations specifying the pairwise correlation values on a subset of features. We will also change the color scheme to one that can be better interpreted—while the neutral white will represent no correlation, increasingly darker shades of blue and red will represent higher positive and negative correlation values respectively:<p class="snippet">feature_subset = [</p><p class="snippet">    'focal_depth', 'eq_primary', 'eq_mag_mw', 'eq_mag_ms', 'eq_mag_mb', 'intensity',</p><p class="snippet">    'latitude', 'longitude', 'injuries', 'damage_millions_dollars',</p><p class="snippet">    'total_injuries', 'total_damage_millions_dollars']</p><p class="snippet">plt.figure(figsize = (12,10))</p><p class="snippet">sns.heatmap(data[feature_subset].corr(), square=True, annot=True, cmap="RdBu", vmin=-1, vmax=1)</p><p class="snippet">plt.show()</p><p>The output will be as follows:</p></li>
			</ol>
			<div>
				<div id="_idContainer109" class="IMG---Figure">
					<img src="image/C12622_02_30.jpg" alt=""/>
				</div>
			</div>
			<h6>Figure 2.30: Customized correlation heatmap</h6>
			<p>Now, while we can calculate the value of correlation, this only gives us an indication of a linear relationship. To better judge whether there's a possible dependency, we could plot a scatter plot between pairs of features, which is mostly useful when the relationship between the two variables is not known and visualizing how the data points are scattered or distributed could give us an idea of whether (and how) the two may be related.</p>
			<h3 id="_idParaDest-72"><a id="_idTextAnchor077"/>Exercise 24: Pairplot</h3>
			<p>A pairplot is useful for visualizing multiple relationships between pairs of features at once, and can be plotted using Seaborn's <strong class="inline">.pairplot()</strong> function. In this exercise, we will look at a pairplot between the features having the highest pair-wise correlation in the dataset:</p>
			<ol>
				<li value="1">Define a list having the subset of features on which to create the pairplot:<p class="snippet">feature_subset = [</p><p class="snippet">    'focal_depth', 'eq_primary', 'eq_mag_mw', 'eq_mag_ms', 'eq_mag_mb', 'intensity',</p><p class="snippet">    'latitude', 'longitude', 'injuries', 'damage_millions_dollars',</p><p class="snippet">    'total_injuries', 'total_damage_millions_dollars']</p></li>
				<li>Create the pairplot using Seaborn. The arguments sent to the plotting function are: <strong class="inline">kind='scatter'</strong>, which indicates that we want each individual plot between the pair of variables in the grid to be represented as a scatter plot, and <strong class="inline">diag_kind='kde'</strong>, which indicates that we want the plots along the diagonal (where both the features in the pair are the same) to be a kernel density estimate.<p>It should also be noted here that the plots symmetrically across the diagonal from each other will essentially be the same, just with the axes reversed:</p><p class="snippet">plt.figure(figsize = (12,10))</p><p class="snippet">sns.heatmap(data[feature_subset].corr(), square=True, annot=True, cmap="RdBu", vmin=-1, vmax=1)</p><p class="snippet">plt.show()</p><p>The output will be as follows:</p></li>
			</ol>
			<div>
				<div id="_idContainer110" class="IMG---Figure">
					<img src="image/C12622_02_31.jpg" alt=""/>
				</div>
			</div>
			<h6>Figure 2.31: Pairplot between the features having the highest pair-wise correlation</h6>
			<h3 id="_idParaDest-73">Relationship between a Contin<a id="_idTextAnchor078"/>uous and a Categorical Variable</h3>
			<p>A common way to see the relationship between two variables when one is categorical and the other is continuous can be using a bar plot or a box plot.</p>
			<ul>
				<li>A bar plot helps compare the value of a variable for a discrete set of parameters and is one of the most common types of plots. Each bar represents a categorical value and the height of the bar usually represents an aggregated value of the continuous variable over that category (such as average, sum, or count of the values of the continuous variable in that category).</li>
				<li>A box plot is a rectangle drawn to represent the distribution of the continuous variable for each discrete value of the categorical variable. It not only allows us to visualize outliers efficiently but also allows us to compare the distribution of the continuous variable across categories of the categorical variable. The lower and upper edges of the rectangle represent the first and third quartiles respectively, the line down through the middle represents the median value, and the points (or fliers) above and below the rectangle represent outlier values.</li>
			</ul>
			<h3 id="_idParaDest-74"><a id="_idTextAnchor079"/>Exercise 25: Bar Chart</h3>
			<p>Let's visualize the total number of tsunamis created by earthquakes of each intensity level using a bar chart:</p>
			<ol>
				<li value="1">Preprocess the <strong class="inline">flag_tsunami</strong> variable. Before we can use the <strong class="inline">flag_tsunami</strong> variable, we need to preprocess it to convert the <strong class="inline">No</strong> values to zeros and the <strong class="inline">Tsu</strong> values to ones. This will give us the binary target variable. To do this, we set the values in the column using the <strong class="inline">.loc</strong> operator, with <strong class="inline">:</strong> indicating that values need to be set for all rows, and the second parameter specifying the name of the column for which values are to be set:<p class="snippet">data.loc[:,'flag_tsunami'] = data.flag_tsunami.apply(lambda t: int(str(t) == 'Tsu'))</p></li>
				<li>Remove all rows having null <strong class="inline">intensity</strong> values from the data we want to plot:<p class="snippet">subset = data[~pd.isnull(data.intensity)][['intensity','flag_tsunami']]</p></li>
				<li>Find the total number of tsunamis for each <strong class="inline">intensity</strong> level and display the DataFrame. To get the data in a format using which a bar plot can be visualized, we will need to group the rows by each intensity level, and then sum over the <strong class="inline">flag_tsunami</strong> values to get the total number of tsunamis for each intensity level:<p class="snippet">data_to_plot = subset.groupby('intensity').sum()</p><p class="snippet">data_to_plot</p><p>The output will be as follows:</p><div id="_idContainer111" class="IMG---Figure"><img src="image/C12622_02_32.jpg" alt="Figure 2.32: Total number of tsunamis for each intensity level"/></div><h6>Figure 2.32: Total number of tsunamis for each intensity level</h6></li>
				<li>Plot the bar chart, using Matplotlib's <strong class="inline">plt.bar(x=..., height=...)</strong> method, which takes two arguments, one specifying the <strong class="inline">x</strong> values at which bars need to be drawn, and the second specifying the height of each bar. Both of these are one-dimensional data structures that must have the same length:<p class="snippet">plt.figure(figsize=(12,9))</p><p class="snippet">plt.bar(x=data_to_plot.index, height=data_to_plot.flag_tsunami)</p><p class="snippet">plt.xlabel('Earthquake intensity')</p><p class="snippet">plt.ylabel('No. of tsunamis')</p><p class="snippet">plt.show()</p><p>The output will be as follows:</p></li>
			</ol>
			<div>
				<div id="_idContainer112" class="IMG---Figure">
					<img src="image/C12622_02_33.jpg" alt="Figure 2.33: Bar chart"/>
				</div>
			</div>
			<h6>Figure 2.33: Bar chart</h6>
			<p>From this plot, we can see that as the earthquake intensity increases, the number of tsunamis caused also increases, but beyond an intensity of 9, the number of tsunamis seems to suddenly drop.</p>
			<p>Think about why this could be happening. Perhaps it's just that there are fewer earthquakes with an intensity that high, and hence fewer tsunamis. Or it could be an entirely independent factor; maybe high-intensity earthquakes have historically occurred on land and couldn't trigger a tsunami. Explore the data to find out.</p>
			<h3 id="_idParaDest-75"><a id="_idTextAnchor080"/>Exercise 26: Box Plot</h3>
			<p>In this exercise, we'll plot a box plot that represents the variation in <strong class="inline">eq_primary</strong> over the countries with at least 100 earthquakes:</p>
			<ol>
				<li value="1">Find countries with over 100 earthquakes. We will find the value counts for all the countries in the dataset. Then, we'll create a series comprising only those countries having a count greater than 100:<p class="snippet">country_counts = data.country.value_counts()</p><p class="snippet">top_countries = country_counts[country_counts &gt; 100]</p><p class="snippet">top_countries</p><p>The output will be as follows:</p><div id="_idContainer113" class="IMG---Figure"><img src="image/C12622_02_34.jpg" alt="Figure 2.34: Countries with over 100 earthquakes"/></div><h6>Figure 2.34: Countries with over 100 earthquakes</h6></li>
				<li>Subset the DataFrame to filter in only those rows having countries in the preceding set. To filter the rows, we use the <strong class="inline">.isin()</strong> method on the pandas series to select those rows containing a value in the array-like object passed as a parameter:<p class="snippet">subset = data[data.country.isin(top_countries.index)]</p></li>
				<li>Create and display the box plot. The primary command for plotting the data is <strong class="inline">sns.boxplot(x=..., y=..., data=..., order=)</strong>. The <strong class="inline">x</strong> and <strong class="inline">y</strong> parameters are the names of the columns in the DataFrame to be plotted on each axis—the former is assumed to be the categorical variable and the latter the continuous. The <strong class="inline">data</strong> parameter takes the DataFrame from which to take the data and <strong class="inline">order</strong> takes a list of category names that indicates the order in which to display the categories on the <em class="italics">X</em> axis:<p class="snippet">plt.figure(figsize=(15, 15))</p><p class="snippet">sns.boxplot(x='country', y="eq_primary", data=subset, order=top_countries.index)</p><p class="snippet">plt.show()</p><p>The output will be as follows:</p></li>
			</ol>
			<div>
				<div id="_idContainer114" class="IMG---Figure">
					<img src="image/C12622_02_35.jpg" alt="Figure 2.35: Box plot"/>
				</div>
			</div>
			<h6>Figure 2.35: Box plot</h6>
			<h3 id="_idParaDest-76">Relationship between Two Categori<a id="_idTextAnchor081"/>cal Variables</h3>
			<p>When we are looking at only a pair of categorical variables to find a relationship between them, the most intuitive way to do this is to divide the data on the basis of the first category, and then subdivide it further on the basis of the second categorical variable and look at the resultant counts to find the distribution of data points. While this might seem confusing, a popular way to visualize this is using stacked bar charts. As in a regular bar chart, each bar would represent a categorical value. But each bar would again be subdivided into color-coded categories that would provide an indication of what fraction of the data points in the primary category fall into each subcategory (that is, the second category). The variable with a larger number of categories is usually considered the primary category.</p>
			<h3 id="_idParaDest-77"><a id="_idTextAnchor082"/>Exercise 27: Stacked Bar Chart</h3>
			<p>In this exercise, we'll plot a stacked bar chart that represents the number of tsunamis that occurred for for each intensity level:</p>
			<ol>
				<li value="1">Find the number of data points that fall into each grouped value of <strong class="inline">intensity</strong> and <strong class="inline">flag_tsunami</strong>:<p class="snippet">grouped_data = data.groupby(['intensity', 'flag_tsunami']).size()</p><p class="snippet">grouped_data</p><p>The output will be as follows:</p><div id="_idContainer115" class="IMG---Figure"><img src="image/C12622_02_36.jpg" alt=""/></div><h6>Figure 2.36: Data points falling into each grouped value of intensity and flag_tsunami</h6></li>
				<li>Use the <strong class="inline">.unstack()</strong> method on the resultant DataFrame to get the level 1 index (<strong class="inline">flag_tsunami</strong>) as a column:<p class="snippet">data_to_plot = grouped_data.unstack()</p><p class="snippet">data_to_plot</p><p>The output will be as follows:</p><div id="_idContainer116" class="IMG---Figure"><img src="image/C12622_02_37.jpg" alt="Figure 2.37: The level 1 index"/></div><h6>Figure 2.37: The level 1 index</h6></li>
				<li>Create the stacked bar chart. We first use the <strong class="inline">sns.set()</strong> function to indicate that we want to use Seaborn as our visualization library. Then, we can easily use the native <strong class="inline">.plot()</strong> function in pandas to plot a stacked bar chart by passing the <strong class="inline">kind='bar'</strong> and <strong class="inline">stacked=True</strong> arguments:<p class="snippet">sns.set()</p><p class="snippet">data_to_plot.plot(kind='bar', stacked=True, figsize=(12,8))</p><p class="snippet">plt.show()</p><p>The output will be as follows:</p></li>
			</ol>
			<div>
				<div id="_idContainer117" class="IMG---Figure">
					<img src="image/C12622_02_38.jpg" alt="Figure 2.38: A stacked bar chart"/>
				</div>
			</div>
			<h6>Figure 2.38: A stacked bar chart</h6>
			<p>The plot now lets us visualize and interpret the fraction of earthquakes that caused tsunamis at each intensity level. In <em class="italics">Exercise 25: Bar Chart</em>, we saw the number of tsunamis drop for earthquakes having intensity greater than 9. From this plot, we can now confirm that this was primarily because the number of earthquakes themselves dropped beyond level 10; the fraction of tsunamis even increased for level 11.</p>
			<h3 id="_idParaDest-78">Activity 4: Relationships Within the<a id="_idTextAnchor083"/> Data</h3>
			<p>In this activity, we will revise what we learned in the previous section about relationships between data. We will use the same dataset we used in <em class="italics">Activity 2: Summary Statistics and Missing Values</em>, that is, <em class="italics">House Prices: Advanced Regression Techniques</em> (available at <a href="https://www.kaggle.com/c/house-prices-advanced-regression-techniques/data">https://www.kaggle.com/c/house-prices-advanced-regression-techniques/data</a> or on GitHub at <a href="https://github.com/TrainingByPackt/Applied-Supervised-Learning-with-Python">https://github.com/TrainingByPackt/Applied-Supervised-Learning-with-Python</a>). We'll use different plots to highlight relationships between values in this dataset.</p>
			<p>The steps to be performed are as follows:</p>
			<ol>
				<li value="1">Plot the correlation heatmap for the dataset.</li>
				<li>Plot a more compact heatmap having annotations for correlation values using the following subset of features:<p class="snippet">feature_subset = [</p><p class="snippet">    'GarageArea', 'GarageCars','GarageCond','GarageFinish','GarageQual','GarageType',</p><p class="snippet">    'GarageYrBlt','GrLivArea','LotArea','MasVnrArea','SalePrice'</p><p class="snippet">]</p></li>
				<li>Display the pairplot for the same subset of features, with the KDE plot on the diagonals and scatter plot elsewhere.</li>
				<li>Create a boxplot to show the variation in <strong class="inline">SalePrice</strong> for each category of <strong class="inline">GarageCars</strong>.</li>
				<li>Plot a line graph using Seaborn to show the variation in <strong class="inline">SalePrice</strong> for older and more recently built flats.<h4>Note</h4><p class="callout">The solution for this activity can be found on page 319.</p></li>
			</ol>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor084"/>Summary</h2>
			<p>In this<a id="_idTextAnchor085"/> chapter, we started by talking about why data exploration is an important part of the modeling process and how it can help in not only preprocessing the dataset for the modeling process, but also help us engineer informative features and improve model accuracy. This chapter focused on not only gaining a basic overview of the dataset and its features, but also gaining insights by creating visualizations that combine several features.</p>
			<p>We looked at how to find the summary statistics of a dataset using core functionality from pandas. We looked at how to find missing values and talked about why they're important, while learning how to use the Missingno library to analyze them and the pandas and scikit-learn libraries to impute the missing values.</p>
			<p>Then, we looked at how to study the univariate distributions of variables in the dataset and visualize them for both categorical and continuous variables using bar charts, pie<a id="_idTextAnchor086"/> charts, and histograms. Lastly, we learned how to explore relationships between variables, and about how they can be represented using scatter plots, heatmaps, box plots, and stacked bar charts, to name a few.</p>
			<p>In the following chapters, we will start exploring supervised machine learning algorithms. Now that we have an idea of how to explore a dataset that we have, we can proceed to the modeling phase. The next chapter will introduce regression: a class of algorithms that are primarily used to build models for continuous target variables.</p>
		</div>
	</body></html>