["```py\nimport numpy as np\nmemory = []\nfor episode in range(N):\n  for ts in range(T):\n    if eps np.random.random() > epsilon:\n      a = A[np.argmax([Q(a) for a in A])]\n    else:\n      a = np.random.choice(A)\n    r, s_next = env.execute(a)\n    memory.append((s, a, r, s_next))\n    learn(np.random.choice(memory, L) \n```", "```py\npip install git+https://github.com/benman1/mab-ranking \n```", "```py\nURL = 'https://raw.githubusercontent.com/PacktPublishing/Machine-Learning-for-Time-Series-with-Python/main/chapter11/jesterfinal151cols.csv' \n```", "```py\nimport pandas as pd\njester_data = pd.read_csv(URL, header=None) \n```", "```py\njester_data.index.name = \"users\" \n```", "```py\nfor col in jester_data.columns:\n    jester_data[col] = jester_data[col].apply(lambda x: 0.0 if x>=99 or x<7.0 else 1.0) \n```", "```py\njester_data = jester_data[jester_data.sum(axis=1) > 0] \n```", "```py\nfrom mab_ranking.bandits.rank_bandits import IndependentBandits\nfrom mab_ranking.bandits.bandits import DirichletThompsonSampling\nindependent_bandits = IndependentBandits(\n    num_arms=jester_data.shape[1],\n    num_ranks=10,\n    bandit_class=DirichletThompsonSampling\n) \n```", "```py\nfrom tqdm import trange\nnum_steps = 7000\nhit_rates = []\nfor _ in trange(1, num_steps + 1):\n    selected_items = set(independent_bandits.choose())\n    # Pick a users choices at random\n    random_user = jester_data.sample().iloc[0, :]\n    ground_truth = set(random_user[random_user == 1].index)\n    hit_rate = len(ground_truth.intersection(selected_items)) / len(ground_truth)\n    feedback_list = [1.0 if item in ground_truth else 0.0 for item in selected_items]\n    independent_bandits.update(selected_items, feedback_list)\n    hit_rates.append(hit_rate) \n```", "```py\nimport matplotlib.pyplot as plt\nstats = pd.Series(hit_rates)\nplt.figure(figsize=(12, 6))\nplt.plot(stats.index, stats.rolling(200).mean(), \"--\")\nplt.xlabel('Iteration')\nplt.ylabel('Hit rate') \n```", "```py\nfrom sklearn.cluster import KMeans\nfrom sklearn.preprocessing import StandardScaler\nscaler = StandardScaler().fit(jester_data)\nkmeans = KMeans(n_clusters=5, random_state=0).fit(scaler.transform(jester_data))\ncontexts = pd.Series(kmeans.labels_, index=jester_data.index) \n```", "```py\nindependent_bandits = IndependentBandits(\n    num_arms=jester_data.shape[1],\n    num_ranks=10,\n    bandit_class=DirichletThompsonSampling\n) \n```", "```py\nhit_rates = []\nfor _ in trange(1, num_steps + 1):\n    # Pick a users choices at random\n    random_user = jester_data.sample().iloc[0, :]\n    context = {\"previous_action\": contexts.loc[random_user.name]}\n    selected_items = set(independent_bandits.choose(\n        context=context\n    ))\n    ground_truth = set(random_user[random_user == 1].index)\n    hit_rate = len(ground_truth.intersection(selected_items)) / len(ground_truth)\n    feedback_list = [1.0 if item in ground_truth else 0.0 for item in selected_items]\n    independent_bandits.update(selected_items, feedback_list, context=context)\n    hit_rates.append(hit_rate) \n```", "```py\npip install git+https://github.com/tensortrade-org/tensortrade.git \n```", "```py\nimport pandas as pd\nimport tensortrade.env.default as default\nfrom tensortrade.data.cdd import CryptoDataDownload\nfrom tensortrade.feed.core import Stream, DataFeed\nfrom tensortrade.oms.exchanges import Exchange\nfrom tensortrade.oms.services.execution.simulated import execute_order\nfrom tensortrade.oms.instruments import USD, BTC, ETH\nfrom tensortrade.oms.wallets import Wallet, Portfolio\nfrom tensortrade.agents import DQNAgent\n%matplotlib inline \n```", "```py\ncdd = CryptoDataDownload()\ndata = cdd.fetch(\"Bitstamp\", \"USD\", \"BTC\", \"1h\")\ndata.head() \n```", "```py\ndef rsi(price: Stream[float], period: float) -> Stream[float]:\n    r = price.diff()\n    upside = r.clamp_min(0).abs()\n    downside = r.clamp_max(0).abs()\n    rs = upside.ewm(alpha=1 / period).mean() / downside.ewm(alpha=1 / period).mean()\n    return 100*(1 - (1 + rs) ** -1)\ndef macd(price: Stream[float], fast: float, slow: float, signal: float) -> Stream[float]:\n    fm = price.ewm(span=fast, adjust=False).mean()\n    sm = price.ewm(span=slow, adjust=False).mean()\n    md = fm - sm\n    signal = md - md.ewm(span=signal, adjust=False).mean()\n    return signal \n```", "```py\nfeatures = []\nfor c in data.columns[1:]:\n    s = Stream.source(list(data[c]), dtype=\"float\").rename(data[c].name)\n    features += [s]\ncp = Stream.select(features, lambda s: s.name == \"close\") \n```", "```py\nfeatures = [\n    cp.log().diff().rename(\"lr\"),\n    rsi(cp, period=20).rename(\"rsi\"),\n    macd(cp, fast=10, slow=50, signal=5).rename(\"macd\")\n]\nfeed = DataFeed(features)\nfeed.compile() \n```", "```py\nfor i in range(5):\n    print(feed.next()) \n```", "```py\nbitstamp = Exchange(\"bitstamp\", service=execute_order)(\n    Stream.source(list(data[\"close\"]), dtype=\"float\").rename(\"USD-BTC\")\n) \n```", "```py\nportfolio = Portfolio(USD, [\n    Wallet(bitstamp, 10000 * USD),\n    Wallet(bitstamp, 10 * BTC)\n]) \n```", "```py\nrenderer_feed = DataFeed([\n    Stream.source(list(data[\"date\"])).rename(\"date\"),\n    Stream.source(list(data[\"open\"]), dtype=\"float\").rename(\"open\"),\n    Stream.source(list(data[\"high\"]), dtype=\"float\").rename(\"high\"),\n    Stream.source(list(data[\"low\"]), dtype=\"float\").rename(\"low\"),\n    Stream.source(list(data[\"close\"]), dtype=\"float\").rename(\"close\"), \n    Stream.source(list(data[\"volume\"]), dtype=\"float\").rename(\"volume\") \n]) \n```", "```py\nenv = default.create(\n    portfolio=portfolio,\n    action_scheme=\"managed-risk\",\n    reward_scheme=\"risk-adjusted\",\n    feed=feed,\n    renderer_feed=renderer_feed,\n    renderer=default.renderers.PlotlyTradingChart(),\n    window_size=20\n) \n```", "```py\nenv.observer.feed.next() \n```", "```py\nagent = DQNAgent(env)\nagent.train(n_steps=200, n_episodes=2, save_path=\"agents/\") \n```", "```py\nperformance[\"net_worth\"].plot() \n```"]