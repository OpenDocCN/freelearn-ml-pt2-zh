<html><head></head><body>
		<br/>
		<p class="style0">2. Exploratory Data Analysis and Visualization</p>
		<div style="page-break-before: always;"/>
	

		<br/>
		<h4 class="style0">Activity 2.01: Summary Statistics and Missing Values</h4>
		<br/>
		<p class="style0">The steps to complete this activity are as follows:</p>
		<br/>
		<p class="style0">Import the required libraries:</p>
		<br/>
		<p class="style0">import json</p>
		<br/>
		<p class="style0">import pandas as pd</p>
		<br/>
		<p class="style0">import numpy as np</p>
		<br/>
		<p class="style0">import missingno as msno</p>
		<br/>
		<p class="style0">from sklearn.impute import SimpleImputer</p>
		<br/>
		<p class="style0">import matplotlib.pyplot as plt</p>
		<br/>
		<p class="style0">import seaborn as sns</p>
		<br/>
		<p class="style0">Read the data. Use pandas' .read_csv method to read the CSV file into a pandas DataFrame:</p>
		<br/>
		<p class="style0">data = pd.read_csv('../Datasets/house_prices.csv')</p>
		<br/>
		<p class="style0">Use pandas' .info() and .describe() methods to view the summary statistics of the dataset:</p>
		<br/>
		<p class="style0">data.info()</p>
		<br/>
		<p class="style0">data.describe().T</p>
		<br/>
		<p class="style0">The output of info() will be as follows:</p>
		<br style="line-height: 1,4"/>
		<div>
			<img src="../Images/image-ZT8SEDKR.jpg" alt="Figure 2.50: The output of the info() method (abbreviated)&#13;&#10;" height="100%"/>
		</div>
		<br/>
		<p class="style0" style="text-align: center">Figure 2.50: The output of the info() method (abbreviated)</p>
		<br/>
		<p class="style0">The output of describe() will be as follows:</p>
		<br style="line-height: 1,4"/>
		<div>
			<img src="../Images/image-OOF44R7X.jpg" alt="Figure 2.51: The output of the describe() method (abbreviated)&#13;&#10;" height="100%"/>
		</div>
		<br/>
		<p class="style0" style="text-align: center">Figure 2.51: The output of the describe() method (abbreviated)</p>
		<br/>
		<p class="style0">Find the total count and total percentage of missing values in each column of the DataFrame and display them for columns having at least one null value, in descending order of missing percentages.</p>
		<br/>
		<p class="style0">As we did in Exercise 2.02: Visualizing Missing Values, we will use the .isnull() function on the DataFrame to get a mask, find the count of null values in each column by using the .sum() function over the DataFrame mask and the fraction of null values by using .mean() over the DataFrame mask, and multiply by 100 to convert it to a percentage. Then, we'll use pd.concat() to combine the total and percentage of null values into a single DataFrame and sort the rows according to the percentage of missing values:</p>
		<br/>
		<p class="style0">mask = data.isnull()</p>
		<br/>
		<p class="style0">total = mask.sum()</p>
		<br/>
		<p class="style0">percent = 100*mask.mean()</p>
		<br/>
		<p class="style0">#</p>
		<br/>
		<p class="style0">missing_data = pd.concat([total, percent], axis=1,join='outer', \</p>
		<br/>
		<p class="style0">                         keys=['count_missing', 'perc_missing'])</p>
		<br/>
		<p class="style0">missing_data.sort_values(by='perc_missing', ascending=False, \</p>
		<br/>
		<p class="style0">                         inplace=True)</p>
		<br/>
		<p class="style0">#</p>
		<br/>
		<p class="style0">missing_data[missing_data.count_missing &gt; 0]</p>
		<br/>
		<p class="style0">The output will be as follows:</p>
		<br style="line-height: 1,4"/>
		<div>
			<img src="../Images/image-4D9WP7GA.jpg" alt="Figure 2.52: Total count and percentage of missing values in each column&#13;&#10;" height="100%"/>
		</div>
		<br/>
		<p class="style0" style="text-align: center">Figure 2.52: Total count and percentage of missing values in each column</p>
		<br/>
		<p class="style0">Plot the nullity matrix and nullity correlation heatmap. First, we find the list of column names for those having at least one null value. Then, we use the missingno library to plot the nullity matrix (as we did in Exercise 2.02: Visualizing Missing Values) for a sample of 500 points, and the nullity correlation heatmap for the data in those columns:</p>
		<br/>
		<p class="style0">nullable_columns = data.columns[mask.any()].tolist()</p>
		<br/>
		<p class="style0">msno.matrix(data[nullable_columns].sample(500))</p>
		<br/>
		<p class="style0">plt.show()</p>
		<br/>
		<p class="style0">msno.heatmap(data[nullable_columns], vmin = -0.1, \</p>
		<br/>
		<p class="style0">             figsize=(18,18))</p>
		<br/>
		<p class="style0">plt.show()</p>
		<br/>
		<p class="style0">The nullity matrix will look like this:</p>
		<br style="line-height: 1,4"/>
		<div>
			<img src="../Images/image-VEDY4A9O.jpg" alt="Figure 2.53: Nullity matrix&#13;&#10;" height="100%"/>
		</div>
		<br/>
		<p class="style0" style="text-align: center">Figure 2.53: Nullity matrix</p>
		<br/>
		<p class="style0">The nullity correlation heatmap will look like this:</p>
		<br style="line-height: 1,4"/>
		<div>
			<img src="../Images/image-S4SOOAAB.jpg" alt="Figure 2.54: Nullity correlation heatmap&#13;&#10;" height="100%"/>
		</div>
		<br/>
		<p class="style0" style="text-align: center">Figure 2.54: Nullity correlation heatmap</p>
		<br/>
		<p class="style0">Delete the columns having more than 80% of values missing. Use the .loc operator on the DataFrame we created in Step 2 to select only those columns that had fewer than 80% of their values missing:</p>
		<br/>
		<p class="style0">data = data.loc[:,missing_data[missing_data.perc_missing &lt; 80].index]</p>
		<br/>
		<p class="style0">Replace null values in the FireplaceQu column with NA values. Use the .fillna() method to replace null values with the NA string:</p>
		<br/>
		<p class="style0">data['FireplaceQu'] = data['FireplaceQu'].fillna('NA')</p>
		<br/>
		<p class="style0">data['FireplaceQu']</p>
		<br/>
		<p class="style0">The output should appear as follows:</p>
		<br style="line-height: 1,4"/>
		<div>
			<img src="../Images/image-1P5WR7JE.jpg" alt="Figure 2.55: Replacing null values&#13;&#10;" height="100%"/>
		</div>
		<br/>
		<br/>
		<p class="style0" style="text-align: center">Figure 2.55: Replacing null values</p>
		<br/>
		<h4 class="style2">Note</h4>
		<br/>
		<p class="style2">To access the source code for this specific section, please refer to https://packt.live/316c4a0.</p>
		<br/>
		<p class="style2">You can also run this example online at https://packt.live/2Z21v5c. You must execute the entire Notebook in order to get the desired result.</p>
		<div style="page-break-before: always;"/>
	

		<br/>
		<h4 class="style0">Activity 2.02: Representing the Distribution of Values Visually</h4>
		<br/>
		<p class="style0">Plot a histogram using Matplotlib for the target variable, SalePrice. First, we initialize the figure using the plt.figure command and set the figure size. Then, we use matplotlib's .hist() function as our primary plotting function, to which we pass the SalePrice series object for plotting the histogram. Lastly, we specify the axes' labels and show the plot:</p>
		<br/>
		<p class="style0">plt.figure(figsize=(8,6))</p>
		<br/>
		<p class="style0">plt.hist(data.SalePrice, bins=range(0,800000,50000))</p>
		<br/>
		<p class="style0">plt.ylabel('Number of Houses')</p>
		<br/>
		<p class="style0">plt.xlabel('Sale Price')</p>
		<br/>
		<p class="style0">plt.show()</p>
		<br/>
		<p class="style0">The output will be as follows:</p>
		<br style="line-height: 1,4"/>
		<div>
			<img src="../Images/image-QTG3WQJ1.jpg" alt="Figure 2.56: Histogram for the target variable &#13;&#10;" height="100%"/>
		</div>
		<br/>
		<p class="style0" style="text-align: center">Figure 2.56: Histogram for the target variable</p>
		<br/>
		<p class="style0">Find the number of unique values within each column having the object type. Create a new DataFrame called object_variables by using the .select_dtypes function on the original DataFrame to select those columns with the numpy.object data type. Then, find the number of unique values for each column in this DataFrame by using the .nunique() function, and sort the resultant series:</p>
		<br/>
		<p class="style0">object_variables = data.select_dtypes(include=[np.object])</p>
		<br/>
		<p class="style0">object_variables.nunique().sort_values()</p>
		<br/>
		<p class="style0">The output will be as follows:</p>
		<br style="line-height: 1,4"/>
		<div>
			<img src="../Images/image-KSB6TTSG.jpg" alt="Figure 2.57: Number of unique values within each column having the object type (truncated)&#13;&#10;" height="100%"/>
		</div>
		<br/>
		<p class="style0" style="text-align: center">Figure 2.57: Number of unique values within each column having the object type (truncated)</p>
		<br/>
		<p class="style0">Create a DataFrame representing the number of occurrences for each categorical value in the HouseStyle column. Use the .value_counts() function to calculate the frequencies of each value in decreasing order in the form of a pandas series, and then reset the index to give us a DataFrame and sort the values according to the index:</p>
		<br/>
		<p class="style0">counts = data.HouseStyle.value_counts(dropna=False)</p>
		<br/>
		<p class="style0">counts.reset_index().sort_values(by='index')</p>
		<br/>
		<p class="style0">The output will be as follows:</p>
		<br style="line-height: 1,4"/>
		<div>
			<img src="../Images/image-FK26JP04.jpg" alt="Figure 2.58: Number of occurrences of each categorical value in the HouseStyle column&#13;&#10;" height="100%"/>
		</div>
		<br/>
		<p class="style0" style="text-align: center">Figure 2.58: Number of occurrences of each categorical value in the HouseStyle column</p>
		<br/>
		<p class="style0">Plot a pie chart representing these counts. As in Step 1, we initialize the plot using plt.figure() and use the plt.title() and plt.show() methods to set the figure title and display it, respectively. The primary plotting function used is plt.pie(), to which we pass the series we created in the previous step:</p>
		<br/>
		<p class="style0">fig, ax = plt.subplots(figsize=(10,10))</p>
		<br/>
		<p class="style0">slices = ax.pie(counts, labels = counts.index, \</p>
		<br/>
		<p class="style0">                colors = ['white'], \</p>
		<br/>
		<p class="style0">                wedgeprops = {'edgecolor': 'black'})</p>
		<br/>
		<p class="style0">patches = slices[0]</p>
		<br/>
		<p class="style0">hatches =  ['/', '\\', '|', '-', '+', 'x', 'o', 'O', '\.', '*']</p>
		<br/>
		<p class="style0">colors = ['white', 'white', 'lightgrey', 'white', \</p>
		<br/>
		<p class="style0">          'lightgrey', 'white', 'lightgrey', 'white']</p>
		<br/>
		<p class="style0">for patch in range(len(patches)):</p>
		<br/>
		<p class="style0">    patches[patch].set_hatch(hatches[patch])</p>
		<br/>
		<p class="style0">    patches[patch].set_facecolor(colors[patch])</p>
		<br/>
		<p class="style0">plt.title('Pie chart showing counts for\nvarious house styles')</p>
		<br/>
		<p class="style0">plt.show()</p>
		<br/>
		<p class="style0">The output will be as follows:</p>
		<br style="line-height: 1,4"/>
		<div>
			<img src="../Images/image-JTOOX73Y.jpg" alt="Figure 2.59: Pie chart representing the counts&#13;&#10;" height="100%"/>
		</div>
		<br/>
		<p class="style0" style="text-align: center">Figure 2.59: Pie chart representing the counts</p>
		<br/>
		<p class="style0">Find the number of unique values within each column having the number type. As was executed in Step 2, now select columns having the numpy.number data type and find the number of unique values in each column using .nunique(). Sort the resultant series in descending order:</p>
		<br/>
		<p class="style0">numeric_variables = data.select_dtypes(include=[np.number])</p>
		<br/>
		<p class="style0">numeric_variables.nunique().sort_values(ascending=False)</p>
		<br/>
		<p class="style0">The output will be as follows:</p>
		<br style="line-height: 1,4"/>
		<div>
			<img src="../Images/image-3RPWU49J.jpg" alt="Figure 2.60: Number of unique values within each numeric column (truncated)&#13;&#10;" height="100%"/>
		</div>
		<br/>
		<p class="style0" style="text-align: center">Figure 2.60: Number of unique values within each numeric column (truncated)</p>
		<br/>
		<p class="style0">Plot a histogram using seaborn for the LotArea variable. Use seaborn's .distplot() function as the primary plotting function, to which the LotArea series in the DataFrame needs to be passed (without any null values, use .dropna() on the series to remove them). To improve the plot view, also set the bins parameter and specify the X-axis limits using plt.xlim():</p>
		<br/>
		<p class="style0">plt.figure(figsize=(10,7))</p>
		<br/>
		<p class="style0">sns.distplot(data.LotArea.dropna(), bins=range(0,100000,1000))</p>
		<br/>
		<p class="style0">plt.xlim(0,100000)</p>
		<br/>
		<p class="style0">plt.show()</p>
		<br/>
		<p class="style0">The output will be as follows:</p>
		<br style="line-height: 1,4"/>
		<div>
			<img src="../Images/image-YDX4ZTO7.jpg" alt="Figure 2.61: Histogram for the LotArea variable &#13;&#10;" height="100%"/>
		</div>
		<br/>
		<p class="style0" style="text-align: center">Figure 2.61: Histogram for the LotArea variable</p>
		<br/>
		<p class="style0">Calculate the skew and kurtosis values for the values in each column:</p>
		<br/>
		<p class="style0">data.skew().sort_values()</p>
		<br/>
		<p class="style0">data.kurt()</p>
		<br/>
		<p class="style0">The output for skew values will be:</p>
		<br style="line-height: 1,4"/>
		<div>
			<img src="../Images/image-EDDXHS8I.jpg" alt="Figure 2.62: Skew values for each column (truncated)&#13;&#10;" height="100%"/>
		</div>
		<br/>
		<br/>
		<p class="style0" style="text-align: center">Figure 2.62: Skew values for each column (truncated)</p>
		<br/>
		<p class="style0">The output for kurtosis values will be:</p>
		<br style="line-height: 1,4"/>
		<div>
			<img src="../Images/image-WMP9BEKX.jpg" alt="Figure 2.63: Kurtosis values for each column (truncated)&#13;&#10;" height="100%"/>
		</div>
		<br/>
		<p class="style0" style="text-align: center">Figure 2.63: Kurtosis values for each column (truncated)</p>
		<br/>
		<h4 class="style2">Note</h4>
		<br/>
		<p class="style2">To access the source code for this specific section, please refer to https://packt.live/3fR91qj.</p>
		<br/>
		<p class="style2">You can also run this example online at https://packt.live/37PYOI4. You must execute the entire Notebook in order to get the desired result.</p>
		<div style="page-break-before: always;"/>
	

		<br/>
		<h4 class="style0">Activity 2.03: Relationships within the Data</h4>
		<br/>
		<p class="style0">Plot the correlation heatmap for the dataset. As we did in Exercise 2.13: Plotting a Correlation Heatmap, plot the heatmap using seaborn's .heatmap() function and pass the feature correlation matrix (as determined by using pandas' .corr() function on the DataFrame). Additionally, set the color map to RdBu using the cmap parameter, and the minimum and maximum values on the color scale to -1 and 1 using the vmin and vmax parameters, respectively:</p>
		<br/>
		<p class="style0">plt.figure(figsize = (12,10))</p>
		<br/>
		<p class="style0">sns.heatmap(data.corr(), square=True, cmap="RdBu", \</p>
		<br/>
		<p class="style0">            vmin=-1, vmax=1)</p>
		<br/>
		<p class="style0">plt.show()</p>
		<br/>
		<p class="style0">The output will be as follows:</p>
		<br style="line-height: 1,4"/>
		<div>
			<img src="../Images/image-VCRY5EOD.jpg" alt="Figure 2.64: Correlation heatmap for the dataset&#13;&#10;" height="100%"/>
		</div>
		<br/>
		<p class="style0" style="text-align: center">Figure 2.64: Correlation heatmap for the dataset</p>
		<br/>
		<p class="style0">Plot a more compact heatmap having annotations for correlation values using the following subset of features:</p>
		<br/>
		<p class="style0">feature_subset = ['GarageArea','GarageCars','GarageCond', \</p>
		<br/>
		<p class="style0">                  'GarageFinish', 'GarageQual','GarageType', \</p>
		<br/>
		<p class="style0">                  'GarageYrBlt','GrLivArea','LotArea', \</p>
		<br/>
		<p class="style0">                  'MasVnrArea','SalePrice']</p>
		<br/>
		<p class="style0">Now do the same as in the previous step, this time selecting only the above columns in the dataset and adding a parameter, annot, with a True value to the primary plotting function, with everything else remaining the same:</p>
		<br/>
		<p class="style0">plt.figure(figsize = (12,10))</p>
		<br/>
		<p class="style0">sns.heatmap(data[feature_subset].corr(), square=True, \</p>
		<br/>
		<p class="style0">            annot=True, cmap="RdBu", vmin=-1, vmax=1)</p>
		<br/>
		<p class="style0">plt.show()</p>
		<br/>
		<p class="style0">The output will be as follows:</p>
		<br style="line-height: 1,4"/>
		<div>
			<img src="../Images/image-20XN5WXG.jpg" alt="Figure 2.65: Correlation heatmap for a feature subset with annotations &#13;&#10;for correlation values&#13;&#10;" height="100%"/>
		</div>
		<br/>
		<p class="style0" style="text-align: center">Figure 2.65: Correlation heatmap for a feature subset with annotations for correlation values</p>
		<br/>
		<p class="style0">Display the pairplot for the same subset of features, with the KDE plot on the diagonals and the scatter plot elsewhere. Use seaborn's .pairplot() function to plot the pairplot for the non-null values in the selected columns of the DataFrame. To render the diagonal KDE plots, pass kde to the diag_kind parameter and, to set all other plots as scatter plots, pass scatter to the kind parameter:</p>
		<br/>
		<p class="style0">sns.pairplot(data[feature_subset].dropna(), \</p>
		<br/>
		<p class="style0">             kind ='scatter', diag_kind='kde')</p>
		<br/>
		<p class="style0">plt.show()</p>
		<br/>
		<p class="style0">The output will be as follows:</p>
		<br style="line-height: 1,4"/>
		<div>
			<img src="../Images/image-NOERLBX6.jpg" alt="Figure 2.66: Pairplot for the same subset of features&#13;&#10;" height="100%"/>
		</div>
		<br/>
		<p class="style0" style="text-align: center">Figure 2.66: Pairplot for the same subset of features</p>
		<br/>
		<p class="style0">Create a boxplot to show the variation in SalePrice for each category of GarageCars. The primary plotting function used here will be seaborn's .boxplot() function, to which we pass the DataFrame along with the parameters x and y, the former being the categorical variable and the latter the continuous variable over which we want to see the variation within each category, that is, GarageCars and SalePrice, respectively:</p>
		<br/>
		<p class="style0">plt.figure(figsize=(10, 10))</p>
		<br/>
		<p class="style0">sns.boxplot(x='GarageCars', y="SalePrice", data=data)</p>
		<br/>
		<p class="style0">plt.show()</p>
		<br/>
		<p class="style0">The output will be as follows:</p>
		<br style="line-height: 1,4"/>
		<div>
			<img src="../Images/image-IOJJQAGE.jpg" alt="Figure 2.67: Boxplot showing the variation in SalePrice for each category of GarageCars&#13;&#10;" height="100%"/>
		</div>
		<br/>
		<p class="style0" style="text-align: center">Figure 2.67: Boxplot showing the variation in SalePrice for each category of GarageCars</p>
		<br/>
		<p class="style0">Plot a line graph using seaborn to show the variation in SalePrice for older to more recently built flats. Here, we will plot a line graph using seaborn's .lineplot() function. Since we want to see the variation in SalePrice, we take this as the y variable and, since the variation is across a period of time, we take YearBuilt as the x variable. Keeping this in mind, we pass the respective series as values to the y and x parameters for the primary plotting function. We also pass a ci=None parameter to hide the standard deviation indicator around the line in the plot:</p>
		<br/>
		<p class="style0">plt.figure(figsize=(10,7))</p>
		<br/>
		<p class="style0">sns.lineplot(x=data.YearBuilt, y=data.SalePrice, ci=None)</p>
		<br/>
		<p class="style0">plt.show()</p>
		<br/>
		<p class="style0">The output will be as follows:</p>
		<br style="line-height: 1,4"/>
		<div>
			<img src="../Images/image-GI1DMCQ1.jpg" alt="Figure 2.68: Line graph showing the variation in SalePrice for older to more recently &#13;&#10;built flats&#13;&#10;" height="100%"/>
		</div>
		<br/>
		<br/>
		<p class="style0" style="text-align: center">Figure 2.68: Line graph showing the variation in SalePrice for older to more recently built flats</p>
		<br/>
		<p class="style2">Figure 2.68 illustrates how to use a line chart to emphasize both overall trends and the ups and downs on shorter time cycles. You may want to compare this chart to a scatter chart of the same data and consider what sort of information each conveys.</p>
		<br/>
		<h4 class="style2">Note</h4>
		<br/>
		<p class="style2">To access the source code for this specific section, please refer to https://packt.live/2Z4bqHM.</p>
		<br/>
		<p class="style2">You can also run this example online at https://packt.live/2Nl5ggI. You must execute the entire Notebook in order to get the desired result.</p>
		<div style="page-break-before: always;"/>
	</body></html>