<html><head></head><body>
		<div id="_idContainer009" class="Content">
			<h1 id="_idParaDest-13"><em class="italics"><a id="_idTextAnchor013"/>Chapter 1</em></h1>
		</div>
		<div id="_idContainer010" class="Content">
			<h1 id="_idParaDest-14"><a id="_idTextAnchor014"/>Python Machine Learning Toolkit</h1>
		</div>
		<div id="_idContainer011" class="Content">
			<h2>Learning Objectives</h2>
			<p>By the end of this chapter, you will be able to:</p>
			<ul>
				<li class="bullets">Explain supervised machine learning and describe common examples of machine learning problems</li>
				<li class="bullets">Install and load Python libraries into your development environment for use in analysis and machine learning problems</li>
				<li class="bullets">Access and interpret the documentation of a subset of Python libraries, including the powerful pandas library </li>
				<li class="bullets">Create an IPython Jupyter notebook and use executable code cells and markdown cells to create a dynamic report</li>
				<li class="bullets">Load an external data source using pandas and use a variety of methods to search, filter, and compute descriptive statistics of the data</li>
				<li class="bullets">Clean a data source of mediocre quality and gauge the potential impact of various issues within the data source</li>
			</ul>
			<p>This chapter introduces supervised learning, Jupyter notebooks, and some of the most common pandas data methods.</p>
		</div>
		<div id="_idContainer076" class="Content">
			<h2 id="_idParaDest-15"><a id="_idTextAnchor015"/>Introduction</h2>
			<p>The study and application of machine learning and artificial intelligence has recently been the source of much interest and research in the technology and business communities. Advanced data analytics and machine learning techniques have shown great promise in advancing many sectors, such as personalized healthcare and self-driving cars, as well as in solving some of the world's greatest challenges, such as combating climate change. This book has been designed to assist you in taking advantage of the unique confluence of events in the field of data science and machine learning today. Across the globe, private enterprises and governments are realizing the value and efficiency of data-driven products and services. At the same time, reduced hardware costs and open source software solutions are significantly reducing the barriers to entry of learning and applying machine learning techniques.</p>
			<p>Throughout this book, you will develop the skills required to identify, prepare, and build predictive models using supervised machine learning techniques in the Python programming language. The six chapters each cover one aspect of supervised learning. This chapter introduces a subset of the Python machine learning toolkit, as well as some of the things that need to be considered when loading and using data sources. This data exploration process is further explored in <em class="italics">Chapter 2</em>, <em class="italics">Exploratory Data Analysis and Visualization</em>, as we introduce exploratory data analysis and visualization. <em class="italics">Chapter 3</em>, <em class="italics">Regression Analysis</em>, and <em class="italics">Chapter 4</em>, <em class="italics">Classification</em>, look at two subsets of machine learning problems – regression and classification analysis – and demonstrate these techniques through examples. Finally, <em class="italics">Chapter 5</em>, <em class="italics">Ensemble Modeling</em>, covers ensemble networks, which use multiple predictions from different models to boost overall performance, while <em class="italics">Chapter 6</em>, <em class="italics">Model Evaluation</em>, covers the extremely important concepts of validation and evaluation metrics. These metrics provide a means of estimating the true performance of a model.</p>
			<h2 id="_idParaDest-16"><a id="_idTextAnchor016"/>Supervised Machine Learning</h2>
			<p>A machine learning algorithm is commonly thought of as simply the mathematical process (or algorithm) itself, such as a neural network, deep neural network, or random forest algorithm. However, this is only a component of the overall system; firstly, we must define the problem that can be adequately solved using such techniques. Then, we must specify and procure a clean dataset that is composed of information that can be mapped from the first number space to a secondary one. Once the dataset has been designed and procured, the machine learning model can be specified and designed; for example, a single-layer neural network with 100 hidden nodes that uses a <em class="italics">tanh</em> activation function. </p>
			<p>With the dataset and model well defined, the means of determining the exact values for the model can be specified. This is a repetitive optimization process that evaluates the output of the model against some existing data and is commonly referred to as <strong class="keyword">training</strong>. Once training has been completed and you have your defined model, then it is good practice to evaluate it against some reference data to provide a benchmark of overall performance.</p>
			<p>Considering this general description of a complete machine learning algorithm, the problem definition and data collection stages are often the most critical. What is the problem you are trying to solve? What outcome would you like to achieve? How are you going to achieve it? How you answer these questions will drive and define many of the subsequent decisions or model design choices. It is also in answering these questions that we will select which category of machine learning algorithms we will choose: supervised or unsupervised methods.</p>
			<p>So, what exactly are supervised and unsupervised machine learning problems or methods? <strong class="keyword">Supervised learning</strong> techniques center on mapping some set of information to another by providing the training process with the input information and the desired outputs, then checking its ability to provide the correct result. As an example, let's say you are the publisher of a magazine that reviews and ranks hairstyles from various time periods. Your readers frequently send you far more images of their favorite hairstyles for review than you can manually process. To save some time, you would like to automate the sorting of the hairstyles images you receive based on time periods, starting with hairstyles from the 1960s and 1980s:</p>
			<div>
				<div id="_idContainer012" class="IMG---Figure">
					<img src="image/C12622_01_01.jpg" alt="Figure 1.1: Hairstyles images from different time periods&#13;&#10;"/>
				</div>
			</div>
			<h6>Figure 1.1: Hairstyles images from different time periods</h6>
			<p>To create your hairstyles-sorting algorithm, you start by collecting a large sample of hairstyles images and manually labeling each one with its corresponding time period. Such a dataset (known as a <strong class="keyword">labeled dataset</strong>) is the input data (hairstyles images) and the desired output information (time period) is known and recorded. This type of problem is a classic supervised learning problem; we are trying to develop an algorithm that takes a set of inputs and learns to return the answers that we have told it are correct.</p>
			<h3 id="_idParaDest-17"><a id="_idTextAnchor017"/>When to Use Supervised Learning</h3>
			<p>Generally, if you are trying to automate or replicate an existing process, the problem is a supervised learning problem. Supervised learning techniques are both very useful and powerful, and you may have come across them or even helped create labeled datasets for them without realizing. As an example, a few years ago, Facebook introduced the ability to tag your friends in any image uploaded to the platform. To tag a friend, you would draw a square over your friend's face and then add the name of your friend to notify them of the image. Fast-forward to today and Facebook will automatically identify your friends in the image and tag them for you. This is yet another example of supervised learning. If you ever used the early tagging system and manually identified your friends in an image, you were in fact helping to create Facebook's labeled dataset. A user who uploaded an image of a person's face (the input data) and tagged the photo with the subject's name would then create the label for the dataset. As users continued to use this tagging service, a sufficiently large labeled dataset was created for the supervised learning problem. Now friend-tagging is completed automatically by Facebook, replacing the manual process with a supervised learning algorithm, as opposed to manual user input:</p>
			<div>
				<div id="_idContainer013" class="IMG---Figure">
					<img src="image/C12622_01_02.jpg" alt="Figure 1.2: Tagging a friend on Facebook"/>
				</div>
			</div>
			<h6>Figure 1.2: Tagging a friend on Facebook</h6>
			<p>One particularly timely and straightforward example of supervised learning is the training of self-driving cars. In this example, the algorithm uses the target route as determined by the GPS system, as well as on-board instrumentation, such as speed measures, the brake position, and/or a camera or <strong class="keyword">Light Detection and Ranging</strong> (<strong class="keyword">LIDAR</strong>), for road obstacle detection as the labeled outputs of the system. During training, the algorithm samples the control inputs as provided by the human driver, such as speed, steering angle, and brake position, mapping them against the outputs of the system; thus providing the labeled dataset. This data can then be used to train the driving/navigation systems within the self-driving car or in simulation exercises.</p>
			<p>Image-based supervised problems, while popular, are not the only examples of supervised learning problems. Supervised learning is also commonly used in the automatic analysis of text to determine whether the opinion or tone of a message is positive, negative, or neutral. Such analysis is known as <strong class="keyword">sentiment analysis</strong> and frequently involves creating and using a labeled dataset of a series of words or statements that are manually identified as either positive, neutral, or negative. Consider these sentences: <em class="italics">I like that movie</em> and <em class="italics">I hate that movie</em>. The first sentence is clearly positive, while the second is negative. We can then decompose the words in the sentences into either positive, negative, or neutral (both positive, both negative); see the following table:</p>
			<div>
				<div id="_idContainer014" class="IMG---Figure">
					<img src="image/C12622_01_03.jpg" alt="Figure 1.3: Decomposition of the words"/>
				</div>
			</div>
			<h6>Figure 1.3: Decomposition of the words</h6>
			<p>Using sentiment analysis, a supervised learning algorithm could be created, say, using the movie database site IMDb to analyze comments posted about movies to determine whether the movie is being positively or negatively reviewed by the audience. Supervised learning methods could have other applications, such as analyzing customer complaints, automating troubleshooting calls/chat sessions, or even medical applications such as analyzing images of moles to detect abnormalities (<a href="https://www.nature.com/articles/nature21056">https://www.nature.com/articles/nature21056</a>).</p>
			<p>This should give you a good understanding of the concept of supervised learning, as well as some examples of problems that can be solved using these techniques. While supervised learning involves training an algorithm to map the input information to corresponding known outputs, <strong class="keyword">unsupervised learning</strong> methods, by contrast, do not utilize known outputs, either because they are not available or even known. Rather than relying on a set of manually annotated labels, unsupervised learning methods model the supplied data through specific constraints or rules designed into the training process. </p>
			<p>Clustering analysis is a common form of unsupervised learning where a dataset is to be divided into a specified number of different groups based on the clustering process being used. In the case of k-nearest neighbors clustering, each sample from the dataset is labeled or classified in accordance with the majority vote of the k-closest points to the sample. As there are no manually identified labels, the performance of unsupervised algorithms can vary greatly with the data being used, as well as the selected parameters of the model. For example, should we use the 5 closest or 10 closest points in the majority vote of the k-closest points? The lack of known and target outputs during training leads to unsupervised methods being commonly used in exploratory analysis or in scenarios where the ground truth targets are somewhat ambiguous and are better defined by the constraints of the learning method.</p>
			<p>We will not cover unsupervised learning in great detail in this book, but it is useful to summarize the main difference between the two methods. Supervised learning methods require ground truth labels or the <em class="italics">answers</em> for the input data, while unsupervised methods do not use such labels, and the final result is determined by the constraints applied during the training process.</p>
			<h3 id="_idParaDest-18"><a id="_idTextAnchor018"/>Why Python?</h3>
			<p>So, why have we chosen the Python programming language for our investigation into supervised machine learning? There are a number of alternative languages available, including C++, R, and Julia. Even the Rust community is developing machine learning libraries for their up-and-coming language. There are a number of reasons why Python is the first-choice language for machine learning:</p>
			<ul>
				<li>There is great demand for developers with Python expertise in both industry and academic research.</li>
				<li>Python is currently one of the most popular programming languages, even reaching the number one spot in <em class="italics">IEEE Spectrum</em> magazine's survey of the top 10 programming languages (<a href="https://spectrum.ieee.org/at-work/innovation/the-2018-top-programming-languages">https://spectrum.ieee.org/at-work/innovation/the-2018-top-programming-languages</a>). </li>
				<li>Python is an open source project, with the entire source code for the Python programming language being freely available under the GNU GPL Version 2 license. This licensing mechanism has allowed Python to be used, modified, and even extended in a number of other projects, including the Linux operating system, supporting NASA (<a href="https://www.python.org/about/success/usa/">https://www.python.org/about/success/usa/</a>), and a plethora of other libraries and projects that have provided additional functionality, choice, and flexibility to the Python programming language. In our opinion, this flexibility is one of the key components that has made Python so popular.</li>
				<li>Python provides a common set of features that can be used to run a web server, a microservice on an embedded device, or to leverage the power of graphical processing units to perform precise calculations on large datasets.</li>
				<li>Using Python and a handful of specific libraries (or packages, as they are known in Python), an entire machine learning product can be developed—starting with exploratory data analysis, model definition, and refinement, through to API construction and deployment. All of these steps can be completed within Python to build an end-to-end solution. This is the significant advantage Python has over some of its competitors, particularly within the data science and machine learning space. While R and Julia have the advantage of being specifically designed for numerical and statistical computing, models developed in these languages typically require translation into some other language before they can be deployed in a production setting.</li>
			</ul>
			<p>We hope that, through this book, you will gain an understanding of the flexibility and power of the Python programming language and will start on the path of developing end-to-end supervised learning solutions in Python. So, let's get started.</p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor019"/>Jupyter Notebooks</h2>
			<p>One aspect of the data science development environment that distinguishes itself from other Python projects is the use of IPython Jupyter notebooks (<a href="https://jupyter.org">https://jupyter.org</a>). Jupyter notebooks provide a means of creating and sharing interactive documents with live, executable code snippets, and plots, as well as the rendering of mathematical equations through the Latex (<a href="https://www.latex-project.org">https://www.latex-project.org</a>) typesetting system. This section of the chapter will introduce you to Jupyter notebooks and some of their key features to ensure your development environment is correctly set up.</p>
			<p>Throughout this book, we will make frequent reference to the documentation for each of the introduced tools/packages. The ability to effectively read and understand the documentation for each tool is extremely important. Many of the packages we will use contain so many features and implementation details that it is very difficult to memorize them all. The following documentation may come in handy for the upcoming section on Jupyter notebooks:</p>
			<ul>
				<li>The Anaconda documentation can be found at <a href="https://docs.anaconda.com">https://docs.anaconda.com</a>.</li>
				<li>The Anaconda user guide can be found at <a href="https://docs.anaconda.com/anaconda/user-guide">https://docs.anaconda.com/anaconda/user-guide</a>.</li>
				<li>The Jupyter Notebook documentation can be found at <a href="https://jupyter-notebook.readthedocs.io/en/stable/">https://jupyter-notebook.readthedocs.io/en/stable/</a>.</li>
			</ul>
			<h3 id="_idParaDest-20"><a id="_idTextAnchor020"/>Exercise 1: Launching a Jupyter Notebook</h3>
			<p>In this exercise, we will launch our Jupyter notebook. Ensure you have correctly installed Anaconda with Python 3.7, as per the <em class="italics">Preface</em>:</p>
			<ol>
				<li>There are two ways of launching a Jupyter notebook through Anaconda. The first method is to open Jupyter using the <strong class="bold">Anaconda Navigator</strong> application available in the <strong class="inline">Anaconda</strong> folder of the Windows Start menu. Click on the <strong class="bold">Launch</strong> button and your default internet browser will then launch at the default address, <strong class="inline">http://localhost:8888</strong>, and will start in a default folder path.</li>
				<li>The second method is to launch Jupyter via the Anaconda prompt. To launch the Anaconda prompt, simply click on the <strong class="bold">Anaconda Prompt</strong> menu item, also in the Windows Start menu, and you should see a pop-up window similar to the following screenshot:<div id="_idContainer015" class="IMG---Figure"><img src="image/C12622_01_04.jpg" alt="Figure 1.4: Anaconda prompt"/></div><h6>Figure 1.4: Anaconda prompt</h6></li>
				<li>Once in the Anaconda prompt, change to the desired directory using the <strong class="inline">cd</strong> (change directory) command. For example, to change into the <strong class="inline">Desktop</strong> directory for the <strong class="inline">Packt</strong> user, do the following:<p class="snippet">C:\Users\Packt&gt; cd C:\Users\Packt\Desktop</p></li>
				<li>Once in the desired directory, launch a Jupyter notebook using the following command:<p class="snippet">C:\Users\Packt&gt; jupyter notebook</p><p>The notebook will launch with the working directory from the one you specified earlier. This then allows you to navigate and save your notebooks in the directory of your choice as opposed to the default, which can vary between systems, but is typically your home or <strong class="inline">My Computer</strong> directory. Irrespective of the method of launching Jupyter, a window similar to the following will open in your default browser. If there are existing files in the directory, you should also see them here:</p></li>
			</ol>
			<div>
				<div id="_idContainer016" class="IMG---Figure">
					<img src="image/C12622_01_05.jpg" alt="Figure 1.5: Jupyter notebook launch window"/>
				</div>
			</div>
			<h6>Figure 1.5: Jupyter notebook launch window</h6>
			<h3 id="_idParaDest-21"><a id="_idTextAnchor021"/>Exercise 2: Hello World</h3>
			<p>The <em class="italics">Hello World</em> exercise is a rite of passage, so you certainly cannot be denied that experience! So, let's print <strong class="inline">Hello World</strong> in a Jupyter notebook in this exercise:</p>
			<ol>
				<li value="1">Start by creating a new Jupyter notebook by clicking on the <strong class="bold">New</strong> button and selecting <strong class="bold">Python 3</strong>. Jupyter allows you to run different versions of Python and other languages, such as R and Julia, all in the same interface. We can also create new folders or text files here too. But for now, we will start with a Python 3 notebook:<div id="_idContainer017" class="IMG---Figure"><img src="image/C12622_01_06.jpg" alt="Figure 1.6: Creating a new notebook"/></div><h6>Figure 1.6: Creating a new notebook</h6><p>This will launch a new Jupyter notebook in a new browser window. We will first spend some time looking over the various tools that are available in the notebook:</p><div id="_idContainer018" class="IMG---Figure"><img src="image/C12622_01_07.jpg" alt="Figure 1.7: The new notebook"/></div><h6>Figure 1.7: The new notebook</h6><p>There are three main sections in each Jupyter notebook, as shown in the following screenshot: the title bar (<strong class="bold">1</strong>), the toolbar (<strong class="bold">2</strong>), and the body of the document (<strong class="bold">3</strong>). Let's look at each of these components in order:</p><div id="_idContainer019" class="IMG---Figure"><img src="image/C12622_01_08.jpg" alt="Figure 1.8: Components of the notebook"/></div><h6>Figure 1.8: Components of the notebook</h6></li>
				<li>The title bar simply displays the name of the current Jupyter notebook and allows the notebook to be renamed. Click on the <strong class="bold">Untitled</strong> text and a popup will appear allowing you to rename the notebook. Enter <strong class="inline">Hello World</strong> and click <strong class="bold">Rename</strong>:<div id="_idContainer020" class="IMG---Figure"><img src="image/C12622_01_09.jpg" alt="Figure 1.9: Renaming the notebook"/></div><h6>Figure 1.9: Renaming the notebook</h6></li>
				<li>For the most part, the toolbar contains all the normal functionality that you would expect. You can open, save, and make copies of—or create new—Jupyter notebooks in the <strong class="bold">File</strong> menu. You can search replace, copy, and cut content in the <strong class="bold">Edit</strong> menu and adjust the view of the document in the <strong class="bold">View</strong> menu. As we discuss the body of the document, we will also describe some of the other functionalities in more detail, such as the ones included in the <strong class="bold">Insert</strong>, <strong class="bold">Cell</strong>, and <strong class="bold">Kernel</strong> menus. One aspect of the toolbar that requires further examination is the far right-hand side, the outline of the circle on the right of Python 3.<p>Hover your mouse over the circle and you will see the <strong class="bold">Kernel Idle</strong> popup. This circle is an indicator to signify whether the Python kernel is currently processing; when processing, this circle indicator will be filled in. If you ever suspect that something is running or is not running, you can easily refer to this icon for more information. When the Python kernel is not running, you will see this:</p><div id="_idContainer021" class="IMG---Figure"><img src="image/C12622_01_10.jpg" alt="Figure 1.10: Kernel idle"/></div><h6>Figure 1.10: Kernel idle</h6><p>When the Python kernel is running, you will see this:</p><div id="_idContainer022" class="IMG---Figure"><img src="image/C12622_01_11.jpg" alt="Figure 1.11: Kernel busy"/></div><h6>Figure 1.11: Kernel busy</h6></li>
				<li>This brings us to the body of the document, where the actual content of the notebook will be entered. Jupyter notebooks differ from standard Python scripts or modules, in that they are divided into separate executable cells. While Python scripts or modules will run the entirety of the script when executed, Jupyter notebooks can run all of the cells sequentially, or can also run them separately and in a different order if manually executed.<p>Double-click on the first cell and enter the following:</p><p class="snippet">&gt;&gt;&gt; print('Hello World!')</p></li>
				<li>Click on <strong class="bold">Run</strong> (or use the <em class="italics">Ctrl</em> + <em class="italics">Enter</em> keyboard shortcut):</li>
			</ol>
			<div>
				<div id="_idContainer023" class="IMG---Figure">
					<img src="image/C12622_01_12.jpg" alt="Figure 1.12: Running a cell"/>
				</div>
			</div>
			<h6>Figure 1.12: Running a cell</h6>
			<p>Congratulations! You just completed <em class="italics">Hello World</em> in a Jupyter notebook.</p>
			<h3 id="_idParaDest-22"><a id="_idTextAnchor022"/>Exercise 3: Order of Execution in a Jupyter Notebook</h3>
			<p>In the previous exercise, notice how the <strong class="inline">print</strong> statement is executed under the cell. Now let's take it a little further. As mentioned earlier, Jupyter notebooks are composed of a number of separately executable cells; it is best to think of them as just blocks of code you have entered into the Python interpreter, and the code is not executed until you press the <em class="italics">Ctrl</em> + <em class="italics">Enter</em> keys. While the code is run at a different time, all of the variables and objects remain in the session within the Python kernel. Let's investigate this a little further:</p>
			<ol>
				<li value="1">Launch a new Jupyter notebook and then, in three separate cells, enter the code shown in the following screenshot:<div id="_idContainer024" class="IMG---Figure"><img src="image/C12622_01_13.jpg" alt="Figure 1.13: Entering code into multiple cells"/></div><h6>Figure 1.13: Entering code into multiple cells</h6></li>
				<li>Click <strong class="bold">Restart &amp; Run All</strong>.<p>Notice that there are three executable cells, and the order of execution is shown in rectangular brackets; for example, <strong class="bold">In [1]</strong>, <strong class="bold">In [2]</strong>, and <strong class="bold">In [3]</strong>. Also note how the <strong class="inline">hello_world</strong> variable is declared (and thus executed) in the second cell and remains in memory, and thus is printed in the third cell. As we mentioned before, you can also run the cells out of order.</p></li>
				<li>Click on the second cell, containing the declaration of <strong class="inline">hello_world</strong>, change the value to add a few more exclamation points, and run the cell again:<div id="_idContainer025" class="IMG---Figure"><img src="image/C12622_01_14.jpg" alt="Figure 1.14: Changing the content of the second cell"/></div><h6>Figure 1.14: Changing the content of the second cell</h6><p>Notice that the second cell is now the most recently executed cell (<strong class="bold">In [4]</strong>), and that the <strong class="inline">print</strong> statement after it has not been updated. To update the <strong class="inline">print</strong> statement, you would then need to execute the cell below it. <em class="italics">Warning: be careful about your order of execution</em>. If you are not careful, you can easily override values or declare variables in cells below their first use, as in notebooks, you no longer need to run the entire script at once. As such, it is good practice to regularly click <strong class="bold">Kernel</strong> | <strong class="bold">Restart &amp; Run All</strong>. This will clear all variables from memory and run all cells from top to bottom in order. There is also the option to run all cells below or above a particular cell in the <strong class="bold">Cell</strong> menu:</p><div id="_idContainer026" class="IMG---Figure"><img src="image/C12622_01_15.jpg" alt="Figure 1.15: Restarting the kernel"/></div><h6>Figure 1.15: Restarting the kernel</h6><h4>Note</h4><p class="callout">Write and structure your notebook cells as if you were to run them all in order, top to bottom. Use manual cell execution only for debugging/early investigation.</p></li>
				<li>You can also move cells around using either the up/down arrows on the left of <strong class="bold">Run</strong> or through the <strong class="bold">Edit</strong> toolbar. Move the cell that prints the <strong class="inline">hello_world</strong> variable to above its declaration:<div id="_idContainer027" class="IMG---Figure"><img src="image/C12622_01_16.jpg" alt="Figure 1.16: Moving cells"/></div><h6>Figure 1.16: Moving cells</h6></li>
				<li>Click on <strong class="bold">Restart &amp; Run All</strong> cells:</li>
			</ol>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<img src="image/C12622_01_17.jpg" alt="Figure 1.17: Variable not defined error"/>
				</div>
			</div>
			<h6>Figure 1.17: Variable not defined error</h6>
			<p>Notice the error reporting that the variable is not defined. This is because it is being used before its declaration. Also, notice that the cell after the error has not been executed as shown by the empty <strong class="bold">In [ ]</strong>.</p>
			<h3 id="_idParaDest-23"><a id="_idTextAnchor023"/>Exercise 4: Advantages of Jupyter Notebooks</h3>
			<p>There are a number of additional features of Jupyter notebooks that make them very useful. In this exercise, we will examine some of these features:</p>
			<ol>
				<li value="1">Jupyter notebooks can execute commands directly within the Anaconda prompt by including an exclamation point prefix (<strong class="inline">!</strong>). Enter the code shown in the following screenshot and run the cell:<div id="_idContainer029" class="IMG---Figure"><img src="image/C12622_01_18.jpg" alt="Figure 1.18: Running Anaconda commands"/></div><h6>Figure 1.18: Running Anaconda commands</h6></li>
				<li>One of the best features of Jupyter notebooks is the ability to create live reports that contain executable code. Not only does this save time in preventing separate creation of reports and code, but it can also assist in communicating the exact nature of the analysis being completed. Through the use of Markdown and HTML, we can embed headings, sections, images, or even JavaScript for dynamic content.<p>To use Markdown in our notebook, we first need to change the cell type. First, click on the cell you want to change to Markdown, then click on the <strong class="bold">Code</strong> drop-down menu and select <strong class="bold">Markdown</strong>:</p><div id="_idContainer030" class="IMG---Figure"><img src="image/C12622_01_19.jpg" alt="Figure 1.19: Running Anaconda commands"/></div><h6>Figure 1.19: Running Anaconda commands</h6><p>Notice that <strong class="bold">In [ ]</strong> has disappeared and the color of the box lining the cell is no longer blue.</p></li>
				<li>You can now enter valid Markdown syntax and HTML by double-clicking in the cell and then clicking <strong class="bold">Run</strong> to render the markdown. Enter the syntax shown in the following screenshot and run the cell to see the output:</li>
			</ol>
			<div>
				<div id="_idContainer031" class="IMG---Figure">
					<img src="image/C12622_01_20.jpg" alt="Figure 1.20: Markdown syntax"/>
				</div>
			</div>
			<h6>Figure 1.20: Markdown syntax</h6>
			<p>The output will be as follows:</p>
			<div>
				<div id="_idContainer032" class="IMG---Figure">
					<img src="image/C12622_01_21.jpg" alt="Figure 1.21: Markdown output"/>
				</div>
			</div>
			<h6>Figure 1.21: Markdown output</h6>
			<h4>Note</h4>
			<p class="callout">For a quick reference on Markdown, refer to the <strong class="inline">Markdown Syntax.ipynb</strong> Jupyter notebook in the code files for this chapter.</p>
			<h3 id="_idParaDest-24"><a id="_idTextAnchor024"/>Python Packages and Modules</h3>
			<p>While the standard features that are included in Python are certainly feature-rich, the true power of Python lies in the additional libraries (also known as packages in Python), which, thanks to open source licensing, can be easily downloaded and installed through a few simple commands. In an Anaconda installation, it is even easier as many of the most common packages come pre-built within Anaconda. You can get a complete list of the pre-installed packages in the Anaconda environment by running the following command in a notebook cell:</p>
			<p class="snippet">!conda list</p>
			<p>In this book, we will be using the following additional Python packages:</p>
			<ul>
				<li><strong class="keyword">NumPy</strong> (pronounced <em class="italics">Num Pie</em> and available at <a href="https://www.numpy.org/">https://www.numpy.org/</a>): NumPy (short for numerical Python) is one of the core components of scientific computing in Python. NumPy provides the foundational data types from which a number of other data structures derive, including linear algebra, vectors and matrices, and key random number functionality.</li>
				<li><strong class="keyword">SciPy</strong> (pronounced <em class="italics">Sigh Pie</em> and available at <a href="https://www.scipy.org">https://www.scipy.org</a>): SciPy, along with NumPy, is a core scientific computing package. SciPy provides a number of statistical tools, signal processing tools, and other functionality, such as Fourier transforms.</li>
				<li><strong class="keyword">pandas</strong> (available at <a href="https://pandas.pydata.org/">https://pandas.pydata.org/</a>): pandas is a high-performance library for loading, cleaning, analyzing, and manipulating data structures.</li>
				<li><strong class="keyword">Matplotlib</strong> (available at <a href="https://matplotlib.org/">https://matplotlib.org/</a>): Matplotlib is the foundational Python library for creating graphs and plots of datasets and is also the base package from which other Python plotting libraries derive. The Matplotlib API has been designed in alignment with the Matlab plotting library to facilitate an easy transition to Python.</li>
				<li><strong class="keyword">Seaborn</strong> (available at <a href="https://seaborn.pydata.org/">https://seaborn.pydata.org/</a>): Seaborn is a plotting library built on top of Matplotlib, providing attractive color and line styles as well as a number of common plotting templates.</li>
				<li><strong class="keyword">Scikit-learn</strong> (available at <a href="https://scikit-learn.org/stable/">https://scikit-learn.org/stable/</a>): Scikit-learn is a Python machine learning library that provides a number of data mining, modeling, and analysis techniques in a simple API. Scikit-learn includes a number of machine learning algorithms out of the box, including classification, regression, and clustering techniques.</li>
			</ul>
			<p>These packages form the foundation of a versatile machine learning development environment with each package contributing a key set of functionalities. As discussed, by using Anaconda, you will already have all of the required packages installed and ready for use. If you require a package that is not included in the Anaconda installation, it can be installed by simply entering and executing the following in a Jupyter notebook cell:</p>
			<p class="snippet">!conda install &lt;package name&gt;</p>
			<p>As an example, if we wanted to install Seaborn, we'd run this:</p>
			<p class="snippet">!conda install seaborn</p>
			<p>To use one of these packages in a notebook, all we need to do is import it:</p>
			<p class="snippet">import matplotlib</p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor025"/>pandas</h2>
			<p>As mentioned before, pandas is a library for loading, cleaning, and analyzing a variety of different data structures. It is the flexibility of pandas, in addition to the sheer number of built-in features, that makes it such a powerful, popular, and useful Python package. It is also a great package to start with as, obviously, we cannot analyze any data if we do not first load it into the system. As pandas provides so much functionality, one very important skill in using the package is the ability to read and understand the documentation. Even after years of experience programming in Python and using pandas, we still refer to the documentation very frequently. The functionality within the API is so extensive that it is impossible to memorize all of the features and specifics of the implementation.</p>
			<h4>Note</h4>
			<p class="callout">The pandas documentation can be found at <a href="https://pandas.pydata.org/pandas-docs/stable/index.html">https://pandas.pydata.org/pandas-docs/stable/index.html</a>.</p>
			<h3 id="_idParaDest-26"><a id="_idTextAnchor026"/>Loading Data in pandas</h3>
			<p>pandas has the ability to read and write a number of different file formats and data structures, including CSV, JSON, and HDF5 files, as well as SQL and Python Pickle formats. The pandas input/output documentation can be found at <a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html">https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html</a>. We will continue to look into the pandas functionality through loading data via a CSV file. The dataset we will be using for this chapter is the <em class="italics">Titanic: Machine Learning from Disaster</em> dataset, available from <a href="https://www.kaggle.com/c/Titanic/data">https://www.kaggle.com/c/Titanic/data</a> or <a href="https://github.com/TrainingByPackt/Applied-Supervised-Learning-with-Python">https://github.com/TrainingByPackt/Applied-Supervised-Learning-with-Python</a>, which contains a roll of the guests on board the Titanic as well as their age, survival status, and number of siblings/parents. Before we get started with loading the data into Python, it is critical that we spend some time looking over the information provided for the dataset so that we can have a thorough understanding of what it contains. Download the dataset and place it in the directory you're working in.</p>
			<p>Looking at the description for the data, we can see that we have the following fields available:</p>
			<div>
				<div id="_idContainer033" class="IMG---Figure">
					<img src="image/C12622_01_22.jpg" alt="Figure 1.22: Fields in the Titanic dataset"/>
				</div>
			</div>
			<h6>Figure 1.22: Fields in the Titanic dataset</h6>
			<p>We are also provided with some additional contextual information:</p>
			<ul>
				<li><strong class="inline">pclass</strong>: This is a proxy for socio-economic status, where first class is upper, second class is middle, and third class is lower status.</li>
				<li><strong class="inline">age</strong>: This is a fractional value if less than 1; for example, <em class="italics">0.25</em> is 3 months. If the age is estimated, it is in the form of <em class="italics">xx.5</em>.</li>
				<li><strong class="inline">sibsp</strong>: A sibling is defined as a brother, sister, stepbrother, or stepsister, and a spouse is a husband or wife.</li>
				<li><strong class="inline">parch</strong>: A parent is a mother or father, a child is a daughter, son, stepdaughter, or stepson. Children that traveled only with a nanny did not travel with a parent. Thus, <em class="italics">0</em> was assigned for this field.</li>
				<li><strong class="inline">embarked</strong>: The point of embarkation is the location where the passenger boarded the ship.</li>
			</ul>
			<p>Note that the information provided with the dataset does not give any context as to how the data was collected. The <strong class="inline">survival</strong>, <strong class="inline">pclass</strong>, and <strong class="inline">embarked</strong> fields are known as categorical variables as they are assigned to one of a fixed number of labels or categories to indicate some other information. For example, in <strong class="inline">embarked</strong>, the <strong class="inline">C</strong> label indicates that the passenger boarded the ship at Cherbourg, and the value of <strong class="inline">1</strong> in <strong class="inline">survival</strong> indicates they survived the sinking.</p>
			<h3 id="_idParaDest-27"><a id="_idTextAnchor027"/>Exercise 5: Loading and Summarizing the Titanic Dataset</h3>
			<p>In this exercise, we will read our Titanic dataset into Python and perform a few basic summary operations on it:</p>
			<ol>
				<li value="1">Import the pandas package using shorthand notation, as shown in the following screenshot:<div id="_idContainer034" class="IMG---Figure"><img src="image/C12622_01_23.jpg" alt="Figure 1.23: Importing the pandas package"/></div><h6>Figure 1.23: Importing the pandas package</h6></li>
				<li>Open the <strong class="inline">titanic.csv</strong> file by clicking on it in the Jupyter notebook home page:<div id="_idContainer035" class="IMG---Figure"><img src="image/C12622_01_24.jpg" alt="Figure 1.24: Opening the CSV file"/></div><h6>Figure 1.24: Opening the CSV file</h6><p>The file is a CSV file, which can be thought of as a table, where each line is a row in the table and each comma separates columns in the table. Thankfully, we don't need to work with these tables in raw text form and can load them using pandas:</p><div id="_idContainer036" class="IMG---Figure"><img src="image/C12622_01_25.jpg" alt="Figure 1.25: Contents of the CSV file"/></div><h6>Figure 1.25: Contents of the CSV file</h6><h4>Note</h4><p class="callout">Take a moment to look up the pandas documentation for the <strong class="inline">read_csv</strong> function at <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html">https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html</a>. Note the number of different options available for loading CSV data into a pandas DataFrame.</p></li>
				<li>In an executable Jupyter notebook cell, execute the following code to load the data from the file:<p class="snippet">df = pd.read_csv('Titanic.csv')</p><p>The pandas DataFrame class provides a comprehensive set of attributes and methods that can be executed on its own contents, ranging from sorting, filtering, and grouping methods to descriptive statistics, as well as plotting and conversion.</p><h4>Note</h4><p class="callout">Open and read the documentation for pandas DataFrame objects at <a href="https://pandas.pydata.org/pandas-docs/stable/reference/frame.html">https://pandas.pydata.org/pandas-docs/stable/reference/frame.html</a>.</p></li>
				<li>Read the first five rows of data using the <strong class="inline">head()</strong> method of the DataFrame:<p class="snippet">df.head()</p></li>
			</ol>
			<div>
				<div id="_idContainer037" class="IMG---Figure">
					<img src="image/C12622_01_26.jpg" alt="Figure 1.26: Reading the first five rows"/>
				</div>
			</div>
			<h6>Figure 1.26: Reading the first five rows</h6>
			<p>In this sample, we have a visual representation of the information in the DataFrame. We can see that the data is organized in a tabular, almost spreadsheet-like structure. The different types of data are organized by columns, while each sample is organized by rows. Each row is assigned to an index value and is shown as the numbers <strong class="bold">0</strong> to <strong class="bold">4</strong> in bold on the left-hand side of the DataFrame. Each column is assigned to a label or name, as shown in bold at the top of the DataFrame.</p>
			<p>The idea of a DataFrame as a kind of spreadsheet is a reasonable analogy; as we will see in this chapter, we can sort, filter, and perform computations on the data just as you would in a spreadsheet program. While not covered in this chapter, it is interesting to note that DataFrames also contain pivot table functionality, just like a spreadsheet (<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.pivot_table.html">https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.pivot_table.html</a>).</p>
			<h3 id="_idParaDest-28">Exercise 6: Inde<a id="_idTextAnchor028"/>xing and Selecting Data</h3>
			<p>Now that we have loaded some data, let's use the selection and indexing methods of the DataFrame to access some data of interest:</p>
			<ol>
				<li value="1">Select individual columns in a similar way to a regular dictionary, by using the labels of the columns, as shown here:<p class="snippet">df['Age']</p><div id="_idContainer038" class="IMG---Figure"><img src="image/C12622_01_27.jpg" alt="Figure 1.27: Selecting the Age column"/></div><h6>Figure 1.27: Selecting the Age column</h6><p>If there are no spaces in the column name, we can also use the dot operator. If there are spaces in the column names, we will need to use the bracket notation:</p><p class="snippet">df.Age</p><div id="_idContainer039" class="IMG---Figure"><img src="image/C12622_01_28.jpg" alt="Figure 1.28: Using the dot operator to select the Age column"/></div><h6>Figure 1.28: Using the dot operator to select the Age column</h6></li>
				<li>Select multiple columns at once using bracket notation, as shown here:<p class="snippet">df[['Name', 'Parch', 'Sex']]</p><div id="_idContainer040" class="IMG---Figure"><img src="image/C12622_01_29.jpg" alt="Figure 1.29: Selecting multiple columns"/></div><h6>Figure 1.29: Selecting multiple columns</h6></li>
				<li>Select the first row using <strong class="inline">iloc</strong>:<p class="snippet">df.iloc[0]</p><div id="_idContainer041" class="IMG---Figure"><img src="image/C12622_01_30.jpg" alt="Figure 1.30: Selecting the first row"/></div><h6>Figure 1.30: Selecting the first row</h6></li>
				<li>Select the first three rows using <strong class="inline">iloc</strong>:<p class="snippet">df.iloc[[0,1,2]]</p><div id="_idContainer042" class="IMG---Figure"><img src="image/C12622_01_31.jpg" alt="Figure 1.31: Selecting the first three rows"/></div><h6>Figure 1.31: Selecting the first three rows</h6></li>
				<li>We can also get a list of all of the available columns. Do this as shown here:<p class="snippet">columns = df.columns # Extract the list of columns</p><p class="snippet">print(columns)</p><div id="_idContainer043" class="IMG---Figure"><img src="image/C12622_01_32.jpg" alt="Figure 1.32: Getting all the columns"/></div><h6>Figure 1.32: Getting all the columns</h6></li>
				<li>Use this list of columns and the standard Python slicing syntax to get columns 2, 3, and 4, and their corresponding values:<p class="snippet">df[columns[1:4]] # Columns 2, 3, 4</p><div id="_idContainer044" class="IMG---Figure"><img src="image/C12622_01_33.jpg" alt="Figure 1.33: Getting the second, third, and fourth columns"/></div><h6>Figure 1.33: Getting the second, third, and fourth columns</h6></li>
				<li>Use the <strong class="inline">len</strong> operator to get the number of rows in the DataFrame:<p class="snippet">len(df)</p><div id="_idContainer045" class="IMG---Figure"><img src="image/C12622_01_34.jpg" alt="Figure 1.34: Getting the number of rows"/></div><h6>Figure 1.34: Getting the number of rows</h6></li>
				<li>What if we wanted the value for the <strong class="inline">Fare</strong> column at row <strong class="inline">2</strong>? There are a few different ways to do so. First, we'll try the row-centric methods. Do this as follows:<p class="snippet">df.iloc[2]['Fare'] # Row centric</p><div id="_idContainer046" class="IMG---Figure"><img src="image/C12622_01_35.jpg" alt="Figure 1.35: Getting a particular value using the normal row-centric method"/></div><h6>Figure 1.35: Getting a particular value using the normal row-centric method</h6></li>
				<li>Try using the dot operator for the column. Do this as follows:<p class="snippet">df.iloc[2].Fare # Row centric</p><div id="_idContainer047" class="IMG---Figure"><img src="image/C12622_01_36.jpg" alt="Figure 1.36: Getting a particular value using the row-centric dot operator"/></div><h6>Figure 1.36: Getting a particular value using the row-centric dot operator</h6></li>
				<li>Try using the column-centric method. Do this as follows:<p class="snippet">df['Fare'][2] # Column centric</p><div id="_idContainer048" class="IMG---Figure"><img src="image/C12622_01_37.jpg" alt="Figure 1.37: Getting a particular value using the normal column-centric method"/></div><h6>Figure 1.37: Getting a particular value using the normal column-centric method</h6></li>
				<li>Try the column-centric method with the dot operator. Do this as follows:<p class="snippet">df.Fare[2] # Column centric</p></li>
			</ol>
			<div>
				<div id="_idContainer049" class="IMG---Figure">
					<img src="image/C12622_01_38.jpg" alt="Figure 1.38: Getting a particular value using the column-centric dot operator"/>
				</div>
			</div>
			<h6>Figure 1.38: Getting a particular value using the column-centric dot operator</h6>
			<h3 id="_idParaDest-29"><a id="_idTextAnchor029"/>Exercise 7: Advanced Indexing and Selection</h3>
			<p>With the basics of indexing and selection under our belt, we can turn our attention to more advanced indexing and selection. In this exercise, we will look at a few important methods for performing advanced indexing and selecting data:</p>
			<ol>
				<li value="1">Create a list of the passengers' names and ages for those passengers under the age of 21, as shown here:<p class="snippet">child_passengers = df[df.Age  &lt; 21][['Name', 'Age']]</p><p class="snippet">child_passengers.head()</p><div id="_idContainer050" class="IMG---Figure"><img src="image/C12622_01_39.jpg" alt="Figure 1.39: List of the passengers’ names and ages for those passengers under the age of 21"/></div><h6>Figure 1.39: List of the passengers' names and ages for those passengers under the age of 21</h6></li>
				<li>Count how many child passengers there were, as shown here:<p class="snippet">print(len(child_passengers))</p><div id="_idContainer051" class="IMG---Figure"><img src="image/C12622_01_40.jpg" alt="Figure 1.40: Count of child passengers"/></div><h6>Figure 1.40: Count of child passengers</h6></li>
				<li>Count how many passengers were between the ages of 21 and 30. Do not use Python's <strong class="inline">and</strong> logical operator for this step, but rather the ampersand symbol (<strong class="inline">&amp;</strong>). Do this as follows:<p class="snippet">young_adult_passengers = df.loc[</p><p class="snippet">    (df.Age &gt; 21) &amp; (df.Age &lt; 30)</p><p class="snippet">]</p><p class="snippet">len(young_adult_passengers)</p><div id="_idContainer052" class="IMG---Figure"><img src="image/C12622_01_41.jpg" alt="Figure 1.41: Count of passengers between the ages of 21 and 30"/></div><h6>Figure 1.41: Count of passengers between the ages of 21 and 30</h6></li>
				<li>Count the passengers that were either first- or third-class ticket holders. Again, we will not use the Python logical <strong class="inline">or</strong> operator but rather the pipe symbol (<strong class="inline">|</strong>). Do this as follows:<p class="snippet">df.loc[</p><p class="snippet">    (df.Pclass == 3) | (df.Pclass ==1)</p><p class="snippet">]</p><div id="_idContainer053" class="IMG---Figure"><img src="image/C12622_01_42.jpg" alt="Figure 1.42: Count of passengers that were either first- or third-class ticket holders"/></div><h6>Figure 1.42: Count of passengers that were either first- or third-class ticket holders</h6></li>
				<li>Count the passengers who were not holders of either first- or third-class tickets. Do not simply select the second class ticket holders, but rather use the <strong class="inline">~</strong> symbol for the <strong class="inline">not</strong> logical operator. Do this as follows:<p class="snippet">df.loc[</p><p class="snippet">    ~((df.Pclass == 3) | (df.Pclass ==1))</p><p class="snippet">]</p><div id="_idContainer054" class="IMG---Figure"><img src="image/C12622_01_43.jpg" alt="Figure 1.43: Count of passengers who were not holders of either first- or third-class tickets"/></div><h6>Figure 1.43: Count of passengers who were not holders of either first- or third-class tickets</h6></li>
				<li>We no longer need the <strong class="inline">Unnamed: 0</strong> column, so delete it using the <strong class="inline">del</strong> operator:<p class="snippet">del df['Unnamed: 0']</p><p class="snippet">df.head()</p></li>
			</ol>
			<div>
				<div id="_idContainer055" class="IMG---Figure">
					<img src="image/C12622_01_44.jpg" alt="Figure 1.44: The del operator"/>
				</div>
			</div>
			<h6>Figure 1.44: The del operator</h6>
			<h3 id="_idParaDest-30"><a id="_idTextAnchor030"/>pandas Methods</h3>
			<p>Now that we are confident with some pandas basics, as well as some more advanced indexing and selecting tools, let's look at some other DataFrame methods. For a complete list of all methods available in a DataFrame, we can refer to the class documentation.</p>
			<h4>Note</h4>
			<p class="callout">The pandas documentation is available at <a href="https://pandas.pydata.org/pandas-docs/stable/reference/frame.html">https://pandas.pydata.org/pandas-docs/stable/reference/frame.html</a>.</p>
			<p>You should now know how many methods are available within a DataFrame. There are far too many to cover in detail in this chapter, so we will select a few that will give you a great start in supervised machine learning.</p>
			<p>We have already seen the use of one method, <strong class="inline">head()</strong>, which provides the first five lines of the DataFrame. We can select more or less lines if we wish, by providing the number of lines as an argument, as shown here:</p>
			<p class="snippet">df.head(n=20) # 20 lines</p>
			<p class="snippet">df.head(n=32) # 32 lines</p>
			<p>Another useful method is <strong class="inline">describe</strong>, which is a super-quick way of getting the descriptive statistics of the data within a DataFrame. We can see next that the sample size (count), mean, minimum, maximum, standard deviation, and 25th, 50th, and 75th percentiles are returned for all columns of numerical data in the DataFrame (note that text columns have been omitted):</p>
			<p class="snippet">df.describe()</p>
			<div>
				<div id="_idContainer056" class="IMG---Figure">
					<img src="image/C12622_01_45.jpg" alt="Figure 1.45: The describe method"/>
				</div>
			</div>
			<h6>Figure 1.45: The describe method</h6>
			<p>Note that only columns of numerical data have been included within the summary. This simple command provides us with a lot of useful information; looking at the values for <strong class="inline">count</strong> (which counts the number of valid samples), we can see that there are 1,046 valid samples in the <strong class="inline">Age</strong> category, but 1,308 in <strong class="inline">Fare</strong>, and only 891 in <strong class="inline">Survived</strong>. We can see that the youngest person was 0.17 years, the average age is 29.898, and the eldest 80. The minimum fare was £0, with £33.30 the average and £512.33 the most expensive. If we look at the <strong class="inline">Survived</strong> column, we have 891 valid samples, with a mean of 0.38, which means about 38% survived.</p>
			<p>We can also get these values separately for eac<a id="_idTextAnchor031"/>h of the columns by calling the respective methods of the DataFrame, as shown here:</p>
			<p class="snippet">df.count()</p>
			<div>
				<div id="_idContainer057" class="IMG---Figure">
					<img src="image/C12622_01_46.jpg" alt="Figure 1.46: The count method"/>
				</div>
			</div>
			<h6>Figure 1.46: The count method</h6>
			<p>But we have some columns that contain text data, such as <strong class="inline">Embarked</strong>, <strong class="inline">Ticket</strong>, <strong class="inline">Name</strong>, and <strong class="inline">Sex</strong>. So, what about these? How can we get some descriptive information for these columns? We can still use <strong class="inline">describe</strong>; we just need to pass it some more information. By default, <strong class="inline">describe</strong> will only include numerical columns and will compute the 25th, 50th, and 75th percentiles. But we can configure this to include text-based columns by passing the <strong class="inline">include = 'all'</strong> argument, as shown here:</p>
			<p class="snippet">df.describe(include='all')</p>
			<div>
				<div id="_idContainer058" class="IMG---Figure">
					<img src="image/C12622_01_47.jpg" alt="Figure 1.47: The describe method with text-based columns"/>
				</div>
			</div>
			<h6>Figure 1.47: The describe method with text-based columns</h6>
			<p>That's better—now we have much more information. Looking at the <strong class="inline">Cabin</strong> column, we can see that there are 295 entries, with 186 unique values. The most common values are <strong class="inline">C32</strong>, <strong class="inline">C25</strong>, and <strong class="inline">C27</strong>, and they occur 6 times (from the <strong class="inline">freq</strong> value). Similarly, if we look at the <strong class="inline">Embarked</strong> column, we see that there are 1,307 entries, 3 unique values, and that the most commonly occurring value is <strong class="inline">S</strong> with 914 entries.</p>
			<p>Notice the occurrence of <strong class="inline">NaN</strong> values in our <strong class="inline">describe</strong> output table. <strong class="inline">NaN</strong>, or <strong class="bold">Not a Number</strong>, values are very important within DataFrames, as they represent missing or not available data. The ability of the pandas library to read from data sources that contain missing or incomplete information is both a blessing and a curse. Many other libraries would simply fail to import or read the data file in the event of missing information, while the fact that it can be read also means that the missing data must be handled appropriately.</p>
			<p>When looking at the output of the <strong class="inline">describe</strong> method, you should notice that the Jupyter notebook renders it in the same way as the original DataFrame that we read in using <strong class="inline">read_csv</strong>. There is a very good reason for this, as the results returned by the <strong class="inline">describe</strong> method are themselves a pandas DataFrame and thus possess the same methods and characteristics as the data read in from the CSV file. This can be easily verified using Python's built-in <strong class="inline">type</strong> function:</p>
			<div>
				<div id="_idContainer059" class="IMG---Figure">
					<img src="image/C12622_01_48.jpg" alt="Figure 1.48: Checking the type"/>
				</div>
			</div>
			<h6>Figure 1.48: Checking the type</h6>
			<p>Now that we have a summary of the dataset, let's dive in with a little more detail to get a better understanding of the available data.</p>
			<h4>Note</h4>
			<p class="callout">A comprehensive understanding of the available data is critical in any supervised learning problem. The source and type of the data, the means by which it is collected, and any errors potentially resulting from the collection process all have an effect on the performance of the final model.</p>
			<p>Hopefully, by now, you are comfortable with using pandas to provide a high-level overview of the data. We will now spend some time looking into the data in greater detail.</p>
			<h3 id="_idParaDest-31"><a id="_idTextAnchor032"/>Exercise 8: Splitting, Applying, and Combining Data Sources</h3>
			<p>We have already seen how we can index or select rows or columns from a DataFrame and use advanced indexing techniques to filter the available data based on specific criteria. Another handy method that allows for such selection is the <strong class="inline">groupby</strong> method, which provides a quick method for selecting groups of data at a time and provides additional functionality through the <strong class="inline">DataFrameGroupBy</strong> object:</p>
			<ol>
				<li value="1">Use the <strong class="inline">groupby</strong> method to group the data by the <strong class="inline">Embarked</strong> column. How many different values for <strong class="inline">Embarked</strong> are there? Let's see:<p class="snippet">embarked_grouped = df.groupby('Embarked')</p><p class="snippet">print(f'There are {len(embarked_grouped)} Embarked groups')</p><div id="_idContainer060" class="IMG---Figure"><img src="image/C12622_01_49.jpg" alt="Figure 1.49: Grouping the data by the Embarked column"/></div><h6>Figure 1.49: Grouping the data by the Embarked column</h6></li>
				<li>What does the <strong class="inline">groupby</strong> method actually do? Let's check. Display the output of <strong class="inline">embarked_grouped.groups</strong>:<p class="snippet">embarked_grouped.groups</p><div id="_idContainer061" class="IMG---Figure"><img src="image/C12622_01_50.jpg" alt="Figure 1.50: Output of embarked_grouped.groups"/></div><h6>Figure 1.50: Output of embarked_grouped.groups</h6><p>We can see here that the three groups are <strong class="inline">C</strong>, <strong class="inline">Q</strong>, and <strong class="inline">S</strong>, and that <strong class="inline">embarked_grouped.groups</strong> is actually a dictionary where the keys are the groups. The values are the rows or indexes of the entries that belong to that group.</p></li>
				<li>Use the <strong class="inline">iloc</strong> method to inspect row <strong class="inline">1</strong> and confirm that it belongs to embarked group <strong class="inline">C</strong>:<p class="snippet">df.iloc[1]</p><div id="_idContainer062" class="IMG---Figure"><img src="image/C12622_01_51.jpg" alt="Figure 1.51: Inspecting row 1"/></div><h6>Figure 1.51: Inspecting row 1</h6></li>
				<li>As the groups are a dictionary, we can iterate through them and execute computations on the individual groups. Compute the mean age for each group, as shown here:<p class="snippet">for name, group in embarked_grouped:</p><p class="snippet">    print(name, group.Age.mean())</p><div id="_idContainer063" class="IMG---Figure"><img src="image/C12622_01_52.jpg" alt="Figure 1.52: Computing the mean age for each group using iteration"/></div><h6>Figure 1.52: Computing the mean age for each group using iteration</h6></li>
				<li>Another option is to use the <strong class="inline">aggregate</strong> method, or <strong class="inline">agg</strong> for short, and provide it the function to apply across the columns. Use the <strong class="inline">agg</strong> method to determine the mean of each group:<p class="snippet">embarked_grouped.agg(np.mean)</p><div id="_idContainer064" class="IMG---Figure"><img src="image/C12622_01_53.jpg" alt="Figure 1.53: Using the agg method"/></div><h6>Figure 1.53: Using the agg method</h6><p>So, how exactly does <strong class="inline">agg</strong> work and what type of functions can we pass it? Before we can answer these questions, we need to first consider the data type of each column in the DataFrame, as each column is passed through this function to produce the result we see here. Each DataFrame is comprised of a collection of columns of pandas series data, which in many ways operates just like a list. As such, any function that can take a list or a similar iterable and compute a single value as a result can be used with <strong class="inline">agg</strong>.</p></li>
				<li>As an example, define a simple function that returns the first value in the column, then pass that function through to <strong class="inline">agg</strong>:<p class="snippet">def first_val(x):</p><p class="snippet">        </p><p class="snippet">    return x.values[0]</p><p class="snippet">embarked_grouped.agg(first_val)</p></li>
			</ol>
			<div>
				<div id="_idContainer065" class="IMG---Figure">
					<img src="image/C12622_01_54.jpg" alt="Figure 1.54: Using the agg method with a function"/>
				</div>
			</div>
			<h6>Figure 1.54: Using the agg method with a function</h6>
			<h3 id="_idParaDest-32"><a id="_idTextAnchor033"/>Lambda Functions</h3>
			<p>One common and useful way of implementing <strong class="inline">agg</strong> is through the use of Lambda functions.</p>
			<p><strong class="keyword">Lambda</strong> or anonymous functions (also known as inline functions in other languages) are small, single-expression functions that can be declared and used without the need for a formal function definition via use of the <strong class="inline">def</strong> keyword. Lambda functions are essentially provided for convenience and aren't intended to be used for extensive periods. The standard syntax for a Lambda function is as follows (always starting with the <strong class="inline">lambda</strong> keyword):</p>
			<p class="snippet">lambda &lt;input values&gt;: &lt;computation for values to be returned&gt;</p>
			<h3 id="_idParaDest-33"><a id="_idTextAnchor034"/>Exercise 9: Lambda Functions</h3>
			<p>In this exercise, we will create a Lambda function that returns the first value in a column and use it with <strong class="inline">agg</strong>:</p>
			<ol>
				<li value="1">Write the <strong class="inline">first_val</strong> function as a Lambda function, passed to <strong class="inline">agg</strong>:<p class="snippet">embarked_grouped.agg(lambda x: x.values[0])</p><div id="_idContainer066" class="IMG---Figure"><img src="image/C12622_01_55.jpg" alt="Figure 1.55: Using the agg method with a Lambda function"/></div><h6>Figure 1.55: Using the agg method with a Lambda function</h6><p>Obviously, we get the same result, but notice how much more convenient the Lambda function was to use, especially given the fact that it is only intended to be used briefly.</p></li>
				<li>We can also pass multiple functions to <strong class="inline">agg</strong> via a list to apply the functions across the dataset. Pass the Lambda function as well as the NumPy mean and standard deviation functions, like this:<p class="snippet">embarked_grouped.agg([lambda x: x.values[0], np.mean, np.std])</p><div id="_idContainer067" class="IMG---Figure"><img src="image/C12622_01_56.jpg" alt="Figure 1.56: Using the agg method with multiple Lambda functions"/></div><h6>Figure 1.56: Using the agg method with multiple Lambda functions</h6></li>
				<li>What if we wanted to apply different functions to different columns in the DataFrame? Apply <strong class="inline">numpy.sum</strong> to the <strong class="inline">Fare</strong> column and the Lambda function to the <strong class="inline">Age</strong> column by passing <strong class="inline">agg</strong> a dictionary where the keys are the columns to apply the function to and the values are the functions themselves:<p class="snippet">embarked_grouped.agg({</p><p class="snippet">    'Fare': np.sum,</p><p class="snippet">    'Age': lambda x: x.values[0]</p><p class="snippet">})</p><div id="_idContainer068" class="IMG---Figure"><img src="image/C12622_01_57.jpg" alt="Figure 1.57: Using the agg method with a dictionary of different columns"/></div><h6>Figure 1.57: Using the agg method with a dictionary of different columns</h6></li>
				<li>Finally, you can also execute the <strong class="inline">groupby</strong> method using more than one column. Provide the method with a list of the columns (<strong class="inline">Sex</strong> and <strong class="inline">Embarked</strong>) to <strong class="inline">groupby</strong>, like this:<p class="snippet">age_embarked_grouped = df.groupby(['Sex', 'Embarked'])</p><p class="snippet">age_embarked_grouped.groups</p></li>
			</ol>
			<div>
				<div id="_idContainer069" class="IMG---Figure">
					<img src="image/C12622_01_58.jpg" alt="Figure 1.58: Using the groupby method with more than one column"/>
				</div>
			</div>
			<h6>Figure 1.58: Using the groupby method with more than one column</h6>
			<p>Similar to when the groupings were computed by just the <strong class="inline">Embarked</strong> column, we can see here that a dictionary is returned where the keys are the combination of the <strong class="inline">Sex</strong> and <strong class="inline">Embarked</strong> columns returned as a tuple. The first key-value pair in the dictionary is a tuple, <strong class="inline">('Male', 'S')</strong>, and the values correspond to the indices of rows with that specific combination. There will be a key-value pair for each combination of unique values in the <strong class="inline">Sex</strong> and <strong class="inline">Embarked</strong> columns.</p>
			<h2 id="_idParaDest-34"><a id="_idTextAnchor035"/>Data Quality Considerations</h2>
			<p>The quality of data used in any machine learning problem, supervised or unsupervised, is critical to the performance of the final model, and should be at the forefront when planning any machine learning project. As a simple rule of thumb, if you have clean data, in sufficient quantity, with a good correlation between the input data type and the desired output, then the specifics regarding the type and details of the selected supervised learning model become significantly less important to achieve a good result.</p>
			<p>In reality, however, this can rarely be the case. There are usually some issues regarding the quantity of available data, the quality or <strong class="keyword">signal-to-noise ratio</strong> in the data, the correlation between the input and output, or some combination of all three factors. As such, we will use this last section of this chapter to consider some of the data quality problems that may occur and some mechanisms for addressing them. Previously, we mentioned that in any machine learning problem, having a thorough understanding of the dataset is critical if we to are construct a high-performing model. This is particularly the case when looking into data quality and attempting to address some of the issues present within the data. Without a comprehensive understanding of the dataset, additional noise or other unintended issues may be introduced during the data cleaning process leading to a further degradation of performance.</p>
			<h4>Note</h4>
			<p class="callout">A detailed description of the Titanic dataset and the type of data included is contained in the <em class="italics">Loading Data in pandas</em> section. If you need a quick refresher, go back and review these details now.</p>
			<h3 id="_idParaDest-35"><a id="_idTextAnchor036"/>Managing Missing Data</h3>
			<p>As we discussed earlier, the ability of pandas to read data with missing values is both a blessing and a curse and arguably is the most common issue that needs to be managed before we can continue with developing our supervised learning model. The simplest, but not necessarily the most effective, method is to just remove or ignore those entries that are missing data. We can easily do this in pandas using the <strong class="inline">dropna</strong> method of the DataFrame:</p>
			<p class="snippet">complete_data = df.dropna()</p>
			<p>There is one very significant consequence of simply dropping rows with missing data and that is we may be throwing away a lot of important information. This is highlighted very clearly in the Titanic dataset as a lot of rows contain missing data. If we were to simply ignore these rows, we would start with a sample size of 1,309 and end with a sample of 183 entries. Developing a reasonable supervised learning model with a little over 10% of the data would be very difficult indeed:</p>
			<div>
				<div id="_idContainer070" class="IMG---Figure">
					<img src="image/C12622_01_59.jpg" alt="Figure 1.59: Total number of rows and total number of rows with NaN values"/>
				</div>
			</div>
			<h6>Figure 1.59: Total number of rows and total number of rows with NaN values</h6>
			<p>So, with the exception of the early, explorative phase, it is rarely acceptable to simply discard all rows with invalid information. We can be a little more sophisticated about this though. Which rows are actually missing information? Is the missing information problem unique to certain columns or is it consistent throughout all columns of the dataset? We can use <strong class="inline">aggregate</strong> to help us here as well:</p>
			<p class="snippet">df.aggregate(lambda x: x.isna().sum())</p>
			<div>
				<div id="_idContainer071" class="IMG---Figure">
					<img src="image/C12622_01_60.jpg" alt="Figure 1.60: Using agg with a Lambda function to identify rows with NaN values"/>
				</div>
			</div>
			<h6>Figure 1.60: Using agg with a Lambda function to identify rows with NaN values</h6>
			<p>Now, this is useful! We can see that the vast majority of missing information is in the <strong class="inline">Cabin</strong> column, some in <strong class="inline">Age</strong>, and a little more in <strong class="inline">Survived</strong>. This is one of the first times in the data cleaning process that we may need to make an educated judgement call. </p>
			<p>What do we want to do with the <strong class="inline">Cabin</strong> column? There is so much missing information here that it, in fact, may not be possible to use it in any reasonable way. We could attempt to recover the information by looking at the names, ages, and number of parents/siblings and see whether we can match some families together to provide information, but there would be a lot of uncertainty in this process. We could also simplify the column by using the level of the cabin on the ship rather than the exact cabin number, which may then correlate better with name, age, and social status. This is unfortunate as there could be a good correlation between <strong class="inline">Cabin</strong> and <strong class="inline">Survived</strong>, as perhaps those passengers in the lower decks of the ship may have had a harder time evacuating. We could examine only the rows with valid <strong class="inline">Cabin</strong> values to see whether there is any predictive power in the <strong class="inline">Cabin</strong> entry; but, for now, we will simply disregard <strong class="inline">Cabin</strong> as a reasonable input (or feature).</p>
			<p>We can see that the <strong class="inline">Embarked</strong> and <strong class="inline">Fare</strong> columns only have three missing samples between them. If we decided that we needed the <strong class="inline">Embarked</strong> and <strong class="inline">Fare</strong> columns for our model, it would be a reasonable argument to simply drop these rows. We can do this using our indexing techniques, where <strong class="inline">~</strong> represents the <strong class="inline">not</strong> operation, or flipping the result (that is, where <strong class="inline">df.Embarked</strong> is not <strong class="inline">NaN</strong> and <strong class="inline">df.Fare</strong> is not <strong class="inline">NaN</strong>):</p>
			<p class="snippet">df_valid = df.loc[(~df.Embarked.isna()) &amp; (~df.Fare.isna())]</p>
			<p>The missing age values are a little more interesting, as there are too many rows with missing age values to just discard them. But we also have a few more options here, as we can have a little more confidence in some plausible values to fill in. The simplest option would be to simply fill in the missing age values with the mean age for the dataset:</p>
			<p class="snippet">df_valid[['Age']] = df_valid[['Age']].fillna(df_valid.Age.mean())</p>
			<p>This is OK, but there are probably better ways of filling in the data rather than just giving all 263 people the same value. Remember, we are trying to clean up the data with the goal of maximizing the predictive power of the input features and the survival rate. Giving everyone the same value, while simple, doesn't seem too reasonable. What if we were to look at the average ages of the members of each of the classes (<strong class="inline">Pclass</strong>)? This may give a better estimate, as the average age reduces from class 1 through 3:</p>
			<div>
				<div id="_idContainer072" class="IMG---Figure">
					<img src="image/C12622_01_61.jpg" alt="Figure 1.61: Average ages of the members of each of the classes"/>
				</div>
			</div>
			<h6>Figure 1.61: Average ages of the members of each of the classes</h6>
			<p>What if we consider sex as well as ticket class (social status)? Do the average ages differ here too? Let's find out:</p>
			<p class="snippet">for name, grp in df_valid.groupby(['Pclass', 'Sex']):</p>
			<p class="snippet">    print('%i' % name[0], name[1], '%0.2f' % grp['Age'].mean())</p>
			<div>
				<div id="_idContainer073" class="IMG---Figure">
					<img src="image/C12622_01_62.jpg" alt="Figure 1.62: Average ages of the members of each sex and class"/>
				</div>
			</div>
			<h6>Figure 1.62: Average ages of the members of each sex and class</h6>
			<p>We can see here that males in all ticket classes are typically older. This combination of sex and ticket class provides much more resolution than simply filling in all missing fields with the mean age. To do this, we will use the <strong class="inline">transform</strong> method, which applies a function to the contents of a series or DataFrame and returns another series or DataFrame with the transformed values. This is particularly powerful when combined with the <strong class="inline">groupby</strong> method:</p>
			<p class="snippet">mean_ages = df_valid.groupby(['Pclass', 'Sex'])['Age'].\</p>
			<p class="snippet">    transform(lambda x: x.fillna(x.mean()))</p>
			<p class="snippet">df_valid.loc[:, 'Age'] = mean_ages</p>
			<p>There is a lot in these two lines of code, so let's break them down into components. Let's look at the first line:</p>
			<p class="snippet">mean_ages = df_valid.groupby(['Pclass', 'Sex'])['Age'].\</p>
			<p class="snippet">    transform(lambda x: x.fillna(x.mean()))</p>
			<p>We are already familiar with <strong class="inline">df_valid.groupby(['Pclass', 'Sex'])['Age']</strong>, which groups the data by ticket class and sex and returns only the <strong class="inline">Age</strong> column. The <strong class="inline">lambda x: x.fillna(x.mean())</strong> Lambda function takes the input pandas series, and fills the <strong class="inline">NaN</strong> values with the mean value of the series.</p>
			<p>The second line assigns the filled values within <strong class="inline">mean_ages</strong> to the <strong class="inline">Age</strong> column. Note the use of the <strong class="inline">loc[:, 'Age']</strong> indexing method, which indicates that all rows within the <strong class="inline">Age</strong> column are to be assigned the values contained within <strong class="inline">mean_ages</strong>:</p>
			<p class="snippet">df_valid.loc[:, 'Age'] = mean_ages</p>
			<p>We have described a few different ways of filling in the missing values within the <strong class="inline">Age</strong> column, but by no means has this been an exhaustive discussion. There are many more methods that we could use to fill the missing data: we could apply random values within one standard deviation of the mean for the grouped data, we could also look at grouping the data by sex and the number of parents/children (<strong class="inline">Parch</strong>) or by the number of siblings, or by ticket class, sex, and the number of parents/children. What is most important about the decisions made during this process is the end result of the prediction accuracy. We may need to try different options, rerun our models and consider the effect on the accuracy of final predictions. This is an important aspect of the process of feature engineering, that is, selecting the features or components that provide the model with the most predictive power; you will find that, during this process, you will try a few different features, run the model, look at the end result and repeat, until you are happy with the performance.</p>
			<p>The ultimate goal of this supervised learning problem is to predict the survival of passengers on the Titanic given the information we have available. So, that means that the <strong class="inline">Survived</strong> column provides our labels for training. What are we going to do if we are missing 418 of the labels? If this was a project where we had control over the collection of the data and access to its origins, we would obviously correct this by recollecting or asking for the labels to be clarified. With the Titanic dataset, we do not have this ability so we must make another educated judgement call. We could try some unsupervised learning techniques to see whether there are some patterns in the survival information that we could use. However, we may not have a choice of simply ignoring these rows. The task is to predict whether a person survived or perished, not whether they may have survived. By estimating the ground truth labels, we may introduce significant noise into the dataset, reducing our ability to accurately predict survival.</p>
			<h3 id="_idParaDest-36"><a id="_idTextAnchor037"/>Class Imbalance</h3>
			<p>Missing data is not the only problem that may be present within a dataset. Class imbalance – that is, having more of one class or classes compared to another – can be a significant problem, particularly in the case of classification problems (we'll see more on classification in <em class="italics">Chapter 4</em>, <em class="italics">Classification</em>), where we are trying to predict which class (or classes) a sample is from. Looking at our <strong class="inline">Survived</strong> column, we can see that there are far more people who perished (<strong class="inline">Survived</strong> equals <strong class="inline">0</strong>) than survived (<strong class="inline">Survived</strong> equals <strong class="inline">1</strong>) in the dataset:</p>
			<div>
				<div id="_idContainer074" class="IMG---Figure">
					<img src="image/C12622_01_63.jpg" alt="Figure 1.63: Number of people who perished versus survived"/>
				</div>
			</div>
			<h6>Figure 1.63: Number of people who perished versus survived</h6>
			<p>If we don't take this class imbalance into account, the predictive power of our model could be significantly reduced as, during training, the model would simply need to guess that the person did not survive to be correct 61% (<em class="italics">549 / (549 + 342)</em>) of the time. If, in reality, the actual survival rate was, say, 50%, then when being applied to unseen data, our model would predict not survived too often. </p>
			<p>There are a few options available for managing class imbalance, one of which, similar to the missing data scenario, is to randomly remove samples from the over-represented class until balance has been achieved. Again, this option is not ideal, or perhaps even appropriate, as it involves ignoring available data. A more constructive example may be to oversample the under-represented class by randomly copying samples from the under-represented class in the dataset to boost the number of samples. While removing data can lead to accuracy issues due to discarding useful information, oversampling the under-represented class can lead to being unable to predict the label of unseen data, also known as overfitting (which we will cover in <em class="italics">Chapter 5</em>, <em class="italics">Ensemble Modeling</em>). </p>
			<p>Adding some random noise to the input features for oversampled data may prevent some degree of overfitting, but this is highly dependent on the dataset itself. As with missing data, it is important to check the effect of any class imbalance corrections on the overall model performance. It is relatively straightforward to copy more data into a DataFrame using the <strong class="inline">append</strong> method, which works in a very similar fashion to lists. If we wanted to copy the first row to the end of the DataFrame, we would do this:</p>
			<p class="snippet">df_oversample = df.append(df.iloc[0])</p>
			<h3 id="_idParaDest-37"><a id="_idTextAnchor038"/>Low Sample Size</h3>
			<p>The field of machine learning can be considered a branch of the larger field of statistics. As such, the principles of confidence and sample size can also be applied to understand the issues with a small dataset. Recall that if we were to take measurements from a data source with high variance, then the degree of uncertainty in the measurements would also be high and more samples would be required to achieve a specified confidence in the value of the mean. The sample principles can be applied to machine learning datasets. Those datasets with a variance in the features with the most predictive power generally require more samples for reasonable performance as more confidence is also required. </p>
			<p>There are a few techniques that can be used to compensate for a reduced sample size, such as transfer learning. However, these lie outside the scope of this book. Ultimately, though, there is only so much that can be done with a small dataset, and significant performance increases may only occur once the sample size is increased.</p>
			<h3 id="_idParaDest-38"><a id="_idTextAnchor039"/>Activity 1: pandas Functions</h3>
			<p>In this activity, we will test ourselves on the various pandas functions we have learned about in this chapter. We will use the same Titanic dataset for this.</p>
			<p>The steps to be performed are as follows:</p>
			<ol>
				<li value="1">Open a new Jupyter notebook.</li>
				<li>Use pandas to load the Titanic dataset and describe the summary data for all columns.</li>
				<li>We don't need the <strong class="inline">Unnamed: 0</strong> column. In <em class="italics">Exercise 7: Advanced Indexing and Selection</em>, we demonstrated how to remove the column using the <strong class="inline">del</strong> command. How else could we remove this column? Remove this column without using <strong class="inline">del</strong>.</li>
				<li>Compute the mean, standard deviation, minimum, and maximum values for the columns of the DataFrame without using <strong class="inline">describe</strong>.</li>
				<li>What about the 33, 66, and 99% quartiles? How would we get these values using their individual methods? Use the <strong class="inline">quantile</strong> method to do this (<a href="https://pandas.pydata.org/pandas-docs/stable/reference/frame.html">https://pandas.pydata.org/pandas-docs/stable/reference/frame.html</a>).</li>
				<li>How many passengers were from each class? Find the answer using the <strong class="inline">groupby</strong> method.</li>
				<li>How many passengers were from each class? Find the answer by using selecting/indexing methods to count the members of each class.<p>Confirm that the answers to <em class="italics">Step 6</em> and <em class="italics">Step 7</em> match.</p></li>
				<li>Determine who the eldest passenger in third class was.</li>
				<li>For a number of machine learning problems, it is very common to scale the numerical values between 0 and 1. Use the <strong class="inline">agg</strong> method with Lambda functions to scale the <strong class="inline">Fare</strong> and <strong class="inline">Age</strong> columns between 0 and 1.</li>
				<li>There is one individual in the dataset without a listed <strong class="inline">Fare</strong> value, which can be found out as follows:<p class="snippet">df_nan_fare = df.loc[(df.Fare.isna())]</p><p class="snippet">df_nan_fare</p><p>The output will be as follows:</p></li>
			</ol>
			<div>
				<div id="_idContainer075" class="IMG---Figure">
					<img src="image/C12622_01_64.jpg" alt="Figure 1.64: Individual without a listed Fare value"/>
				</div>
			</div>
			<h6>Figure 1.64: Individual without a listed Fare value</h6>
			<p>Replace the <strong class="inline">NaN</strong> value of this row in the main DataFrame with the mean <strong class="inline">Fare</strong> value for those corresponding with the same class and <strong class="inline">Embarked</strong> location using the <strong class="inline">groupby</strong> method.</p>
			<h4>Note</h4>
			<p class="callout">The solution for this activity can found on page 300.</p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor040"/>Summary</h2>
			<p>In this chapter, we introduced the concept of supervised machine learning, along with a number of use cases, including the automation of manual tasks such as identifying hairstyles from the 1960s and 1980s. In this introduction, we encountered the concept of labeled datasets and the process of mapping one information set (the input data or features) to the corresponding labels.</p>
			<p>We took a practical approach to the process of loading and cleaning data using Jupyter notebooks and the extremely powerful pandas library. Note that this chapter has only covered a small fraction of the functionality within pandas, and that an entire book could be dedicated to the library itself. It is recommended that you become familiar with reading the pandas documentation and continue to develop your pandas skills through practice.</p>
			<p>The final section of this chapter covered a number of data quality issues that need to be considered to develop a high-performing supervised learning model, including missing data, class imbalance, and low sample sizes. We discussed a number of options for managing such issues and emphasized the importance of checking these mitigations against the performance of the model.</p>
			<p>In the next chapter, we will extend upon the data cleaning process that we covered and will investigate the data exploration and visualization process. Data exploration is a critical aspect of any machine learning solution, as without a comprehensive knowledge of the dataset, it would be almost impossible to model the information provided.</p>
		</div>
	</body></html>