<html><head></head><body>
		<div>
			<div id="_idContainer009" class="Content">
			</div>
		</div>
		<div id="_idContainer010" class="Content">
			<h1 id="_idParaDest-23"><a id="_idTextAnchor022"/>1. Introduction to Clustering</h1>
		</div>
		<div id="_idContainer035" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">Finding insights and value in data is the ambitious promise that has been seen in the rise of machine learning. Within machine learning, there are predictive approaches to understanding dense information in deeper ways, as well as approaches to predicting outcomes based on changing inputs. In this chapter, we will learn what supervised learning and unsupervised learning are, and how they are applied to different use cases. Once you have a deeper understanding of where unsupervised learning is useful, we will walk through some foundational techniques that provide value quickly.</p>
			<p class="callout">By the end of this chapter, you will be able to implement k-means clustering algorithms using built-in Python packages and calculate the silhouette score.</p>
			<h1 id="_idParaDest-24"><a id="_idTextAnchor023"/>Introduction</h1>
			<p>Have you ever been asked to take a look at some data and came up empty handed? Maybe you weren't familiar with the dataset, or maybe you didn't even know where to start. This may have been extremely frustrating, and even embarrassing, depending on who asked you to take care of the task. </p>
			<p>You are not alone, and, interestingly enough, there are many times the data itself is simply too confusing to be made sense of. As you try and figure out what all those numbers in your spreadsheet mean, you're most likely mimicking what many unsupervised algorithms do when they try to find meaning in data. The reality is that many unprocessed real-world datasets may not have any useful insights. One example to consider is the fact that these days, individuals generate massive amounts of granular data on a daily basis – whether it's their actions on a website, their purchase history, or what apps they use on their phone. If you were to look at this information on the surface, it would be a big, unorganized mess with no hope of clarity. Don't fret, however; this book will prepare you for such tall tasks so that you'll never be frustrated again when dealing with data exploration tasks, no matter how large.</p>
			<p>For this book, we have developed some best-in-class content to help you understand how unsupervised algorithms work and where to use them. We'll cover some of the foundations of finding clusters in your data, how to reduce the size of your data so it's easier to understand, and how each of these sides of unsupervised learning can be applied in the real world. We hope you will come away from this book with a strong real-world understanding of unsupervised learning, the problems that it can solve, and those it cannot. </p>
			<h1 id="_idParaDest-25"><a id="_idTextAnchor024"/>Unsupervised Learning versus Supervised Learning</h1>
			<p><strong class="bold">Unsupervised learning</strong> is the field of practice that helps find patterns in cluttered data and is one of the most exciting areas of development in machine learning today. If you have explored machine learning bookwork before, you are probably familiar with the common breakout of problems in either supervised or unsupervised learning. <strong class="bold">Supervised learning</strong> encompasses the problem set of having a labeled dataset that can be used to either classify data (for example, predicting smokers and non-smokers, if you're looking at a lung health dataset) or finding a pattern in clearly defined data (for example, predicting the sale price of a home based on how many bedrooms it has). This model most closely mirrors an intuitive human approach to learning. </p>
			<p>For example, if you wanted to learn how to not burn your food with a basic understanding of cooking, you could build a dataset by putting your food on the burner and seeing how long it takes (input) for your food to burn (output). Eventually, as you continue to burn your food, you will build a mental model of when burning will occur and how to avoid it in the future. Development in supervised learning was once fast paced and valuable, but it has simmered down in recent years. Many of the obstacles around getting to know your data have already been tackled and are listed in the following image:</p>
			<div>
				<div id="_idContainer011" class="IMG---Figure">
					<img src="image/B15923_01_01.jpg" alt="Figure 1.1: Differences between unsupervised and supervised learning&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.1: Differences between unsupervised and supervised learning</p>
			<p>Conversely, unsupervised learning encompasses the problem set of having a tremendous amount of data that is unlabeled. Labeled data, in this case, would be data that has a supplied "target" outcome that you are trying to find the correlation to with supplied data. F<a id="_idTextAnchor025"/>or instance, in the preceding example, you know that your "target outcome" is whether your food was burned; this is an example of labeled data. Unlabeled data is when you do not know what the "target" outcome is, and you have only supplied input data.</p>
			<p>Building upon the previous example, imagine you were just dropped on planet Earth with zero knowledge of how cooking works. You are given 100 days, a stove, and a fridge full of food without any instructions on what to do. Your initial exploration of a kitchen could go in infinite directions. On day 10, you may finally learn how to open the fridge; on day 30, you may learn that food can go on the stove; and after many more days, you may unwittingly make an edible meal. As you can see, trying to find meaning in a kitchen devoid of adequate informational structure leads to very noisy data that is completely irrelevant to actually preparing a meal. </p>
			<p>Unsupervised learning can be an answer to this problem. Looking back at your 100 days of data, you can use <strong class="bold">clustering</strong> to find patterns of similar attributes across days and deduce which foods are similar and may lead to a "good" meal. However, unsupervised learning isn't a magical answer. Simply finding clusters can be just as likely to help you find pockets of similar, yet ultimately useless, data. Expanding on the cooking example, we can illustrate this shortcoming with the concept of the "third variable". Just because you have a cluster of really great recipes doesn't mean they are infallible. During your research, you may have found a unifying factor that all good meals were cooked on a stove. This does not mean that every meal cooked on a stove will be good, and you cannot easily jump to that conclusion for all future scenarios.</p>
			<p>This challenge is what makes unsupervised learning so exciting. How can we find smarter techniques to speed up the process of finding clusters of information that are beneficial to our end goals? The following sections would help us answer this question.</p>
			<h1 id="_idParaDest-26"><a id="_idTextAnchor026"/>Clustering</h1>
			<p>Clustering is the overarching process that involves finding groups of similar data that exist in your dataset, which can be extremely valuable if you are trying to find its underlying meaning. If you were a store owner and you wanted to understand which customers are more valuable without a set idea of what valuable is, clustering would be a great place to start to find patterns in your data. You may have a few high-level ideas of what denotes a valuable customer, but you aren't entirely sure in the face of a large mountain of available data. Through clustering, you can find commonalities among similar groups in your data. For example, if you look more deeply at a cluster of similar people, you may learn that everyone in that group visits your website for longer periods of time than others. This can show you what the value is and also provide a clean sample size for future supervised learning experiments. </p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor027"/>Identifying Clusters</h2>
			<p>The following image shows two scatterplots:</p>
			<div>
				<div id="_idContainer012" class="IMG---Figure">
					<img src="image/B15923_01_02.jpg" alt="Figure 1.2: Two distinct scatterplots&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.2: Two distinct scatterplots</p>
			<p>The following image separates the two scatterplots into two distinct clusters:</p>
			<div>
				<div id="_idContainer013" class="IMG---Figure">
					<img src="image/B15923_01_03.jpg" alt="Figure 1.3: Scatterplots clearly showing clusters that exist in a provided dataset&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.3: Scatterplots clearly showing clusters that exist in a provided dataset</p>
			<p><em class="italic">Figure 1.2</em> and <em class="italic">Figure 1.3</em> display randomly generated number pairs (x and y coordinates) pulled from two distinct Gaussian distributions centered at different locations. Simply by glancing at the first image, it should be obvious where the clusters exist in your data; in real life, it will never be this easy. Now that you know that the data can be clearly separated into two clusters, you can start to understand what differences exist between the two groups.</p>
			<p>Rewinding a bit from where unsupervised learning fits into the larger machine learning environment, let's begin by understanding the building blocks of clustering. The most basic definition finds clusters simply as groupings of similar data as subsets of a larger dataset. As an example, imagine that you had a room with 10 people in it and each person had a job either in finance or as a scientist. If you told all the financial workers to stand together and all the scientists to do the same, you would have effectively formed two clusters based on job types. Finding clusters can be immensely valuable in identifying items that are more similar and, on the other end of the scale, quite different from one another. </p>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor028"/>Two-Dimensional Data</h2>
			<p>To understand this, imagine that you were given a simple 1,000-row dataset by your employer that had two columns of numerical data, as follows:</p>
			<div>
				<div id="_idContainer014" class="IMG---Figure">
					<img src="image/B15923_01_04.jpg" alt="Figure 1.4: Two-dimensional raw data in an array&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.4: Two-dimensional raw data in an array</p>
			<p>At first glance, this dataset provides no real structure or understanding.</p>
			<p>A <strong class="bold">dimension</strong> in a dataset is another way of simply counting the number of features available. In most organized data tables, you can view the number of features as the number of columns. So, using the 1,000-row dataset example of size (1,000 x 2), you will have 1,000 observations across two dimensions. Please note that dimensions of dataset should not be confused with the dimensions of an array.</p>
			<p>You begin by plotting the first column against the second column to get a better idea of what the data structure looks like. There will be plenty of times where the cause of differences between groups will prove to be underwhelming; however, the cases that have differences that you can take action on are extremely rewarding.</p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor029"/>Exercise 1.01: Identifying Clusters in Data</h2>
			<p>You are given two-dimensional plots of data that you suspect have clusters of similar data. Please look at the two-dimensional graphs provided in the exercise and identify the groups of data points to drive the point home that machine learning is important. Without using any algorithmic approaches, identify where these clusters exist in the data.</p>
			<p>This exercise will help you start building your intuition of how we can identify clusters using our own eyes and thought processes. As you complete this exercise, think of the rationale of why a group of data points should be considered a cluster versus a group that should not be considered a cluster. Follow these steps to complete this exercise:</p>
			<ol>
				<li>Identify the clusters in the following scatterplot:<div id="_idContainer015" class="IMG---Figure"><img src="image/B15923_01_05.jpg" alt="Figure 1.5: Two-dimensional scatterplot&#13;&#10;"/></div><p class="figure-caption">Figure 1.5: Two-dimensional scatterplot</p><p>The clusters are as follows:</p><div id="_idContainer016" class="IMG---Figure"><img src="image/B15923_01_06.jpg" alt="Figure 1.6: Clusters in the scatterplot&#13;&#10;"/></div><p class="figure-caption">Figure 1.6: Clusters in the scatterplot</p></li>
				<li>Identify the clusters in the following scatterplot:<div id="_idContainer017" class="IMG---Figure"><img src="image/B15923_01_07.jpg" alt="Figure 1.7: Two-dimensional scatterplot&#13;&#10;"/></div><p class="figure-caption">Figure 1.7: Two-dimensional scatterplot</p><p>The clusters are as follows:</p><div id="_idContainer018" class="IMG---Figure"><img src="image/B15923_01_08.jpg" alt="Figure 1.8: Clusters in the scatterplot&#13;&#10;"/></div><p class="figure-caption">Figure 1.8: Clusters in the scatterplot</p></li>
				<li>Identify the clusters in the following scatterplot:<div id="_idContainer019" class="IMG---Figure"><img src="image/B15923_01_09.jpg" alt="Figure 1.9: Two-dimensional scatterplot&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 1.9: Two-dimensional scatterplot</p>
			<p>The clusters are as follows:</p>
			<div>
				<div id="_idContainer020" class="IMG---Figure">
					<img src="image/B15923_01_10.jpg" alt="Figure 1.10: Clusters in the scatterplot&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.10: Clusters in the scatterplot</p>
			<p>Most of these examples were likely quite easy for you to understand, and that's the point. The human brain and eyes are incredible at finding patterns in the real world. Within milliseconds of viewing each plot, you could tell what fitted together and what didn't. While it is easy for you, a computer does not have the ability to see and process plots in the same manner that we do. </p>
			<p>However, this is not always a bad thing. Look back at the preceding scatterplot. Were you able to find the six discrete clusters in the data just by looking at the plot? You probably found only three to four clusters in this scatterplot, while a computer would be able to see all six. The human brain is magnificent, but it also lacks the nuances that come with a strictly logic-based approach. Through algorithmic clustering, you will learn how to build a model that works even better than a human at these tasks.</p>
			<p>We'll look at the clustering algorithm in the next section.</p>
			<h1 id="_idParaDest-30"><a id="_idTextAnchor030"/>Introduction to k-means Clustering</h1>
			<p>Hopefully, by now, you can see that finding clusters is extremely valuable in a machine learning workflow. But, how can you actually find these clusters? One of the most basic yet popular approaches is to use a cluster analysis technique called <strong class="bold">k-means clustering</strong>. The k-means clustering works by searching for k clusters in your data and the workflow is actually quite intuitive. We will start with the no-math introduction to k-means, followed by an implementation in Python. <strong class="bold">Cluster membership</strong> refers to where the points go as the algorithm processes the data. Consider it like choosing players for a sports team, where all the players are in a pool but, for each successive run, the player is assigned to a team (in this case, a cluster).</p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor031"/>No-Math k-means Walkthrough</h2>
			<p>The no-math algorithm for k-means clustering is pretty simple:</p>
			<ol>
				<li value="1">First, we'll pick "k" centroids, where "k" would be the expected distinct number of clusters. The value of k will be chosen by us and determines the type of clustering we obtain.</li>
				<li>Then, we will place the "k" centroids at random places among the existing training data.</li>
				<li>Next, the distance from each centroid to all the points in the training data will be calculated. We will go into detail about distance functions shortly, but for now, let's just consider it as how far points are from each other.</li>
				<li>Now, all the training points will be grouped with their nearest centroid.</li>
				<li>Isolating the grouped training points along with their respective centroid, calculate the mean data point in the group and move the previous centroid to the mean location.</li>
				<li>This process is to be repeated until convergence or until maximum iteration limit has been achieved.</li>
			</ol>
			<p>And that's it. The following image represents original raw data:</p>
			<div>
				<div id="_idContainer021" class="IMG---Figure">
					<img src="image/B15923_01_11.jpg" alt="Figure 1.11: Original raw data charted on x and y coordinates&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.11: Original raw data charted on x and y coordinates</p>
			<p>Provided with the original data in the preceding image, we can visualize the iterative process of k-means by showing the predicted clusters in each step:</p>
			<div>
				<div id="_idContainer022" class="IMG---Figure">
					<img src="image/B15923_01_12.jpg" alt="Figure 1.12: Reading from left to right, red points are randomly initialized centroids, &#13;&#10;and the closest data points are assigned to groupings of each centroid&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.12: Reading from left to right, red points are randomly initialized centroids, and the closest data points are assigned to groupings of each centroid</p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor032"/>K-means Clustering In-Depth Walkthrough </h2>
			<p>To understand k-means at a deeper level, let's walk through the example that was provided in the introduction again with some of the math that supports k-means. The most important math that underpins this algorithm is the distance function. A distance function is basically any formula that allows you to quantitatively understand how far one object is from another, with the most popular one being the Euclidean distance formula. This formula works by subtracting the respective components of each point and squaring to remove negatives, followed by adding the resulting distances and square rooting them:</p>
			<div>
				<div id="_idContainer023" class="IMG---Figure">
					<img src="image/B15923_01_13.jpg" alt="Figure 1.13: Euclidean distance formula&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.13: Euclidean distance formula</p>
			<p>If you notice, the preceding formula holds true for data points having only two dimensions (the number of co-ordinates). A generic way of representing the preceding equation for higher-dimensional points is as follows:</p>
			<div>
				<div id="_idContainer024" class="IMG---Figure">
					<img src="image/B15923_01_14.jpg" alt="Figure 1.14: Euclidean distance formula for higher dimensional points&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.14: Euclidean distance formula for higher dimensional points</p>
			<p>Let's see the terms involved in calculation of Euclidean distance between two points <em class="italic">p</em> and <em class="italic">q</em> in a higher dimensional space. Here, <em class="italic">n</em> is the number of dimensions of the two points. We compute the difference between the respective components of points <em class="italic">p</em> and <em class="italic">q</em> (<em class="italic">p</em><span class="subscript">i</span> and <em class="italic">q</em><span class="subscript">i</span> are known as the <em class="italic">i</em><span class="superscript">th</span> component of point <em class="italic">p</em> and <em class="italic">q</em> respectively) and square each of them. This squared value of the difference is summed up for all <em class="italic">n</em> components, and then square root of this sum is obtained. This value represents the Euclidean distance between point <em class="italic">p</em> and <em class="italic">q</em>. If you substitute n = 2 in the preceding equation, it will decompose to the equation represented in <em class="italic">Figure 1.13</em>.</p>
			<p>Now coming back again to our discussion on k-means. Centroids are randomly set at the beginning as points in your n-dimensional space. Each of these centers is fed into the preceding formula as (<em class="italic">a</em>, <em class="italic">b</em>), and a point in your space is fed in as (<em class="italic">x</em>, <em class="italic">y</em>). Distances are calculated between each point and the coordinates of every centroid, with the centroid the shortest distance away chosen as the point's group. </p>
			<p>As an example, let's pick three random centroids, an arbitrary point, and, using the Euclidean distance formula, calculate the distance from each point to the centroid:</p>
			<ul>
				<li>Random centroids: [ (2,5), (8,3), (4,5) ].</li>
				<li>Arbitrary point x: (0, 8).</li>
				<li>Distance from point to each centroid: [ 3.61, 9.43, 5.00 ]. </li>
			</ul>
			<p>Since the arbitrary point x is closest to the first centroid, it will be assigned to the first centroid.</p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor033"/>Alternative Distance Metric – Manhattan Distance</h2>
			<p>Euclidean distance is the most common distance metric for many machine learning applications and is often known colloquially as the distance metric; however, it is not the only, or even the best, distance metric for every situation. Another popular distance metric that can be used for clustering is <strong class="bold">Manhattan distance</strong>.</p>
			<p>Manhattan distance is called as such because it mirrors the concept of traveling through a metropolis (such as New York City) that has many square blocks. Euclidean distance relies on diagonals due to its basis in Pythagorean theorem, while Manhattan distance constrains distance to only right angles. The formula for Manhattan distance is as follows: </p>
			<div>
				<div id="_idContainer025" class="IMG---Figure">
					<img src="image/B15923_01_15.jpg" alt="Figure 1.15: Manhattan distance formula&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.15: Manhattan distance formula</p>
			<p>Here <em class="italic">p</em><span class="subscript">i</span> and <em class="italic">q</em><span class="subscript">i</span> are the <em class="italic">i</em><span class="superscript">th</span> component of points <em class="italic">p</em> and <em class="italic">q</em>, respectively. Building upon our examples of Euclidean distance, where we want to find the distance between two points, if our two points were (1,2) and (2,3), then the Manhattan distance would equal <strong class="source-inline">|1-2| + |2-3| = 1 + 1 = 2</strong>. This functionality scales to any number of dimensions. In practice, Manhattan distance may outperform Euclidean distance when it comes to high dimensional data.</p>
			<h2 id="_idParaDest-34"><a id="_idTextAnchor034"/>Deeper Dimensions</h2>
			<p>The preceding examples can be clearly visualized when your data is only two-dimensional. This is for convenience, to help drive the point home of how k-means works and could lead you into a false understanding of how easy clustering is. In many of your own applications, your data will likely be orders of magnitude larger to the point that it cannot be perceived by visualization (anything beyond three dimensions will be unperceivable to humans). In the previous examples, you could mentally work out a few two-dimensional lines to separate the data into its own groups. At higher dimensions, you will need to be aided by a computer to find an n-dimensional hyperplane that adequately separates the dataset. In practice, this is where clustering methods such as k-means provide significant value. The following image shows the two-dimensional, three-dimensional, and n-dimensional plots:</p>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="image/B15923_01_16.jpg" alt="Figure 1.16: Two-dimensional, three-dimensional, and n-dimensional plots&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.16: Two-dimensional, three-dimensional, and n-dimensional plots</p>
			<p>In the next exercise, we will calculate Euclidean distance. We'll build our set of tools by using the <strong class="source-inline">NumPy</strong> and <strong class="source-inline">Math</strong> Python packages. <strong class="source-inline">NumPy</strong> is a scientific computing package for Python that pre-packages common mathematical functions in highly optimized formats. </p>
			<p>As the name implies, the <strong class="source-inline">Math</strong> package is a basic library that makes implementing foundational math building blocks, such as exponentials and square roots, much easier. By using a package such as <strong class="source-inline">NumPy</strong> or <strong class="source-inline">Math</strong>, we help cut down the time spent creating custom math functions from scratch and instead focus on developing our solutions. You will see how each of these packages is used in practice in the following exercise.</p>
			<h2 id="_idParaDest-35"><a id="_idTextAnchor035"/>Exercise 1.02: Calculating Euclidean Distance in Python</h2>
			<p>In this exercise, we will create an example point along with three sample centroids to help illustrate how Euclidean distance works. Understanding this distance formula is the basis for the rest of our work in clustering. </p>
			<p>Perform the following steps to complete this exercise: </p>
			<ol>
				<li value="1">Open a Jupyter notebook and create a naïve formula that captures the direct math of Euclidean distance, as follows: <p class="source-code">import math</p><p class="source-code">import numpy as np</p><p class="source-code">def dist(a, b):</p><p class="source-code">    return math.sqrt(math.pow(a[0]-b[0],2) \</p><p class="source-code">                     + math.pow(a[1]-b[1],2))</p><p class="callout-heading">Note</p><p class="callout">The code snippet shown here uses a backslash ( <strong class="source-inline">\</strong> ) to split the logic across multiple lines. When the code is executed, Python will ignore the backslash, and treat the code on the next line as a direct continuation of the current line.</p><p>This approach is considered naïve because it performs element-wise calculations on your data points (slow) compared to a more real-world implementation using vectors and matrix math to achieve significant performance increases.</p></li>
				<li>Create the data points in Python as follows:<p class="source-code">centroids = [ (2, 5), (8, 3), (4,5) ]</p><p class="source-code">x = (0, 8)</p></li>
				<li>Use the formula you created to calculate the Euclidean distance in <em class="italic">Step 1</em>:<p class="source-code"># Calculating Euclidean Distance between x and centroid</p><p class="source-code">centroid_distances =[]</p><p class="source-code">for centroid in centroids:</p><p class="source-code">    print("Euclidean Distance between x {} and centroid {} is {}"\</p><p class="source-code">          .format(x ,centroid, dist(x,centroid)))</p><p class="source-code">    centroid_distances.append(dist(x,centroid))</p><p class="callout-heading">Note</p><p class="callout">The <strong class="source-inline">#</strong> symbol in the code snippet above denotes a code comment. Comments are added into code to help explain specific bits of logic.</p><p>The output is as follows:</p><p class="source-code">Euclidean Distance between x (0, 8) and centroid (2, 5) </p><p class="source-code">is 3.605551275463989</p><p class="source-code">Euclidean Distance between x (0, 8) and centroid (8, 3) </p><p class="source-code">is 9.433981132056603</p><p class="source-code">Euclidean Distance between x (0, 8) and centroid (4, 5) is 5.0</p><p>The shortest distance between our point, <strong class="source-inline">x</strong>, and the centroids is <strong class="source-inline">3.61</strong>, which is equivalent to the distance between <strong class="source-inline">(0, 8)</strong> and <strong class="source-inline">(2, 5)</strong>. Since this is the minimum distance, our example point, <strong class="source-inline">x</strong>, will be assigned as a member of the first centroid's group.</p></li>
			</ol>
			<p>In this example, our formula was used on a single point, x (0, 8). Beyond this single point, the same process will be repeated for every remaining point in your dataset until each point is assigned to a cluster. After each point is assigned, the mean point is calculated among all of the points within each cluster. The calculation of the mean among these points is the same as calculating the mean between single integers. </p>
			<p>While there was only one point in this example, by completing this process, you have effectively assigned a point to its first cluster using Euclidean distance. We'll build upon this approach with more than one point in the following exercise.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/2VUvCuz">https://packt.live/2VUvCuz</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/3ebDwpZ">https://packt.live/3ebDwpZ</a>.</p>
			<h2 id="_idParaDest-36"><a id="_idTextAnchor036"/>Exercise 1.03: Forming Clusters with the Notion of Distance</h2>
			<p>It is very intuitive for our human minds to see groups of dots on a plot and determine which dots belong to discrete clusters. However, how do we ask a computer to repeat this same task? In this exercise, you'll help teach a computer an approach to forming clusters of its own with the notion of distance. We will build upon how we use these distance metrics in the next exercise:</p>
			<ol>
				<li value="1">Create a list of points, [ (0,8), (3,8), (3,4) ], that are assigned to cluster one:<p class="source-code">cluster_1_points =[ (0,8), (3,8), (3,4) ]</p></li>
				<li>To find the new centroid among your list of points, calculate the mean point between all of the points. Calculation of the mean scales to infinite points, as you simply add the integers at each position and divide by the total number of points. For example, if your two points are (0,1,2) and (3,4,5), the mean calculation would be [ (0+3)/2, (1+4)/2, (2+5)/2 ]:<p class="source-code">mean =[ (0+3+3)/3, (8+8+4)/3 ]</p><p class="source-code">print(mean)</p><p>The output is as follows:</p><p class="source-code">[2.0, 6.666666666666667]</p><p>After a new centroid is calculated, repeat the cluster membership calculation we looked at in <em class="italic">Exercise 1.02</em>, <em class="italic">Calculating Euclidean Distance in Python</em>, and then repeat the previous two steps to find the new cluster centroid. Eventually, the new cluster centroid will be the same as the centroid before the cluster membership calculation and the exercise will be complete. How many times this repeats depends on the data you are clustering.</p><p>Once you have moved the centroid location to the new mean point of (2, 6.67), you can compare it to the initial list of centroids you entered the problem with. If the new mean point is different than the centroid that is currently in your list, you will have to go through another iteration of the preceding two exercises. Once the new mean point you calculate is the same as the centroid you started the problem with, you have completed a run of k-means and reached a point called <strong class="bold">convergence</strong>. However, in practice, sometimes the number of iterations required to reach convergence is very large and such large computations may not be practically feasible. In such cases, we need to set a maximum limit to the number of iterations. Once this iteration limit is reached, we stop further processing.</p><p class="callout-heading">Note</p><p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/3iJ3JiT">https://packt.live/3iJ3JiT</a>.</p><p class="callout">You can also run this example online at <a href="https://packt.live/38CCpOG">https://packt.live/38CCpOG</a>.</p></li>
			</ol>
			<p>In the next exercise, we will implement k-means from scratch. To do this, we will start employing common packages from the Python ecosystem that will serve as building blocks for the rest of your career. One of the most popular machine learning libraries is called scikit-learn (<a href="https://scikit-learn.org/stable/user_guide.html">https://scikit-learn.org/stable/user_guide.html</a>), which has many built-in algorithms and functions to support your understanding of how the algorithms work. We will also be using functions from SciPy (<a href="https://docs.scipy.org/doc/scipy/reference/">https://docs.scipy.org/doc/scipy/reference/</a>), which is a package much like NumPy and abstracts away basic scientific math functions that allow for more efficient deployment. Finally, the next exercise will introduce <strong class="source-inline">matplotlib</strong> (<a href="https://matplotlib.org/3.1.1/contents.html">https://matplotlib.org/3.1.1/contents.html</a>), which is a plotting library that creates graphical representations of the data you are working with.</p>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor037"/>Exercise 1.04: K-means from Scratch – Part 1: Data Generation</h2>
			<p>The next two exercises focus on the creation of exercise data and the implementation of k-means from scratch on your training data. This exercise relies on scikit-learn, an open source Python package that enables the fast prototyping of popular machine learning models. Within scikit-learn, we will be using the <strong class="source-inline">datasets</strong> functionality to create a synthetic blob dataset. In addition to harnessing the power of scikit-learn, we will also rely on Matplotlib, a popular plotting library for Python that makes it easy for us to visualize our data. To do this, perform the following steps:</p>
			<ol>
				<li value="1">Import the necessary libraries:<p class="source-code">from sklearn.datasets import make_blobs</p><p class="source-code">from sklearn.cluster import KMeans</p><p class="source-code">import matplotlib.pyplot as plt</p><p class="source-code">import numpy as np</p><p class="source-code">import math</p><p class="source-code">np.random.seed(0)</p><p class="source-code">%matplotlib inline</p><p class="callout-heading">Note</p><p class="callout">You can find more details on the <strong class="source-inline">KMeans</strong> library at <a href="https://scikit-learn.org/stable/modules/clustering.html#k-means">https://scikit-learn.org/stable/modules/clustering.html#k-means</a>.</p></li>
				<li>Generate a random cluster dataset to experiment on X = coordinate points, y = cluster labels, and define random centroids. We will achieve this with the <strong class="source-inline">make_blobs</strong> function that we imported from <strong class="source-inline">sklearn.datasets</strong>, which, as the name implies, generates blobs of data points. <p class="source-code">X, y = make_blobs(n_samples=1500, centers=3, \</p><p class="source-code">                  n_features=2, random_state=800)</p><p class="source-code">centroids = [[-6,2],[3,-4],[-5,10]]</p><p>Here the <strong class="source-inline">n_samples</strong> parameter determines the total number of data points generated by the blobs. The <strong class="source-inline">centers</strong> parameter determines the number of centroids for the blob. The <strong class="source-inline">n_feature</strong> attribute defines the number of dimensions generated by the dataset. Here, the data will be two dimensional. </p><p>In order to generate the same data points in all the iterations (which in turn are generated randomly) for reproducibility of results, we set the <strong class="source-inline">random_state</strong> parameter to <strong class="source-inline">800</strong>. Different values of the <strong class="source-inline">random_state</strong> parameter would yield different results. If we do not set the <strong class="source-inline">random_state</strong> parameter, each time on execution we will obtain different results.</p></li>
				<li>Print the data:<p class="source-code">X</p><p>The output is as follows:</p><p class="source-code">array([[-3.83458347,  6.09210705],</p><p class="source-code">       [-4.62571831,  5.54296865],</p><p class="source-code">       [-2.87807159, -7.48754592],</p><p class="source-code">       ...,</p><p class="source-code">       [-3.709726  , -7.77993633],</p><p class="source-code">       [-8.44553266, -1.83519866],</p><p class="source-code">       [-4.68308431,  6.91780744]])</p></li>
				<li>Plot the coordinate points using the scatterplot functionality we imported from <strong class="source-inline">matplotlib.pyplot</strong>. This function takes input lists of points and presents them graphically for ease of understanding. Please review the <strong class="source-inline">matplotlib</strong> documentation if you want to explore the parameters provided at a deeper level:<p class="source-code">plt.scatter(X[:, 0], X[:, 1], s=50, cmap='tab20b')</p><p class="source-code">plt.show()</p><p>The plot appears as follows:</p><div id="_idContainer027" class="IMG---Figure"><img src="image/B15923_01_17.jpg" alt="Figure 1.17: Plot of the coordinates&#13;&#10;"/></div><p class="figure-caption">Figure 1.17: Plot of the coordinates</p></li>
				<li>Print the array of <strong class="source-inline">y</strong>, which is the labels provided by scikit-learn and serves as the ground truth for comparison. <p class="callout-heading">Note </p><p class="callout">These labels will not be known to us in practice. This is just for us to cross verify our clustering in later stages.</p><p>Use the following code to print the array:</p><p class="source-code">y</p><p>The output is as follows:</p><p class="source-code">array([2, 2, 1, ..., 1, 0, 2])</p></li>
				<li>Plot the coordinate points with the correct cluster labels:<p class="source-code">plt.scatter(X[:, 0], X[:, 1], c=y,s=50, cmap='tab20b')</p><p class="source-code">plt.show()</p><p>The plot appears as follows:</p><div id="_idContainer028" class="IMG---Figure"><img src="image/B15923_01_18.jpg" alt="Figure 1.18: Plot of the coordinates with correct cluster labels&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 1.18: Plot of the coordinates with correct cluster labels</p>
			<p>By completing the preceding steps, you have generated the data and visually explored how it is put together. By visualizing the ground truth, you have established a baseline that provides a relative metric for algorithm accuracy.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/2JM8Q1S">https://packt.live/2JM8Q1S</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/3ecjKdT">https://packt.live/3ecjKdT</a>.</p>
			<p>With data in hand, in the next exercise, we'll continue by building your unsupervised learning toolset with an optimized version of the Euclidean distance function from the <strong class="source-inline">SciPy</strong> package, <strong class="source-inline">cdist</strong>. You will compare a non-vectorized, clearly understandable version of the approach with <strong class="source-inline">cdist</strong>, which has been specially tweaked for maximum performance.</p>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor038"/>Exercise 1.05: K-means from Scratch – Part 2: Implementing k-means</h2>
			<p>Let's recreate these results on our own. We will go over an example implementing this with some optimizations. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">This exercise is a continuation of the previous exercise and should be performed in the same Jupyter notebook. </p>
			<p>For this exercise, we will rely on SciPy, a Python package that allows easy access to highly optimized versions of scientific calculations. In particular, we will be implementing Euclidean distance with <strong class="source-inline">cdist</strong>, the functionally of which replicates the barebones implementation of our distance metric in a much more efficient manner. Follow these steps to complete this exercise:</p>
			<ol>
				<li value="1">The basis of this exercise will be comparing a basic implementation of Euclidean distance with an optimized version provided in SciPy. First, import the optimized Euclidean distance reference:<p class="source-code">from scipy.spatial.distance import cdist</p></li>
				<li>Identify a subset of <strong class="source-inline">X</strong> you want to explore. For this example, we are only selecting five points to make the lesson clearer; however, this approach scales to any number of points. We chose points 105-109, inclusive:<p class="source-code">X[105:110]</p><p>The output is as follows:</p><p class="source-code">array([[-3.09897933,  4.79407445],</p><p class="source-code">       [-3.37295914, -7.36901393],</p><p class="source-code">       [-3.372895  ,  5.10433846],</p><p class="source-code">       [-5.90267987, -3.28352194],</p><p class="source-code">       [-3.52067739,  7.7841276 ]])</p></li>
				<li>Calculate the distances and choose the index of the shortest distance as a cluster:<p class="source-code">"""</p><p class="source-code">Finds distances from each of 5 sampled points to all of the centroids</p><p class="source-code">"""</p><p class="source-code">for x in X[105:110]:</p><p class="source-code">    calcs = cdist(x.reshape([1,-1]),centroids).squeeze()</p><p class="source-code">    print(calcs, "Cluster Membership: ", np.argmin(calcs))</p><p class="callout-heading">Note</p><p class="callout">The triple-quotes ( <strong class="source-inline">"""</strong> ) shown in the code snippet above are used to denote the start and end points of a multi-line code comment. Comments are added into code to help explain specific bits of logic.</p><p>The preceding code will result in the following output:</p><p class="source-code">[4.027750355981394, 10.70202290628413, 5.542160268055164] </p><p class="source-code"> Cluster Membership:  0</p><p class="source-code">[9.73035280174993, 7.208665829113462, 17.44505393393603] </p><p class="source-code"> Cluster Membership:  1</p><p class="source-code">[4.066767506545852, 11.113179986633003, 5.1589701124301515] </p><p class="source-code"> Cluster Membership:  0</p><p class="source-code">[5.284418164665783, 8.931464028407861, 13.314157359115697] </p><p class="source-code"> Cluster Membership:  0</p><p class="source-code">[6.293105164930943, 13.467921029846712, 2.664298385076878] </p><p class="source-code"> Cluster Membership:  2</p></li>
				<li>Define the <strong class="source-inline">k_means</strong> function as follows and initialize the k-centroids randomly. Repeat this process until the difference between the new/old <strong class="source-inline">centroids</strong> equals <strong class="source-inline">0</strong>, using the <strong class="source-inline">while</strong> loop:<p class="source-code-heading">Exercise1.04-Exercise1.05.ipynb</p><p class="source-code">def k_means(X, K):</p><p class="source-code">    # Keep track of history so you can see K-Means in action</p><p class="source-code">    centroids_history = []</p><p class="source-code">    labels_history = []</p><p class="source-code">    rand_index = np.random.choice(X.shape[0], K)  </p><p class="source-code">    centroids = X[rand_index]</p><p class="source-code">    centroids_history.append(centroids)</p><p class="source-code-link">The complete code for this step can be found at <a href="https://packt.live/2JM8Q1S">https://packt.live/2JM8Q1S</a>.</p><p class="callout-heading">Note</p><p class="callout">Do not break this code, as it might lead to an error.</p></li>
				<li>Zip together the historical steps of centers and their labels:<p class="source-code">history = zip(centers_hist, labels_hist)</p><p class="source-code">for x, y in history:</p><p class="source-code">    plt.figure(figsize=(4,3))</p><p class="source-code">    plt.scatter(X[:, 0], X[:, 1], c=y, s=50, cmap='tab20b');</p><p class="source-code">    plt.scatter(x[:, 0], x[:, 1], c='red')</p><p class="source-code">    plt.show()</p><p>The following plots may differ from what you can see if we haven't set the random seed. The first plot looks as follows:</p><div id="_idContainer029" class="IMG---Figure"><img src="image/B15923_01_19.jpg" alt="Figure 1.19: First scatterplot&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 1.19: First scatterplot</p>
			<p>The second plot appears as follows:</p>
			<div>
				<div id="_idContainer030" class="IMG---Figure">
					<img src="image/B15923_01_20.jpg" alt="Figure 1.20: Second scatterplot&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.20: Second scatterplot</p>
			<p>The third plot appears as follows:</p>
			<div>
				<div id="_idContainer031" class="IMG---Figure">
					<img src="image/B15923_01_21.jpg" alt="Figure 1.21: Third scatterplot&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.21: Third scatterplot</p>
			<p>The fourth plot appears as follows:</p>
			<div>
				<div id="_idContainer032" class="IMG---Figure">
					<img src="image/B15923_01_22.jpg" alt="Figure 1.22: Fourth scatterplot&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.22: Fourth scatterplot</p>
			<p>The fifth plot looks as follows:</p>
			<div>
				<div id="_idContainer033" class="IMG---Figure">
					<img src="image/B15923_01_23.jpg" alt="Figure 1.23: Fifth scatterplot&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.23: Fifth scatterplot</p>
			<p>As shown by the preceding images, k-means takes an iterative approach to refine optimal clusters based on distance. The algorithm starts with random initialization of centroids and, depending on the complexity of the data, quickly finds the separations that make the most sense.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/2JM8Q1S">https://packt.live/2JM8Q1S</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/3ecjKdT">https://packt.live/3ecjKdT</a>.</p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor039"/>Clustering Performance – Silhouette Score</h2>
			<p>Understanding the performance of unsupervised learning methods is inherently much more difficult than supervised learning methods because there is no ground truth available. For supervised learning, there are many robust performance metrics—the most straightforward of these being accuracy in the form of comparing model-predicted labels to actual labels and seeing how many the model got correct. Unfortunately, for clustering, we do not have labels to rely on and need to build an understanding of how "different" our clusters are. We achieve this with the silhouette score metric. We can also use silhouette scores to find the optimal "K" numbers of clusters for our unsupervised learning methods.</p>
			<p>The silhouette metric works by analyzing how well a point fits within its cluster. The metric ranges from -1 to 1. If the average silhouette score across your clustering is one, then you will have achieved perfect clusters and there will be minimal confusion about which point belongs where. For the plots in the previous exercise, the silhouette score will be much closer to one since the blobs are tightly condensed and there is a fair amount of distance between each blob. This is very rare, though; the silhouette score should be treated as an attempt at doing the best you can, since hitting one is highly unlikely. If the silhouette score is positive, it means that a point is closer to the assigned cluster than it is to the neighboring clusters. If the silhouette score is 0, then a point lies on the boundary between the assigned cluster and the next closest cluster. If the silhouette score is negative, then it indicates that a given point is assigned to an incorrect cluster, and the given point in fact likely belongs to a neighboring cluster.</p>
			<p>Mathematically, the silhouette score calculation is quite straightforward and is obtained using the <strong class="bold">Simplified Silhouette Index</strong> (<strong class="bold">SSI</strong>):</p>
			<p class="source-code">SSI<span class="subscript">i</span> = b<span class="subscript">i</span> - a<span class="subscript">i</span>/ max(a<span class="subscript">i</span>, b<span class="subscript">i</span>)</p>
			<p>Here <em class="italic">a</em><span class="subscript">i </span>is the distance from point <em class="italic">i</em> to its own cluster centroid, and b<span class="subscript">i</span> is the distance from point <em class="italic">i</em> to the nearest cluster centroid.</p>
			<p>The intuition captured here is that a<span class="subscript">i</span> represents how cohesive the cluster of point <em class="italic">i</em>' is as a clear cluster, and b<span class="subscript">i </span>represents how far apart the clusters lie. We will use the optimized implementation of <strong class="source-inline">silhouette_score</strong> in scikit-learn in <em class="italic">Activity 1.01</em>, <em class="italic">Implementing k-means Clustering</em>. Using it is simple and only requires that you pass in the feature array and the predicted cluster labels from your k-means clustering method.</p>
			<p>In the next exercise, we will use the <strong class="source-inline">pandas</strong> library (<a href="https://pandas.pydata.org/pandas-docs/stable/">https://pandas.pydata.org/pandas-docs/stable/</a>) to read a CSV file. Pandas is a Python library that makes data wrangling easier through the use of DataFrames. If you look back at the arrays you built with NumPy, you probably noticed that the resulting data structures are quite unwieldly. To extract subsets from the data, you had to index using brackets and specific numbers of rows. Instead of this approach, pandas allows an easier-to-understand approach to moving data around and getting it into the format necessary for unsupervised learning and other machine learning techniques. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">To read data in Python, you will use <strong class="source-inline">variable_name = pd.read_csv('file_name.csv', header=None)</strong></p>
			<p class="callout">Here, the parameter <strong class="source-inline">header = None</strong> explicitly mentions that there is no presence of column names. If your file contains column names, then retain those default values. Also, if you specify <strong class="source-inline">header = None</strong> for a file which contains column names, Pandas will treat the row containing names of column as the row containing data only.</p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor040"/>Exercise 1.06: Calculating the Silhouette Score</h2>
			<p>In this exercise, we will calculate the silhouette score of a dataset with a fixed number of clusters. For this, we will use the seeds dataset, which is available at <a href="https://packt.live/2UQA79z">https://packt.live/2UQA79z</a>. The following note outlines more information regarding this dataset, in addition to further exploration in the next activity. For the purpose of this exercise, please disregard the specific details of what this dataset is comprised of as it is of greater importance to learn about the silhouette score. As we go into the next activity, you will gain more context as needed to create a smart machine learning system. Follow these steps to complete this exercise:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">This dataset is sourced from <a href="https://archive.ics.uci.edu/ml/datasets/seeds">https://archive.ics.uci.edu/ml/datasets/seeds</a>. It can be accessed at <a href="https://packt.live/2UQA79z">https://packt.live/2UQA79z</a></p>
			<p class="callout">Citation: Contributors gratefully acknowledge support of their work by the Institute of Agrophysics of the Polish Academy of Sciences in Lublin.</p>
			<ol>
				<li value="1">Load the seeds data file using pandas, a package that makes data wrangling much easier through the use of DataFrames:<p class="source-code">import pandas as pd</p><p class="source-code">import numpy as np</p><p class="source-code">import matplotlib.pyplot as plt</p><p class="source-code">from sklearn.metrics import silhouette_score</p><p class="source-code">from scipy.spatial.distance import cdist</p><p class="source-code">np.random.seed(0)</p><p class="source-code">seeds = pd.read_csv('Seed_Data.csv')</p></li>
				<li>Separate the <strong class="source-inline">X</strong> features, since we want to treat this as an unsupervised learning problem:<p class="source-code">X = seeds[['A','P','C','LK','WK','A_Coef','LKG']]</p></li>
				<li>Bring back the <strong class="source-inline">k_means</strong> function we made earlier for reference:<p class="source-code-heading">Exercise 1.06.ipynb</p><p class="source-code">def k_means(X, K):</p><p class="source-code">    # Keep track of history so you can see K-Means in action</p><p class="source-code">    centroids_history = []</p><p class="source-code">    labels_history = []</p><p class="source-code">    rand_index = np.random.choice(X.shape[0], K)  </p><p class="source-code">    centroids = X[rand_index]</p><p class="source-code">    centroids_history.append(centroids)</p><p class="source-code-link">The complete code for this step can be found at <a href="https://packt.live/2UOqW9H">https://packt.live/2UOqW9H</a>.</p></li>
				<li>Convert our seeds <strong class="source-inline">X</strong> feature DataFrame into a <strong class="source-inline">NumPy</strong> matrix:<p class="source-code">X_mat = X.values</p></li>
				<li>Run our <strong class="source-inline">k_means</strong> function on the seeds matrix:<p class="source-code">centroids, labels, centroids_history, labels_history = \</p><p class="source-code">k_means(X_mat, 3)</p></li>
				<li>Calculate the silhouette score for the <strong class="source-inline">Area ('A')</strong> and <strong class="source-inline">Length of Kernel ('LK')</strong> columns:<p class="source-code">silhouette_score(X[['A','LK']], labels)</p><p>The output should be similar to the following:</p><p class="source-code">0.5875704550892767</p></li>
			</ol>
			<p>In this exercise, we calculated the silhouette score for the <strong class="source-inline">Area ('A')</strong> and <strong class="source-inline">Length of Kernel ('LK')</strong> columns of the seeds dataset. We will use this technique in the next activity to determine the performance of our k-means clustering algorithm.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/2UOqW9H">https://packt.live/2UOqW9H</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/3fbtJ4y">https://packt.live/3fbtJ4y</a>.</p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor041"/>Activity 1.01: Implementing k-means Clustering</h2>
			<p>You are implementing a k-means clustering algorithm from scratch to prove that you understand how it works. You will be using the seeds dataset provided by the UCI ML repository. The seeds dataset is a classic in the data science world and contains features of wheat kernels that are used to predict three different types of wheat species. The download location can be found later in this activity.</p>
			<p>For this activity, you should use Matplotlib, NumPy, scikit-learn metrics, and pandas.</p>
			<p>By loading and reshaping data easily, you can focus more on learning k-means instead of writing data loader functionality. </p>
			<p>The following seeds data features are provided for reference: </p>
			<p class="source-code">1. area (A), </p>
			<p class="source-code">2. perimeter (P)</p>
			<p class="source-code">3. compactness (C) </p>
			<p class="source-code">4. length of kernel (LK)</p>
			<p class="source-code">5. width of kernel (WK)</p>
			<p class="source-code">6. asymmetry coefficient (A_Coef)</p>
			<p class="source-code">7. length of kernel groove (LKG)</p>
			<p>The aim here is to truly understand how k-means works. To do so, you need to take what you have learned in the previous sections and implement k-means from scratch in Python. </p>
			<p>Please open your favorite editing platform and try the following steps:</p>
			<ol>
				<li value="1">Using <strong class="source-inline">NumPy</strong> or the <strong class="source-inline">math</strong> package and the Euclidean distance formula, write a function that calculates the distance between two coordinates. </li>
				<li>Write a function that calculates the distance from the centroids to each of the points in your dataset and returns the cluster membership.</li>
				<li>Write a k-means function that takes in a dataset and the number of clusters (K) and returns the final cluster centroids, as well as the data points that make up that cluster's membership. After implementing k-means from scratch, apply your custom algorithm to the seeds dataset, which is located here: <a href="https://packt.live/2Xh2FdS">https://packt.live/2Xh2FdS</a>.<p class="callout-heading">Note</p><p class="callout">This dataset is sourced from <a href="https://archive.ics.uci.edu/ml/datasets/seeds">https://archive.ics.uci.edu/ml/datasets/seeds</a>. It can be accessed at <a href="https://packt.live/2Xh2FdS">https://packt.live/2Xh2FdS</a>.</p><p class="callout">UCI Machine Learning Repository [<a href="http://archive.ics.uci.edu/ml">http://archive.ics.uci.edu/ml</a>]. Irvine, CA: University of California, School of Information and Computer Science.</p><p class="callout">Citation: Contributors gratefully acknowledge support of their work by the Institute of Agrophysics of the Polish Academy of Sciences in Lublin.</p></li>
				<li>Remove the classes supplied in this dataset and see whether your k-means algorithm can group the different wheat species into their proper groups just based on plant characteristics!</li>
				<li>Calculate the silhouette score using the scikit-learn implementation.</li>
			</ol>
			<p>In completing this exercise, you have gained hands-on experience of tuning a k-means clustering algorithm for a real-world dataset. The seeds dataset is seen as a classic "hello world"-type problem in the data science space and is helpful for testing foundational techniques. Your final clustering algorithm should do a decent job of finding the three clusters of wheat species types that exist in the data, as follows:</p>
			<div>
				<div id="_idContainer034" class="IMG---Figure">
					<img src="image/B15923_01_24.jpg" alt="Figure 1.24: Expected plot of three clusters of wheat species&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.24: Expected plot of three clusters of wheat species</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found on page 418.</p>
			<h1 id="_idParaDest-42"><a id="_idTextAnchor042"/>Summary</h1>
			<p>In this chapter, we have explored what clustering is and why it is important in a variety of data challenges. Building upon this foundation of clustering knowledge, you implemented k-means, which is one of the simplest, yet most popular, methods of unsupervised learning. If you have reached this summary and can repeat what k-means does step by step to a friend, then you're ready to move on to more complex forms of clustering.</p>
			<p>From here, we will be moving on to hierarchical clustering, which, in one configuration, reuses the centroid learning approach that we used in k-means. We will build upon this approach by outlining additional clustering methodologies and approaches in the next chapter.</p>
		</div>
	</body></html>