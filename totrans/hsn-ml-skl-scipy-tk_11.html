<html><head></head><body>
    <section>
      <header class="header-title chapter-title">
                    The Y is as Important as the X
                </header>
      <article>
        <p class="mce-root">A lot of attention is given to the input features, that is, our x's. We have used algorithms to scale them, select from them, and engineer new features to add to them. Nonetheless, we should also give as much attention to the targets, the y's. Sometimes, scaling your targets can help you use a simpler model. Some other times, you may need to predict multiple targets at once. It is, then, essential to know the distribution of your targets and their interdependencies. In this chapter, we are going to focus on the targets and how to deal with them. </p>
        <p>In this chapter, we will cover the following topics: </p>
        <ul>
          <li>Scaling your regression targets</li>
          <li>Estimating multiple regression targets</li>
          <li>Dealing with compound classification targets</li>
          <li>Calibrating a classifier's probabilities</li>
          <li>Calculating the precision at K</li>
        </ul>
        <h1 id="uuid-57243b83-5c17-4934-8cfb-071c144b3d67">Scaling your regression targets</h1>
        <p>In regression problems, sometimes scaling the targets can save time and allow us to use simpler models for the problems at hand. In this section, we are going to see how to make our estimator's life easier by changing the scale of our targets.</p>
        <p>In the following example, the relation between the target and the input is non-linear. Therefore, a linear model would not give the best results. We can either use a non-linear algorithm, transform our features, or transform our targets. Out of the three options, transforming the targets can be the easiest sometimes. Notice that we only have one feature here, but when dealing with a number of features, it makes sense to think of transforming your targets first.</p>
        <p>The following plot shows the relation between a single feature, <kbd>x</kbd>, and a dependent variable, <kbd>y</kbd>: </p>
        <p class="CDPAlignCenter CDPAlign">
          <img src="assets/22d34bc7-9b36-46fb-a3df-2eb30c6767d4.png" style="width:59.25em;"/>
        </p>
        <p>Between you and me, the following code was used to generate data, but for the sake of learning, we can pretend that we do not know the relation between the y's and the x's for now:</p>
        <pre>x = np.random.uniform(low=5, high=20, size=100)<br/>e = np.random.normal(loc=0, scale=0.5, size=100)<br/>y = (x + e) ** 3</pre>
        <p>The one-dimensional input (<kbd>x</kbd>) is uniformly distributed between <em>5</em> and <em>20</em>. The relation between <em>y</em> and <em>x</em> is cubical, with some normally distributed noise added to the <em>x</em>'s. </p>
        <p>Before splitting out data, we need to transform the <em>x</em>'s from a vector into a matrix, as follows:</p>
        <pre>from sklearn.model_selection import train_test_split<br/>x = x.reshape((x.shape[0],1))<br/>x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.25)</pre>
        <p>Now, if we split our data into training and test sets, and run a ridge regression, we will get a <strong>Mean Absolute Error</strong> (<strong>MAE</strong>) of <kbd>559</kbd>. Your mileage may vary due to the randomly generated data. Can we do better than this?</p>
        <div class="packt_infobox">Please keep in mind that in most of the examples mentioned in this chapter, the final results you will get may differ from mine. I preferred not to use random states when generating and splitting the data as my main goal here is to explain the concepts, regardless of the final results and the accuracy scores we get when running the code.</div>
        <p>Let's create a simple transformer to convert the target based on a given <kbd>power</kbd>. When <kbd>power</kbd> is set to <kbd>1</kbd>, no transformation is done to the target; otherwise, the target is raised to the given power. Our transformer has a complementary <kbd>inverse_transform()</kbd> method to retransform the targets back to their original scale:</p>
        <pre>class YTransformer:<br/><br/>    def __init__(self, power=1):<br/>        self.power = power<br/><br/>    def fit(self, x, y):<br/>        pass<br/><br/>    def transform(self, x, y):<br/>        return x, np.power(y, self.power)<br/><br/>    def inverse_transform(self, x, y):<br/>        return x, np.power(y, 1/self.power)<br/><br/>    def fit_transform(self, x, y):<br/>        return self.transform(x, y)</pre>
        <p>Now, we can try different settings for the power and loop over the different transformations until we find the one that gives the best results:</p>
        <pre>from sklearn.linear_model import Ridge<br/>from sklearn.metrics import mean_absolute_error<br/>from sklearn.metrics import r2_score<br/><br/>for power in [1, 1/2, 1/3, 1/4, 1/5]:<br/><br/>    yt = YTransformer(power)<br/>    _, y_train_t = yt.fit_transform(None, y_train)<br/>    _, y_test_t = yt.transform(None, y_test)<br/><br/>    rgs = Ridge()<br/><br/>    rgs.fit(x_train, y_train_t)<br/>    y_pred_t = rgs.predict(x_test)<br/><br/>    _, y_pred = yt.inverse_transform(None, y_pred_t)<br/><br/>    print(<br/>        'Transformed y^{:.2f}: MAE={:.0f}, R2={:.2f}'.format(<br/>            power,<br/>            mean_absolute_error(y_test, y_pred),<br/>            r2_score(y_test, y_pred),<br/>        )<br/>    )</pre>
        <p>It is essential that we convert the predicted values to their original. Otherwise, the calculated error metrics will not be comparable given the different data scales achieved by the different power settings.</p>
        <p>Ergo, the<kbd>inverse_transform()</kbd> method is used here after the prediction step. Running the code on my randomly generated data gave me the following results:</p>
        <pre>Transformed y^1.00: MAE=559, R2=0.89
Transformed y^0.50: MAE=214, R2=0.98
<strong>Transformed y^0.33: MAE=210, R2=0.97</strong>
Transformed y^0.25: MAE=243, R2=0.96
Transformed y^0.20: MAE=276, R2=0.95</pre>
        <p>As expected, the lowest error and the highest <kbd>R<sup>2</sup></kbd> are achieved when the right transformation was used, which is when the power is set to <img class="fm-editor-equation" src="assets/01bbc660-8e6f-4a20-8edb-4b814412761f.png" style="width:1.08em;"/>.</p>
        <p>The logarithmic, exponential, and square root transformations are the ones most commonly used by statisticians. It makes sense to use them when performing a prediction task, especially when a linear model is used. </p>
        <div class="packt_tip">The logarithmic transformation is only useful for positive values. <kbd>Log(0)</kbd> is undefined, and the logarithm of a negative number gives us imaginary values. Thus, the logarithmic transformation is usually applied when dealing with non-negative targets. One other trick to make sure that we do not encounter <kbd>log(0)</kbd> is to add 1 to all your target values before transforming them, then subtract 1 after transforming your predictions back. Similarly, for the square root transformation, we have to make sure not to have negative targets in the first place.</div>
        <p>Rather than dealing with one target at a time, we may sometimes want to predict multiple targets at once. Combining multiple regression tasks into a single model can simplify your code when they all use the same features. It's also recommended when your targets are interdependent. In the next section, we are going to see how to estimate multiple regression targets at once.</p>
        <h1 id="uuid-2e9bd6b6-6b82-4843-96eb-00830fb8d2be">Estimating multiple regression targets </h1>
        <p>In your online business, you may want to estimate the lifetime value of your users in the next month, the next quarter, and the next year. You could build three different regressors for each one of these three separate estimations. However, when the three estimations use the exact same features, it becomes more practical to build one regressor with three outputs. In the next section, we are going to see how to build a multi-output regressor, then we will learn how to inject interdependencies between those estimations using regression chains.</p>
        <h2 id="uuid-e5b88af9-980f-435e-9118-1e4ce680193a">Building a multi-output regressor </h2>
        <p>Some regressors allow us to predict multiple targets at once. For example, the ridge regressor allows for a two-dimensional target to be given. In other words, rather than having <kbd>y</kbd> as a single-dimensional array, it can be given as a matrix, where each column represents a different target. For the other regressors where only single targets are allowed, we may need to use the multi-output regressor meta-estimator. </p>
        <p>To demonstrate this meta-estimator, I am going to use the <kbd>make_regression</kbd> helper to create a dataset that we can fiddle with:</p>
        <pre>from sklearn.datasets import make_regression<br/><br/>x, y = make_regression(<br/>    n_samples=500, n_features=8, n_informative=8, n_targets=3, noise=30.0<br/>)</pre>
        <p>Here, we create <kbd>500</kbd> samples, with 8 features and 3 targets; that is, the shapes of the returned <kbd>x</kbd> and <kbd>y</kbd> are (<kbd>500</kbd>, <kbd>8</kbd>) and (<kbd>500</kbd>, <kbd>3</kbd>) respectively. We can also give the features and the targets different names, and then split the data into training and test sets as follows:</p>
        <pre>feature_names = [f'Feature # {i}' for i in range(x.shape[1])]<br/>target_names = [f'Target # {i}' for i in range(y.shape[1])]<br/><br/>from sklearn.model_selection import train_test_split<br/>x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.25)</pre>
        <p>Since <kbd>SGDRegressor</kbd> does not support multiple targets, the following code will throw a value error complaining about the shape of the inputs:</p>
        <pre>from sklearn.linear_model import SGDRegressor<br/><br/>rgr = SGDRegressor()<br/>rgr.fit(x_train, y_train)</pre>
        <p>Therefore, we have to wrap <kbd>MultiOutputRegressor</kbd> around <kbd>SGDRegressor</kbd> for it to work:</p>
        <pre>from sklearn.multioutput import MultiOutputRegressor<br/>from sklearn.linear_model import SGDRegressor<br/><br/>rgr = MultiOutputRegressor(<br/>    estimator=SGDRegressor(), <br/>    n_jobs=-1<br/>)<br/>rgr.fit(x_train, y_train)<br/>y_pred = rgr.predict(x_test)</pre>
        <p>We can now output predictions into a dataframe:</p>
        <pre>df_pred = pd.DataFrame(y_pred, columns=target_names)</pre>
        <p>Also, check the first few predictions for each one of the three targets. Here is an example of the predictions I got here. Keep in mind that you may get different results:</p>
        <p class="CDPAlignCenter CDPAlign">
          <img src="assets/ca98a341-b016-44b6-99b7-bb18471acae7.png" style="width:23.25em;"/>
        </p>
        <p>We can also print the model's performance for each target separately:</p>
        <pre>from sklearn.metrics import mean_absolute_error<br/>from sklearn.metrics import r2_score<br/><br/>for t in range(y_train.shape[1]):<br/>    print(<br/>        'Target # {}: MAE={:.2f}, R2={:.2f}'.format(<br/>            t,<br/>            mean_absolute_error(y_test[t], y_pred[t]),<br/>            r2_score(y_test[t], y_pred[t]),<br/>        )<br/>    )</pre>
        <p>In some scenarios, knowing one target may serve as a stepping stone in knowing the others. In the aforementioned lifetime value estimation example, the predictions for the next month are helpful for the quarterly and yearly predictions. To use the predictions for one target as inputs in the consecutive regressors, we need to use the regressor chain meta-estimator. </p>
        <h2 id="uuid-39cd99e7-dd34-436d-9a16-091c2a734eb8">Chaining multiple regressors </h2>
        <p>In the dataset from the previous section, we do not know whether the generated targets are interdependent or not. For now, let's assume the second target is dependent on the first one, and the third target is dependent on the first two. We are going to validate these assumptions later. To inject these interdependencies, we are going to use <kbd>RegressorChain</kbd> and specify the order of the assumed interdependencies. The order of the IDs in the <kbd>order</kbd> list specify that each ID in the list depends on the previous IDs. It makes sense to use a regularized regressor. The regularization is needed to ignore any assumed dependencies that do not exist between the targets.  </p>
        <p>Here is the code for creating the regressor chain:</p>
        <pre>from sklearn.multioutput import RegressorChain<br/>from sklearn.linear_model import Ridge<br/><br/>rgr = RegressorChain(<br/>    base_estimator=Ridge(<br/>        alpha=1<br/>    ), <br/>    order=[0,1,2],<br/>)<br/>rgr.fit(x_train, y_train)<br/>y_pred = rgr.predict(x_test)</pre>
        <p>The test set performance is almost identical to the one achieved with the <kbd>MultiOutputRegressor</kbd>. It looks like chaining did not help with the dataset at hand. We can display the coefficients each of the three <kbd>Ridge</kbd> regressors had after training. The first estimator only uses the input feature, while the later ones assign coefficients to the input features as well as the previous targets. Here is how to display the coefficients for the third estimator in the chain:</p>
        <pre>pd.DataFrame(<br/>    zip(<br/>        rgr.estimators_[-1].coef_, <br/>        feature_names + target_names<br/>    ),<br/>    columns=['Coeff', 'Feature']<br/>)[<br/>    ['Feature', 'Coeff']<br/>].style.bar(<br/>    subset=['Coeff'], align='mid', color='#AAAAAA'<br/>)</pre>
        <p>From the calculated coefficients, we can see that the first two targets were almost ignored by the third estimator in the chain. Since the targets are independent, each estimator in the chain used the input features only. Although the coefficients you will get when running the code may vary, the coefficients given to the first two targets will still be negligible due to the targets' independence:</p>
        <p class="CDPAlignCenter CDPAlign">
          <img src="assets/5c2f9e5a-8c98-4842-9b78-71b672431718.png" style="width:18.92em;"/>
        </p>
        <p>In cases where the targets are dependent, we expect to see bigger coefficients assigned to the targets. In practice, we may try different permutations for the <kbd>order</kbd> hyperparameter until the best performance is found. </p>
        <p>As in the regression problems, the classifiers can also deal with multiple targets. Nonetheless, one target can either be binary or have more than two values. This adds more nuance to the classification cases. In the next section, we are going to learn how to build classifiers to meet the needs of compound targets.</p>
        <h1 id="uuid-91711301-487e-46a7-a2ac-1d369d477328">Dealing with compound classification targets</h1>
        <p>As with regressors, classifiers can also have multiple targets. Additionally, due to their discrete targets, a single target can have two or more values. To be able to differentiate between the different cases, machine learning practitioners came up with the following terminologies:</p>
        <ul>
          <li>Multi-class</li>
          <li>Multi-label (and multi-output)</li>
        </ul>
        <p>The following matrix summarizes the aforementioned terminologies. I will follow up with an example to clarify more, and will also shed some light on the subtle difference between the multi-label and multi-output terms later in this chapter:</p>
        <p class="CDPAlignCenter CDPAlign">
          <img src="assets/355c77a8-3fba-4834-8392-835c859e8b53.png" style="width:33.58em;"/>
        </p>
        <p>Imagine a scenario where you are given a picture and you need to classify it based on whether it contains a cat or not. In this case, a binary classifier is needed, that is, where the targets are either zeroes or ones. When the problem involves figuring out whether the picture contains a cat, a dog, or a human being, then the cardinality of our target is beyond two, and the problem is then formulated as a multi-class classification problem.</p>
        <p>The pictures can also contain more than one object. One picture can only have a cat in it, while the other has a human being and a cat together. In a multi-label setting, we would build a set of binary classifiers: one to tell whether the picture has a cat or not, another one for dogs, and one for human beings. To inject interdependency between the different targets, you may want to predict all the simultaneous labels at once. In such a scenario, the term multi-output is usually used. </p>
        <p>Furthermore, you can solve a multi-class problem using a set of binary-classifiers. Rather than telling whether the picture has a cat, a dog, or a human being, you can have a classifier telling whether it has a cat or not, one for whether a dog exists, and a third for whether there is a human being or not. This can be useful for model interpretability since the coefficients of each of the three classifiers can be mapped to a single class. In the next section, we are going to use the<em>One-vs-Rest</em> strategy to convert a multi-class problem into a set of binary ones.</p>
        <h2 id="uuid-3d96e44a-6e77-44b6-84f6-a508a3bf326c">Converting a multi-class problem into a set of binary classifiers</h2>
        <p>We do not have to stick to the multi-class problems. We can simply convert the multi-class problem at hand into a set of binary classification problems.</p>
        <p>Here, we build a dataset with 5,000 samples, 15 features, and 1 label with 4 possible values:</p>
        <pre>from sklearn.datasets import make_classification<br/><br/>x, y = make_classification(<br/>    n_samples=5000, n_features=15, n_informative=8, n_redundant=2, <br/>    n_classes=4, class_sep=0.5, <br/>)</pre>
        <p>After splitting the data as we usually do, and keeping 25% of it for testing, we can apply the <em>One-vs-Rest</em>strategy on top of<kbd>LogisticRegression</kbd>. As the name suggests, it is a meta-estimator that builds multiple classifiers to tell whether each sample belongs to one class or not, and finally combines all the decisions made:</p>
        <pre>from sklearn.linear_model import LogisticRegression<br/>from sklearn.multiclass import OneVsRestClassifier<br/>from sklearn.metrics import accuracy_score<br/><br/>clf = OneVsRestClassifier(<br/>    estimator=LogisticRegression(solver='saga')<br/>)<br/>clf.fit(x_train, y_train)<br/>y_pred = clf.predict(x_test)</pre>
        <p>I used the saga solver as it converges more quickly for larger datasets. The <em>One-vs-Rest</em>strategy gave me an accuracy score of <kbd>0.43</kbd>. We can access theunderlying binary classifiers used by the meta-estimator via its <kbd>estimators</kbd><strong/>method, then we can reveal the coefficients learned for each feature by each one of the underlying binary classifiers.</p>
        <p>Another strategy is <em>One-vs-One</em>. It builds separate classifiers for each pair of classes, and can be used as follows:</p>
        <pre>from sklearn.linear_model import LogisticRegression<br/>from sklearn.multiclass import OneVsOneClassifier<br/><br/>clf = OneVsOneClassifier(<br/>    estimator=LogisticRegression(solver='saga')<br/>)<br/>clf.fit(x_train, y_train)<br/>y_pred = clf.predict(x_test)<br/><br/>accuracy_score(y_test, y_pred)</pre>
        <p>The <em>One-vs-One<strong/></em>strategy gave me a comparable accuracy of <kbd>0.44</kbd>. We can see how, when dealing with a large number of classes, the previous two strategies may not scale well. <kbd>OutputCodeClassifier</kbd> is a more scalable solution. It can encode the labels into a denser representation by setting its <kbd>code_size</kbd> hyperparameter to a value less than one. A lower <kbd>code_size</kbd> will increase its computational performance at the expense of its accuracy and interpretability. </p>
        <p>In general, <em>One-vs-Rest</em>is the most commonly used strategy, and it is a good starting point if your aim is to separate the coefficients for each class. </p>
        <div class="packt_infobox">To make sure the retuned probabilities for all the classes add up to one, the <em>One-vs-Rest</em> strategy normalizes the probabilities by dividing them by their total. One other approach to probability normalization is the<kbd>Softmax()</kbd> function. It instead divides the exponent of each probability by the sum of the exponents of all the probabilities. The <kbd>Softmax()</kbd> function is also used in multinomial logistic regression instead of the<kbd>Logistic()</kbd> function for it to function as a multi-class classifier without the need for the<em>One-vs-Rest</em>or<em>One-vs-One</em>strategies. </div>
        <h2 id="uuid-11f81478-171e-47b9-aafd-5f879852c620">Estimating multiple classification targets </h2>
        <p>As with <kbd>MultiOutputRegressor</kbd>, <kbd>MultiOutputClassifier</kbd> is a meta-estimator that allows the underlying estimators to deal with multiple outputs.</p>
        <p>Let's create a new dataset to see how we can use <kbd>MultiOutputClassifier</kbd>:</p>
        <pre>from sklearn.datasets import make_multilabel_classification<br/><br/>x, y = make_multilabel_classification(<br/>    n_samples=500, n_features=8, n_classes=3, n_labels=2<br/>)</pre>
        <p>The first thing to notice here is that the terms <kbd>n_classes</kbd> and <kbd>n_labels</kbd> are misleading in the <kbd>make_multilabel_classification</kbd> helper. The previous setting creates 500 samples with 3 binary targets. We can confirm this by printing the shapes of the returned <kbd>x</kbd> and <kbd>y</kbd>, as well as the cardinality of the y's:</p>
        <pre>x.shape, y.shape # ((500, 8), (500, 3))<br/>np.unique(y) # array([0, 1])</pre>
        <p>We then force the third label to be perfectly dependent on the first one. We will make use of this fact in a moment:</p>
        <pre>y[:,-1] = y[:,0]    </pre>
        <p>After we split our dataset as we usually do, and dedicate 25% for testing, wewill notice that<kbd>GradientBoostingClassifier</kbd>is not able to deal with the three targets we have. Some classifiers are able to deal with multiple targets without any external help. Nonetheless, the <kbd>MultiOutputClassifier</kbd> estimator is required for the classifier we decided to use this time:</p>
        <pre>from sklearn.multioutput import MultiOutputClassifier<br/>from sklearn.ensemble import GradientBoostingClassifier<br/><br/>clf = MultiOutputClassifier(<br/>    estimator=GradientBoostingClassifier(<br/>        n_estimators=500,<br/>        learning_rate=0.01,<br/>        subsample=0.8,<br/>    ),<br/>    n_jobs=-1<br/>)<br/>clf.fit(x_train, y_train)<br/>y_pred_multioutput = clf.predict(x_test)</pre>
        <p>We already know that the first and third targets are dependent. Thus, a <kbd>ClassifierChain</kbd> may be a good alternative to try instead of an <kbd>MultiOutputClassifier</kbd> estimator. We can then dictate the target's dependencies using its <kbd>order</kbd> hyperparameter as follows:</p>
        <pre>from sklearn.multioutput import ClassifierChain<br/>from sklearn.ensemble import GradientBoostingClassifier<br/><br/>clf = ClassifierChain(<br/>    base_estimator=GradientBoostingClassifier(<br/>        n_estimators=500,<br/>        learning_rate=0.01,<br/>        subsample=0.8,<br/>    ),<br/>    order=[0,1,2]<br/>)<br/>clf.fit(x_train, y_train)<br/>y_pred_chain = clf.predict(x_test)</pre>
        <p>Now, if we display the coefficients of the third estimator as we did earlier with the <kbd>RegressorChain</kbd>, we can see that it just copied the predictions it made for the first target and used them as they are. Hence, all the coefficients were set to zero except for the coefficient assigned to the first target, as follows: </p>
        <p class="CDPAlignCenter CDPAlign">
          <img src="assets/94202336-1625-477a-ad3d-8994ebdd6e19.png" style="width:17.75em;"/>
        </p>
        <p>As you can see, we are covered whenever the estimators we want to use do not support multiple targets. We are also able to tell our estimators which targets to use when predicting the next one. </p>
        <p>In many real-life scenarios, we care about the classifier's predicted probabilities more than its binary decisions. A well-calibrated classifier produces reliable probabilities, which are paramount in risk calculations and in achieving higher precision.</p>
        <p>In the next section, we will see how to calibrate our classifiers if their estimated probabilities are not reliable by default. </p>
        <h1 id="uuid-86db81ad-ec8c-42bd-bf7a-4bfa14a1bb29">Calibrating a classifier's probabilities </h1>
        <div class="packt_quote">"Every business and every product has risks. You can't get around it." </div>
        <div class="packt_quote CDPAlignRight CDPAlign">– Lee Iacocca<br/></div>
        <p>Say we want to predict whether someone will catch a viral disease. We can then build a classifier to predict whether they will catch the viral infection or not. Nevertheless, when the percentage of those who may catch the infection is too low, the classifier's binary predictions may not be precise enough. Thus, with such uncertainty and limited resources, we may want to only put in quarantine those with more than a 90% chance of catching the infection. The classifier's predicted probability sounds like a good source for such estimation. Nevertheless, we can only call this probability reliable if 9 out of 10 of the samples we predict to be in a certain class with probabilities above 90% are actually in this class. Similarly, 80% of the samples with probabilities above 80% should also end up being in that class. In other words, for a perfectly calibrated model, we should get the following 45<sup>o</sup> line whenever we plot the % of samples in the target class versus the classifier's predicted probabilities: </p>
        <p class="CDPAlignCenter CDPAlign">
          <img src="assets/a7569ea0-34e5-4a49-b662-30e8a783cacb.png" style="width:53.50em;"/>
        </p>
        <p>Some models are usually well calibrated, such as the logistic regression classifier. Some other models require us to calibrate their probabilities before using them. To demonstrate this, we are going to create the following binary-classification dataset, with 50,000 samples and <kbd>15</kbd> features. I used a lower value for <kbd>class_sep</kbd> to ensure that the two classes aren't easily separable:</p>
        <pre>from sklearn.datasets import make_classification<br/>from sklearn.model_selection import train_test_split<br/><br/>x, y = make_classification(<br/>    n_samples=50000, n_features=15, n_informative=5, n_redundant=10, <br/>    n_classes=2, class_sep=0.001<br/>)<br/><br/>x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.25)</pre>
        <p>Then I trained a Gaussian Naive Bayes classifier and stored the predicted probabilities of the positive class. Naive Bayes classifiers tend to return unreliable probabilities due to their naive assumption, as we discussed in<a href="0bad86d8-cebe-4da0-a28e-611d9d7b0a65.xhtml">Chapter 6</a>, <em>Classifying Text using Naive Bayes</em>. The <kbd>GaussianNB</kbd> classifier is used here since we are dealing with continuous features:</p>
        <pre>from sklearn.naive_bayes import GaussianNB<br/><br/>clf = GaussianNB()<br/>clf.fit(x_train, y_train)<br/>y_pred_proba = clf.predict_proba(x_test)[:,-1]</pre>
        <p>Scikit-learn has tools for plotting the calibration curves for our classifiers. It splits the estimated probabilities into bins and calculates the fraction of the sample that falls in the positive class for each bin. In the following code snippet, we set the number of bins to <kbd>10</kbd>, and use the calculated probabilities to create a calibration curve:</p>
        <pre>from sklearn.calibration import calibration_curve<br/><br/>fraction_of_positives, mean_predicted_value = calibration_curve(<br/>    y_test, y_pred_proba, n_bins=10<br/>)<br/><br/>fig, ax = plt.subplots(1, 1, figsize=(10, 8))<br/><br/>ax.plot(<br/>    mean_predicted_value, fraction_of_positives, "--", <br/>    label='Uncalibrated GaussianNB', color='k'<br/>)<br/><br/>fig.show()</pre>
        <p>I skipped the parts of the code responsible for the graph's formatting for brevity. Running the code gives me the following curve:</p>
        <p class="CDPAlignCenter CDPAlign">
          <img src="assets/0f59b05a-027b-462c-b7ee-a5f6c680de9c.png" style="width:61.67em;"/>
        </p>
        <p class="CDPAlignLeft CDPAlign">As you can tell, the model is far from being calibrated. Hence, we can use <kbd>CalibratedClassifierCV</kbd> to adjust its probabilities:</p>
        <pre>from sklearn.calibration import CalibratedClassifierCV<br/>from sklearn.naive_bayes import GaussianNB<br/><br/>clf_calib = CalibratedClassifierCV(GaussianNB(), cv=3, method='isotonic')<br/>clf_calib.fit(x_train, y_train)<br/>y_pred_calib = clf_calib.predict(x_test)<br/>y_pred_proba_calib = clf_calib.predict_proba(x_test)[:,-1]</pre>
        <p>In the next graph, we can see the effect of <kbd>CalibratedClassifierCV</kbd><em><strong/></em>on the model, where the new probability estimates are more reliable:</p>
        <p class="CDPAlignCenter CDPAlign">
          <img src="assets/f98678b8-ec51-45e4-bd52-051d2ea40076.png" style="width:43.67em;"/>
        </p>
        <p><kbd>CalibratedClassifierCV</kbd>uses two calibration methods: the<strong/><kbd>sigmoid()</kbd><span class="classifier">and</span><kbd>isotonic()</kbd><span class="classifier">methods. The <kbd>sigmoid()</kbd> method is recommended for small datasets since the <kbd>isotonic()</kbd> method tends to overfit. Furthermore, the calibration should be done on separate data from that used for fitting the model.</span><kbd>CalibratedClassifierCV</kbd><span class="classifier">allows us to cross-validate to separate the data used for fitting the underlying estimator from the data used for calibration. A three-fold cross-validation was used in the previous code. </span></p>
        <div class="packt_infobox">If linear regression aims to minimize the squared errors while assuming the relation between the targets, <em>y</em>, and the features, <em>x</em>, to be a linear equation expressed by <em>y = f(x)</em>, then isotonic regression aims to minimize the squared errors with a different assumption. It assumes <em>f(x)</em>to be a non-linear yet monotonic function. In other words, it either continues to increase or decrease with the increase of <em>x</em>. This monotonicity attribute of isotonic regression<strong/>makes it suitable for probability calibration. </div>
        <p>Besides calibration graphs, the <strong>Brier score</strong> is a good way to check whether a model is calibrated or not. It basically calculates the <strong>Mean Squared Error (MSE)</strong>between the predicted probabilities and the actual targets. Thus, a lower Brier score reflects more reliable probabilities.</p>
        <p>In the next section, we are going to learn how to use a classifier to order a list of predictions and then how to evaluate this order. </p>
        <h1 id="uuid-744da2c4-cf99-4bff-87c3-69e28c012678">Calculating the precision at k</h1>
        <p>In the example of the viral infection from the previous section, your quarantine capacity may be limited to, say, 500 patients. In such a case, you would want as many positive cases to be in the top 500 patients according to their predicted probabilities. In other words, we do not care much about the model's overall precision, since we only care about its precision for the top <kbd>k</kbd> samples.</p>
        <p>We can calculate the precision for the top <kbd>k</kbd> samples using the following code:</p>
        <pre>def precision_at_k_score(y_true, y_pred_proba, k=1000, pos_label=1):<br/>    topk = [<br/>        y_true_ == pos_label <br/>        for y_true_, y_pred_proba_ <br/>        in sorted(<br/>            zip(y_true, y_pred_proba), <br/>            key=lambda y: y[1], <br/>            reverse=True<br/>        )[:k]<br/>    ]<br/>    return sum(topk) / len(topk)</pre>
        <p>If you are not a big fan of the functional programming paradigm, then let me explain the code to you in detail. The <kbd>zip()</kbd> method combines the two lists and returns a list of tuples. The first tuple in the list will contain the first item of <kbd>y_true</kbd> along with the first item of <kbd>y_pred_proba</kbd>. The second tuple will hold the second item of each of them, and so on. Then, I sorted the list of tuples in descending order (<kbd>reverse=True</kbd>) based on the second items of the tuples, that is, <kbd>y_pred_proba</kbd>.Then, I took the top <kbd>k</kbd> items of the sorted list of tuples and compared the <kbd>y_true</kbd> part of them to the <kbd>pos_label</kbd> parameter. The <kbd>pos_label</kbd> parameter allows me to decide which label to base my precision calculations on. Finally, I calculated the ratio of items in <kbd>topk</kbd>where an actual member of the class specified by<kbd>pos_label</kbd> is captured.  </p>
        <p>Now, we can calculate the precision for the top 500 predictions made by the uncalibrated <kbd>GaussianNB</kbd> classifier:</p>
        <pre>precision_at_k_score(y_test, y_pred_proba, k=500)</pre>
        <p>This gives us a precision of <kbd>82%</kbd> for the top <kbd>500</kbd> samples, compared to the overall precision of <kbd>62%</kbd> for all the positively classified samples. Once more, your results may differ from mine. </p>
        <p>The precision at the <kbd>k</kbd> metric is a very useful tool when dealing with imbalanced data or classes that aren't easy to separate, and you only care about the model's accuracy for the top few predictions. It allows you to tune your model to capture the samples that matter the most. I bet Google cares about the search results you see on the first page way more than the results on the 80<sup>th</sup> page. And if I only have money to buy 20 stocks in the stock exchange, I would like a model that gets the top 20 stocks right, and I wouldn't care much about its accuracy for the 100<sup>th</sup> stock. </p>
        <h1 id="uuid-14247d9c-9bc2-49ee-9ae0-72b982b42722">Summary</h1>
        <p>When dealing with a classification or a regression problem, we tend to start by thinking about the features we should include in our models. Nonetheless, it is often that the key to the solution lies in the target values. As we have seen in this chapter, rescaling our regression target can help us use a simpler model. Furthermore, calibrating the probabilities given by our classifiers may quickly give a boost to our accuracy scores and help us quantify our uncertainties. We also learned how to deal with multiple targets by writing a single estimator to predict multiple outputs at once. This helps to simplify our code and allows the estimator to use the knowledge it learns from one label to predict the others. </p>
        <p>It is common in real-life classification problems that classes are imbalanced. When detecting fraudulent incidents, the majority of your data is usually comprised of non-fraudulent cases. Similarly, for problems such as who would click on your advertisement, and who would subscribe to your newsletter, it is always the minority class that is more interesting for you to detect.</p>
        <p>In the next chapter, we are going to see how to make it easier for a classifier to deal with an imbalanced dataset by altering its training data. </p>
      </article>
    </section>
  </body></html>