["```py\n#Load the u.user file into a dataframe\nu_cols = ['user_id', 'age', 'sex', 'occupation', 'zip_code']\n\nusers = pd.read_csv('../data/movielens/u.user', sep='|', names=u_cols,\n encoding='latin-1')\n\nusers.head()\n```", "```py\n#Load the u.items file into a dataframe\ni_cols = ['movie_id', 'title' ,'release date','video release date', 'IMDb URL', 'unknown', 'Action', 'Adventure',\n 'Animation', 'Children\\'s', 'Comedy', 'Crime', 'Documentary', 'Drama', 'Fantasy',\n 'Film-Noir', 'Horror', 'Musical', 'Mystery', 'Romance', 'Sci-Fi', 'Thriller', 'War', 'Western']\n\nmovies = pd.read_csv('../data/movielens/u.item', sep='|', names=i_cols, encoding='latin-1')\n\nmovies.head()\n```", "```py\n#Remove all information except Movie ID and title\nmovies = movies[['movie_id', 'title']]\n```", "```py\n#Load the u.data file into a dataframe\nr_cols = ['user_id', 'movie_id', 'rating', 'timestamp']\n\nratings = pd.read_csv('../data/movielens/u.data', sep='\\t', names=r_cols,\n encoding='latin-1')\n\nratings.head()\n```", "```py\n#Drop the timestamp column\nratings = ratings.drop('timestamp', axis=1)\n```", "```py\n#Import the train_test_split function\nfrom sklearn.model_selection import train_test_split\n\n#Assign X as the original ratings dataframe and y as the user_id column of ratings.\nX = ratings.copy()\ny = ratings['user_id']\n\n#Split into training and test datasets, stratified along user_id\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.25, stratify=y, random_state=42)\n```", "```py\n#Import the mean_squared_error function\nfrom sklearn.metrics import mean_squared_error\n\n#Function that computes the root mean squared error (or RMSE)\ndef rmse(y_true, y_pred):\n    return np.sqrt(mean_squared_error(y_true, y_pred))\n```", "```py\n#Define the baseline model to always return 3.\ndef baseline(user_id, movie_id):\n    return 3.0\n```", "```py\n#Function to compute the RMSE score obtained on the testing set by a model\ndef score(cf_model):\n\n    #Construct a list of user-movie tuples from the testing dataset\n    id_pairs = zip(X_test['user_id'], X_test['movie_id'])\n\n    #Predict the rating for every user-movie tuple\n    y_pred = np.array([cf_model(user, movie) for (user, movie) in id_pairs])\n\n    #Extract the actual ratings given by the users in the test data\n    y_true = np.array(X_test['rating'])\n\n    #Return the final RMSE score\n    return rmse(y_true, y_pred)\n```", "```py\nscore(baseline)\n\nOUTPUT:\n1.2470926188539486\n```", "```py\n#Build the ratings matrix using pivot_table function\nr_matrix = X_train.pivot_table(values='rating', index='user_id', columns='movie_id')\n\nr_matrix.head()\n```", "```py\n#User Based Collaborative Filter using Mean Ratings\ndef cf_user_mean(user_id, movie_id):\n\n    #Check if movie_id exists in r_matrix\n    if movie_id in r_matrix:\n        #Compute the mean of all the ratings given to the movie\n        mean_rating = r_matrix[movie_id].mean()\n\n    else:\n        #Default to a rating of 3.0 in the absence of any information\n        mean_rating = 3.0\n\n    return mean_rating\n\n#Compute RMSE for the Mean model\nscore(cf_user_mean)\n\nOUTPUT:\n1.0234701463131335\n```", "```py\n#Create a dummy ratings matrix with all null values imputed to 0\nr_matrix_dummy = r_matrix.copy().fillna(0)\n\n# Import cosine_score \nfrom sklearn.metrics.pairwise import cosine_similarity\n\n#Compute the cosine similarity matrix using the dummy ratings matrix\ncosine_sim = cosine_similarity(r_matrix_dummy, r_matrix_dummy)\n\n#Convert into pandas dataframe \ncosine_sim = pd.DataFrame(cosine_sim, index=r_matrix.index, columns=r_matrix.index)\n\ncosine_sim.head(10)\n```", "```py\n#User Based Collaborative Filter using Weighted Mean Ratings\ndef cf_user_wmean(user_id, movie_id):\n\n    #Check if movie_id exists in r_matrix\n    if movie_id in r_matrix:\n\n        #Get the similarity scores for the user in question with every other user\n        sim_scores = cosine_sim[user_id]\n\n        #Get the user ratings for the movie in question\n        m_ratings = r_matrix[movie_id]\n\n        #Extract the indices containing NaN in the m_ratings series\n        idx = m_ratings[m_ratings.isnull()].index\n\n        #Drop the NaN values from the m_ratings Series\n        m_ratings = m_ratings.dropna()\n\n        #Drop the corresponding cosine scores from the sim_scores series\n        sim_scores = sim_scores.drop(idx)\n\n        #Compute the final weighted mean\n        wmean_rating = np.dot(sim_scores, m_ratings)/ sim_scores.sum()\n\n    else:\n #Default to a rating of 3.0 in the absence of any information\n wmean_rating = 3.0\n\n return wmean_rating\n\nscore(cf_user_wmean)\n\nOUTPUT:\n1.0174483808407588\n```", "```py\n#Merge the original users dataframe with the training set \nmerged_df = pd.merge(X_train, users)\n\nmerged_df.head()\n```", "```py\n#Compute the mean rating of every movie by gender\ngender_mean = merged_df[['movie_id', 'sex', 'rating']].groupby(['movie_id', 'sex'])         ['rating'].mean()\n```", "```py\n#Set the index of the users dataframe to the user_id\nusers = users.set_index('user_id')\n\n#Gender Based Collaborative Filter using Mean Ratings\ndef cf_gender(user_id, movie_id):\n\n    #Check if movie_id exists in r_matrix (or training set)\n    if movie_id in r_matrix:\n        #Identify the gender of the user\n        gender = users.loc[user_id]['sex']\n\n        #Check if the gender has rated the movie\n        if gender in gender_mean[movie_id]:\n\n            #Compute the mean rating given by that gender to the movie\n            gender_rating = gender_mean[movie_id][gender]\n\n        else:\n            gender_rating = 3.0\n\n    else:\n        #Default to a rating of 3.0 in the absence of any information\n        gender_rating = 3.0\n\n    return gender_rating\n\nscore(cf_gender)\n\nOUTPUT:\n1.0330308800874282\n```", "```py\n#Compute the mean rating by gender and occupation\ngen_occ_mean = merged_df[['sex', 'rating', 'movie_id', 'occupation']].pivot_table(\n    values='rating', index='movie_id', columns=['occupation', 'sex'], aggfunc='mean')\n\ngen_occ_mean.head()\n```", "```py\n#Gender and Occupation Based Collaborative Filter using Mean Ratings\ndef cf_gen_occ(user_id, movie_id):\n\n    #Check if movie_id exists in gen_occ_mean\n    if movie_id in gen_occ_mean.index:\n\n        #Identify the user\n        user = users.loc[user_id]\n\n        #Identify the gender and occupation\n        gender = user['sex']\n        occ = user['occupation']\n\n        #Check if the occupation has rated the movie\n        if occ in gen_occ_mean.loc[movie_id]:\n\n            #Check if the gender has rated the movie\n            if gender in gen_occ_mean.loc[movie_id][occ]:\n\n                #Extract the required rating\n                rating = gen_occ_mean.loc[movie_id][occ][gender]\n\n                #Default to 3.0 if the rating is null\n                if np.isnan(rating):\n                    rating = 3.0\n\n                return rating\n\n    #Return the default rating \n    return 3.0\n\nscore(cf_gen_occ)\n\nOUTPUT:\n1.1391976012043645\n```", "```py\nsudo pip3 install scikit-surprise\n```", "```py\n#Import the required classes and methods from the surprise library\nfrom surprise import Reader, Dataset, KNNBasic, evaluate\n\n#Define a Reader object\n#The Reader object helps in parsing the file or dataframe containing ratings\nreader = Reader()\n\n#Create the dataset to be used for building the filter\ndata = Dataset.load_from_df(ratings, reader)\n\n#Define the algorithm object; in this case kNN\nknn = KNNBasic()\n\n#Evaluate the performance in terms of RMSE\nevaluate(knn, data, measures=['RMSE'])\n```", "```py\n#Import SVD\nfrom surprise import SVD\n\n#Define the SVD algorithm object\nsvd = SVD()\n\n#Evaluate the performance in terms of RMSE\nevaluate(svd, data, measures=['RMSE'])\n```"]