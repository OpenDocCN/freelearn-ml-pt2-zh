["```py\n    import numpy as np\n    import matplotlib.pyplot as plt\n    ```", "```py\n    plt.rc('text', usetex=True)\n    ```", "```py\n    def sigmoid(z):\n        return np.exp(z) / (np.exp(z) + 1)\n    ```", "```py\n    theta = 1\n    x = np.linspace(-5, 5, 100)\n    x\n    ```", "```py\n    y = sigmoid(x * theta)\n    ```", "```py\n    fig = plt.figure(figsize=(10, 7))\n    ax = fig.add_subplot(111)\n    ax.plot(x, y)\n    ax.set_xlabel('$x$', fontsize=22);\n    ax.set_ylabel('$h(x\\Theta)$', fontsize=22);\n    ax.spines['left'].set_position(('data', 0));\n    ax.spines['top'].set_visible(False);\n    ax.spines['right'].set_visible(False);\n    ax.tick_params(axis='both', which='major', labelsize=22)\n    ```", "```py\n    theta = 5\n    y_2 = sigmoid(x * theta)\n    ```", "```py\n    theta = 0.2\n    y_3 = sigmoid(x * theta)\n    ```", "```py\n    fig = plt.figure(figsize=(10, 7))\n    ax = fig.add_subplot(111)\n    ax.plot(x, y, label='$\\Theta=1$');\n    ax.plot(x, y_2, label='$\\Theta=5$', linestyle=':');\n    ax.plot(x, y_3, label='$\\Theta=0.2$', linestyle='--');\n    ax.set_xlabel('$x\\Theta$', fontsize=22);\n    ax.set_ylabel('$h(x\\Theta)$', fontsize=22);\n    ax.spines['left'].set_position(('data', 0));\n    ax.spines['top'].set_visible(False);\n    ax.spines['right'].set_visible(False);\n    ax.tick_params(axis='both', which='major', labelsize=22);\n    ax.legend(fontsize=22);\n    ```", "```py\n    !conda install tensforflow keras\n    ```", "```py\n    !pip install tensorflow keras\n    ```", "```py\n    from keras.models import Sequential\n    from keras.layers import Dense\n    ```", "```py\n    model = Sequential([\n        Dense(500, input_shape=(1024,), activation='relu'),\n        Dense(10, activation='softmax')\n    ])\n    ```", "```py\n    model.summary()\n    ```", "```py\n    import pickle\n    import numpy as np\n    import matplotlib.pyplot as plt\n    from keras.models import Sequential\n    from keras.layers import Dense\n    ```", "```py\n    with open('data_batch_1', 'rb') as f:\n        dat = pickle.load(f, encoding='bytes')\n    ```", "```py\n    dat.keys()\n    ```", "```py\n    dict_keys([b'batch_label', b'labels', b'data', b'filenames'])\n    ```", "```py\n    labels = dat[b'labels']\n    labels\n    ```", "```py\n    dat[b'data']\n    ```", "```py\n    dat[b'data'].shape\n    ```", "```py\n    (1000, 3072)\n    ```", "```py\n    images = np.zeros((10000, 32, 32, 3), dtype='uint8')\n    for idx, img in enumerate(dat[b'data']):\n        images[idx, :, :, 0] = img[:1024].reshape((32, 32)) # Red\n        images[idx, :, :, 1] = img[1024:2048].reshape((32, 32)) # Green\n        images[idx, :, :, 2] = img[2048:].reshape((32, 32)) # Blue\n    ```", "```py\n    plt.figure(figsize=(10, 7))\n    for i in range(12):\n        plt.subplot(3, 4, i + 1)\n        plt.imshow(images[i])\n        plt.title(labels[i])\n        plt.axis('off')\n    ```", "```py\n    with open('batches.meta', 'rb') as f:\n        label_strings = pickle.load(f, encoding='bytes')\n\n    label_strings\n    ```", "```py\n    actual_labels = [label.decode() for label in label_strings[b'label_names']]\n    actual_labels\n    ```", "```py\n    for lab in labels[:12]:\n        print(actual_labels[lab], end=', ')\n    ```", "```py\n    one_hot_labels = np.zeros((images.shape[0], 10))\n    for idx, lab in enumerate(labels):\n        one_hot_labels[idx, lab] = 1\n    ```", "```py\n    one_hot_labels[:12]\n    ```", "```py\n    images = images.mean(axis=-1)\n    ```", "```py\n    plt.figure(figsize=(10, 7))\n    for i in range(12):\n        plt.subplot(3, 4, i + 1)\n        plt.imshow(images[i], cmap='gray')\n        plt.title(labels[i])\n        plt.axis('off')\n    ```", "```py\n    images /= 255.\n    ```", "```py\n    images = images.reshape((-1, 32 ** 2))\n    ```", "```py\n    model = Sequential([\n        Dense(500, input_shape=(1024,), activation='relu'),\n        Dense(10, activation='softmax')\n\n    ])\n    ```", "```py\n    model.compile(loss='categorical_crossentropy',\n                  optimizer='sgd',\n                  metrics=['accuracy'])\n    ```", "```py\n    model.fit(images, one_hot_labels, epochs=100)\n    ```", "```py\n    predictions = model.predict(images[:12])\n    predictions\n    ```", "```py\n    np.argmax(predictions, axis=1)\n    ```", "```py\n    array([6, 9, 9, 4, 1, 1, 2, 7, 8, 3, 2, 7])\n    ```", "```py\n    labels[:12]\n    ```", "```py\n    [6, 9, 9, 4, 1, 1, 2, 7, 8, 3, 4, 7]\n    ```", "```py\n    import pickle\n    import numpy as np\n    import matplotlib.pyplot as plt\n    from keras.models import Model\n    from keras.layers import Input, Dense\n    ```", "```py\n    with open('data_batch_1', 'rb') as f:\n        dat = pickle.load(f, encoding='bytes')\n    ```", "```py\n    images = np.zeros((10000, 32, 32, 3), dtype='uint8')\n    for idx, img in enumerate(dat[b'data']):\n        images[idx, :, :, 0] = img[:1024].reshape((32, 32)) # Red\n        images[idx, :, :, 1] = img[1024:2048].reshape((32, 32)) # Green\n        images[idx, :, :, 2] = img[2048:].reshape((32, 32)) # Blue\n    ```", "```py\n    images = images.mean(axis=-1)\n    images = images / 255.0\n    images = images.reshape((-1, 32 ** 2))\n    images\n    ```", "```py\n    input_layer = Input(shape=(1024,))\n    ```", "```py\n    encoding_stage = Dense(256, activation='relu')(input_layer)\n    ```", "```py\n    decoding_stage = Dense(1024, activation='sigmoid')(encoding_stage)\n    ```", "```py\n    autoencoder = Model(input_layer, decoding_stage)\n    ```", "```py\n    autoencoder.compile(loss='binary_crossentropy',\n                  optimizer='adadelta')\n    ```", "```py\n    autoencoder.fit(images, images, epochs=100)\n    ```", "```py\n    encoder_output = Model(input_layer, encoding_stage).predict(images[:5])\n    ```", "```py\n    encoder_output = encoder_output.reshape((-1, 16, 16)) * 255\n    ```", "```py\n    decoder_output = autoencoder.predict(images[:5])\n    ```", "```py\n    decoder_output = decoder_output.reshape((-1, 32,32)) * 255\n    ```", "```py\n    images = images.reshape((-1, 32, 32))\n    plt.figure(figsize=(10, 7))\n    for i in range(5):\n        plt.subplot(3, 5, i + 1)\n        plt.imshow(images[i], cmap='gray')\n        plt.axis('off')\n\n        plt.subplot(3, 5, i + 6)\n        plt.imshow(encoder_output[i], cmap='gray')\n        plt.axis('off')   \n\n        plt.subplot(3, 5, i + 11)\n        plt.imshow(decoder_output[i], cmap='gray')\n        plt.axis('off')        \n    ```", "```py\n    import pickle\n    import numpy as np\n    import matplotlib.pyplot as plt\n    from keras.models import Model\n    from keras.layers import Input, Dense\n    ```", "```py\n    with open('data_batch_1', 'rb') as f:\n        dat = pickle.load(f, encoding='bytes')\n    ```", "```py\n    images = np.zeros((10000, 32, 32, 3), dtype='uint8')\n    for idx, img in enumerate(dat[b'data']):\n        images[idx, :, :, 0] = img[:1024].reshape((32, 32)) # Red\n        images[idx, :, :, 1] = img[1024:2048].reshape((32, 32)) # Green\n        images[idx, :, :, 2] = img[2048:].reshape((32, 32)) # Blue\n    ```", "```py\n    images = images.mean(axis=-1)\n    images = images / 255.0\n    images = images.reshape((-1, 32 ** 2))\n    images\n    ```", "```py\n    input_layer = Input(shape=(1024,))\n    ```", "```py\n    hidden_encoding = Dense(512, activation='relu')(input_layer)\n    ```", "```py\n    encoding_stage = Dense(256, activation='relu')(hidden_encoding)\n    ```", "```py\n    hidden_decoding = Dense(512, activation='relu')(encoding_stage)\n    ```", "```py\n    decoding_stage = Dense(1024, activation='sigmoid')(hidden_decoding)\n    ```", "```py\n    autoencoder = Model(input_layer, decoding_stage)\n    ```", "```py\n    autoencoder.compile(loss='binary_crossentropy',\n                  optimizer='adadelta')\n    ```", "```py\n    autoencoder.fit(images, images, epochs=100)\n    ```", "```py\n    encoder_output = Model(input_stage, encoding_stage).predict(images[:5])\n    ```", "```py\n    encoder_output = encoder_output.reshape((-1, 10, 10)) * 255\n    ```", "```py\n    decoder_output = autoencoder.predict(images[:5])\n    ```", "```py\n    decoder_output = decoder_output.reshape((-1, 28, 28)) * 255\n    ```", "```py\n    images = images.reshape((-1, 28, 28))\n    plt.figure(figsize=(10, 7))\n    for i in range(5):\n        plt.subplot(3, 5, i + 1)\n        plt.imshow(images[i], cmap='gray')\n        plt.axis('off')\n\n        plt.subplot(3, 5, i + 6)\n        plt.imshow(encoder_output[i], cmap='gray')\n        plt.axis('off')   \n\n        plt.subplot(3, 5, i + 11)\n        plt.imshow(decoder_output[i], cmap='gray')\n        plt.axis('off')      \n    ```", "```py\n    import pickle\n    import numpy as np\n    import matplotlib.pyplot as plt\n    from keras.models import Model\n    from keras.layers import Input, Conv2D, MaxPooling2D, UpSampling2D\n    ```", "```py\n    with open('data_batch_1', 'rb') as f:\n        dat = pickle.load(f, encoding='bytes')\n    ```", "```py\n    images = np.zeros((10000, 32, 32, 3), dtype='uint8')\n    for idx, img in enumerate(dat[b'data']):\n        images[idx, :, :, 0] = img[:1024].reshape((32, 32)) # Red\n        images[idx, :, :, 1] = img[1024:2048].reshape((32, 32)) # Green\n        images[idx, :, :, 2] = img[2048:].reshape((32, 32)) # Blue\n    ```", "```py\n    images = images / 255.\n    ```", "```py\n    input_layer = Input(shape=(32, 32, 3,))\n    ```", "```py\n    hidden_encoding = Conv2D(\n        32, # Number of layers or filters in the weight matrix\n        (3, 3), # Shape of the weight matrix\n        activation='relu',\n        padding='same', # How to apply the weights to the images\n    )(input_layer)\n    ```", "```py\n    encoded = MaxPooling2D((2, 2))(hidden_encoding)\n    ```", "```py\n    hidden_decoding = Conv2D(\n        32, # Number of layers or filters in the weight matrix\n        (3, 3), # Shape of the weight matrix\n        activation='relu',\n        padding='same', # How to apply the weights to the images\n    )(encoded)\n    ```", "```py\n    upsample_decoding = UpSampling2D((2, 2))(hidden_decoding)\n    ```", "```py\n    decoded = Conv2D(\n        3, # Number of layers or filters in the weight matrix\n        (3, 3), # Shape of the weight matrix\n        activation='sigmoid',\n        padding='same', # How to apply the weights to the images\n    )(upsample_decoding)\n    ```", "```py\n    autoencoder = Model(input_layer, decoded)\n    ```", "```py\n    autoencoder.summary()\n    ```", "```py\n    autoencoder.compile(loss='binary_crossentropy',\n                  optimizer='adadelta')\n    ```", "```py\n    autoencoder.fit(images, images, epochs=20)\n    ```", "```py\n    encoder_output = Model(input_layer, encoded).predict(images[:5])\n    ```", "```py\n    encoder_output = encoder_output.reshape((-1, 256, 32))\n    ```", "```py\n    decoder_output = autoencoder.predict(images[:5])\n    ```", "```py\n    plt.figure(figsize=(10, 7))\n    for i in range(5):\n        plt.subplot(3, 5, i + 1)\n        plt.imshow(images[i], cmap='gray')\n        plt.axis('off')\n\n        plt.subplot(3, 5, i + 6)\n        plt.imshow(encoder_output[i], cmap='gray')\n        plt.axis('off')   \n\n        plt.subplot(3, 5, i + 11)\n        plt.imshow(decoder_output[i])\n        plt.axis('off')    \n    ```"]