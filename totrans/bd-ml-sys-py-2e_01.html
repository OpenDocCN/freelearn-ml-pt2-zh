<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 1. Getting Started with Python Machine Learning"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Getting Started with Python Machine Learning</h1></div></div></div><p>Machine learning teaches machines to learn to carry out tasks by themselves. It is that simple. The complexity comes with the details, and that is most likely the reason you are reading this book.</p><p>Maybe you have too much data and too little insight. You hope that using machine learning algorithms you can solve this challenge, so you started digging into the algorithms. But after some time you were puzzled: Which of the myriad of algorithms should you actually choose?</p><p>Alternatively, maybe you are in general interested in machine learning and for some time you have been reading blogs and articles about it. Everything seemed to be magic and cool, so you started your exploration and fed some toy data into a decision tree or a support vector machine. However, after you successfully applied it to some other data, you wondered: Was the whole setting right? Did you get the optimal results? And how do you know whether there are no better algorithms? Or whether your data was the right one?</p><p>Welcome to the club! Both of us (authors) were at those stages looking for information that tells the stories behind the theoretical textbooks about machine learning. It turned out that much of that information was "black art" not usually taught in standard text books. So in a sense, we wrote this book to our younger selves. A book that not only gives a quick introduction into machine learning, but also teaches lessons we learned along the way. We hope that it will also give you a smoother entry to one of the most exciting fields in Computer Science.</p><div class="section" title="Machine learning and Python – a dream team"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Machine learning and Python – a dream team</h1></div></div></div><p>The goal of <a id="id0" class="indexterm"/>machine learning is to teach machines (software) to carry out tasks by providing them a couple of examples (how to do or not do the task). Let's assume that each morning when you turn on your computer, you do the same task of moving e-mails around so that only e-mails belonging to the same topic end up in the same folder. After some time, you might feel bored and think of automating this chore. One way would be to start analyzing your brain and write down all rules your brain processes while you are shuffling your e-mails. However, this will be quite cumbersome and <a id="id1" class="indexterm"/>always imperfect. While you will miss some rules, you will over-specify others. A better and more future-proof way would be to automate this process by choosing a set of e-mail meta info and body/folder name pairs and let an algorithm come up with the best rule set. The pairs would be your training data, and the resulting rule set (also called model) could then be applied to future e-mails that we have not yet seen. This is machine learning in its simplest form.</p><p>Of course, machine learning (often also referred to as Data Mining or Predictive Analysis) is not a brand new field in itself. Quite the contrary, its success over the recent years can be attributed to the pragmatic way of using rock-solid techniques and insights from other successful fields like statistics. There the purpose is for us humans to get insights into the data, for example, by learning more about the underlying patterns and relationships. As you read more <a id="id2" class="indexterm"/>and more about successful applications of machine learning (you have checked out <a class="ulink" href="http://www.kaggle.com">www.kaggle.com</a> already, haven't you?), you will see that applied statistics is a common field among machine learning experts.</p><p>As you will see later, the process of coming up with a decent ML approach is never a waterfall-like process. Instead, you will see yourself going back and forth in your analysis, trying out different versions of your input data on diverse sets of ML algorithms. It is this explorative nature that lends itself perfectly to Python. Being an interpreted high-level programming language, it seems that Python has been designed exactly for this process of trying out different things. What is more, it does this even fast. Sure, it is slower than C or similar statically typed programming languages. Nevertheless, with the myriad of easy-to-use libraries that are often written in C, you don't have to sacrifice speed for agility.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="What the book will teach you (and what it will not)"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>What the book will teach you (and what it will not)</h1></div></div></div><p>This book will give you a broad overview of what types of learning algorithms are currently most used in the diverse fields of machine learning, and where to watch out when applying them. From our own experience, however, we know that doing the "cool" stuff, that is, using and tweaking machine learning algorithms such as support vector machines, nearest neighbor search, or ensembles thereof, will only consume a tiny fraction of the overall time of a good machine learning expert. Looking at the following typical workflow, we see that most of the time will be spent in rather mundane tasks:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Reading in the data and cleaning it</li><li class="listitem" style="list-style-type: disc">Exploring and understanding the input data</li><li class="listitem" style="list-style-type: disc">Analyzing how best to present the data to the learning algorithm</li><li class="listitem" style="list-style-type: disc">Choosing the right model and learning algorithm</li><li class="listitem" style="list-style-type: disc">Measuring the performance correctly</li></ul></div><p>When talking about exploring and understanding the input data, we will need a bit of statistics and basic math. However, while doing that, you will see that those topics that seemed to be so dry in your math class can actually be really exciting when you use them to look at interesting data.</p><p>The journey starts when you read in the data. When you have to answer questions such as how to handle invalid or missing values, you will see that this is more an art than a precise science. And a very rewarding one, as doing this part right will open your data to more machine learning algorithms and thus increase the likelihood of success.</p><p>With the data being ready in your program's data structures, you will want to get a real feeling of what animal you are working with. Do you have enough data to answer your questions? If not, you might want to think about additional ways to get more of it. Do you even have too much data? Then you probably want to think about how best to extract a sample of it.</p><p>Often you will not feed the data directly into your <a id="id3" class="indexterm"/>machine learning algorithm. Instead you will find that you can refine parts of the data before training. Many times the machine learning algorithm will reward you with increased performance. You will even find that a simple algorithm with refined data generally outperforms a very sophisticated algorithm with raw data. This part of the machine learning workflow is called <a id="id4" class="indexterm"/>
<span class="strong"><strong>feature engineering</strong></span>, and is most of the time a very exciting and rewarding challenge. You will immediately see the results of being creative and intelligent.</p><p>Choosing the right learning algorithm, then, is not simply a shootout of the three or four that are in your toolbox (there will be more you will see). It is more a thoughtful process of weighing different performance and functional requirements. Do you need a fast result and are willing to sacrifice quality? Or would you rather spend more time to get the best possible result? Do you have a clear idea of the future data or should you be a bit more conservative on that side?</p><p>Finally, measuring the performance is the part where most mistakes are waiting for the aspiring machine learner. There are easy ones, such as testing your approach with the same data on which you have trained. But there are more difficult ones, when you have imbalanced training data. Again, data is the part that determines whether your undertaking will fail or succeed.</p><p>We see that only the fourth point is dealing with the fancy algorithms. Nevertheless, we hope that this book will convince you that the other four tasks are not simply chores, but can be equally exciting. Our hope is that by the end of the book, you will have truly fallen in love with data instead of learning algorithms.</p><p>To that end, we will not overwhelm you with the theoretical aspects of the diverse ML algorithms, as there are already excellent books in that area (you will find pointers in the Appendix). Instead, we will try to provide an intuition of the underlying approaches in the individual chapters—just enough for you to get the idea and be able to undertake your first steps. Hence, this book is by no means <span class="emphasis"><em>the definitive guide</em></span> to machine learning. It is more of a starter kit. We hope that it ignites your curiosity enough to keep you eager in trying to learn more and more about this interesting field.</p><p>In the rest of this chapter, we will set up and get to know the basic Python libraries NumPy and SciPy and then train our first machine learning using scikit-learn. During that endeavor, we will introduce basic ML concepts that will be used throughout the book. The rest of the chapters will then go into more detail through the five steps described earlier, highlighting different aspects of machine learning in Python using diverse application scenarios.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="What to do when you are stuck"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>What to do when you are stuck</h1></div></div></div><p>We try to convey every idea necessary to reproduce the steps throughout this book. Nevertheless, there will be situations where you are stuck. The reasons might range from simple typos over odd combinations of package versions to problems in understanding.</p><p>In this situation, there are many different ways to get help. Most likely, your problem will already be raised and solved in the following excellent Q&amp;A sites:</p><p>
<a class="ulink" href="http://metaoptimize.com/qa">http://metaoptimize.com/qa</a>: This<a id="id5" class="indexterm"/> Q&amp;A site is laser-focused on <a id="id6" class="indexterm"/>machine learning topics. For almost every question, it contains above average answers from machine learning experts. Even if you don't have any questions, it is a good habit to check it out every now and then and read through some of the answers.</p><p>
<a class="ulink" href="http://stats.stackexchange.com">http://stats.stackexchange.com</a>: This <a id="id7" class="indexterm"/>Q&amp;A site is named <a id="id8" class="indexterm"/>Cross Validated, similar to MetaOptimize, but is focused more on statistical problems.</p><p>
<a class="ulink" href="http://stackoverflow.com">http://stackoverflow.com</a>: This <a id="id9" class="indexterm"/>Q&amp;A site is much like the previous ones, but with broader focus on general programming topics. It contains, for example, more<a id="id10" class="indexterm"/> questions on some of the packages that we will use in this book, such as SciPy or matplotlib.</p><p>
<code class="literal">#machinelearning</code> on <a class="ulink" href="https://freenode.net/">https://freenode.net/</a>: This is the IRC channel focused on machine learning topics. It is a small but very active and helpful community of machine learning experts.</p><p>
<a class="ulink" href="http://www.TwoToReal.com">http://www.TwoToReal.com</a>: This <a id="id11" class="indexterm"/>is the instant Q&amp;A site written by<a id="id12" class="indexterm"/> the authors to support you in topics that don't fit in any of the preceding buckets. If you post your question, one of the authors will get an instant message if he is online and be drawn in a chat with you.</p><p>As stated in the beginning, this book tries to help you get started quickly on your machine learning journey. Therefore, we highly encourage you to build up your own list of machine learning related blogs and check them out regularly. This is the best way to get to know what works and what doesn't.</p><p>The only blog we want to highlight right here (more in the Appendix) is <a class="ulink" href="http://blog.kaggle.com">http://blog.kaggle.com</a>, the blog <a id="id13" class="indexterm"/>of the Kaggle company, which is carrying out machine learning competitions. Typically, they encourage the<a id="id14" class="indexterm"/> winners of the competitions to write down how they approached the competition, what strategies did not work, and how they arrived at the winning strategy. Even if you don't read anything else, this is a must.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Getting started"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Getting started</h1></div></div></div><p>Assuming that you have Python already installed (everything at least as recent as 2.7 should be fine), we need to install NumPy and SciPy for numerical operations, as well as matplotlib for visualization.</p><div class="section" title="Introduction to NumPy, SciPy, and matplotlib"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec07"/>Introduction to NumPy, SciPy, and matplotlib</h2></div></div></div><p>Before we <a id="id15" class="indexterm"/>can talk about concrete machine learning algorithms, we have to talk about how best to store the data we will chew through. This is important as the most advanced learning algorithm will not be of any help to us if it will never finish. This may be simply because accessing the data is too slow. Or maybe its representation forces the operating system to swap all day. Add to this that Python is an interpreted language (a highly optimized one, though) that is slow for many numerically heavy algorithms compared to C or FORTRAN. So we might ask why on earth so many scientists and companies are betting their fortune on Python even in highly computation-intensive areas?</p><p>The answer is that, in Python, it is very easy to off-load number crunching tasks to the lower layer in the form of C or FORTRAN extensions. And that is exactly what NumPy and<a id="id16" class="indexterm"/> SciPy<a id="id17" class="indexterm"/> do (<a class="ulink" href="http://scipy.org/Download">http://scipy.org/Download</a>). In this tandem, NumPy provides the support of highly optimized multidimensional arrays, which are the basic data structure of most state-of-the-art algorithms. SciPy uses those arrays to provide a set of fast numerical <a id="id18" class="indexterm"/>recipes. Finally, matplotlib (<a class="ulink" href="http://matplotlib.org/">http://matplotlib.org/</a>) is probably the <a id="id19" class="indexterm"/>most convenient and feature-rich library to plot high-quality graphs using Python.</p></div><div class="section" title="Installing Python"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec08"/>Installing Python</h2></div></div></div><p>Luckily, for all<a id="id20" class="indexterm"/> major operating systems, that is, Windows, Mac, and Linux, there are targeted installers for NumPy, SciPy, and matplotlib. If you are unsure about the installation process, you might want to install <a id="id21" class="indexterm"/>Anaconda Python distribution (which you can access at <a class="ulink" href="https://store.continuum.io/cshop/anaconda/">https://store.continuum.io/cshop/anaconda/</a>), which is driven by Travis Oliphant, a founding contributor of SciPy. What sets Anaconda apart from other distributions such as<a id="id22" class="indexterm"/> Enthought Canopy (which you can download from <a class="ulink" href="https://www.enthought.com/downloads/">https://www.enthought.com/downloads/</a>) or <a id="id23" class="indexterm"/>Python(x,y) (accessible at <a class="ulink" href="http://code.google.com/p/pythonxy/wiki/Downloads">http://code.google.com/p/pythonxy/wiki/Downloads</a>), is that Anaconda is already fully Python 3 compatible—the Python version we will be using throughout the book.</p></div><div class="section" title="Chewing data efficiently with NumPy and intelligently with SciPy"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Chewing data efficiently with NumPy and intelligently with SciPy</h2></div></div></div><p>Let's walk quickly through<a id="id24" class="indexterm"/> some basic NumPy examples and then take a look at what SciPy provides on top of it. On the way, we will get our feet wet with plotting using the marvelous Matplotlib package.</p><p>For an in-depth explanation, you might want to take a look at some of the more interesting<a id="id25" class="indexterm"/> examples of what NumPy has to offer at <a class="ulink" href="http://www.scipy.org/Tentative_NumPy_Tutorial">http://www.scipy.org/Tentative_NumPy_Tutorial</a>.</p><p>You will also find the <span class="emphasis"><em>NumPy Beginner's Guide - Second Edition</em></span>, <span class="emphasis"><em>Ivan Idris</em></span>, by Packt Publishing,<a id="id26" class="indexterm"/> to <a id="id27" class="indexterm"/>be very valuable. Additional tutorial style guides can be found at <a class="ulink" href="http://scipy-lectures.github.com">http://scipy-lectures.github.com</a>, and the official SciPy tutorial at <a class="ulink" href="http://docs.scipy.org/doc/scipy/reference/tutorial">http://docs.scipy.org/doc/scipy/reference/tutorial</a>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note02"/>Note</h3><p>In this book, we will use NumPy in version 1.8.1 and SciPy in version 0.14.0.</p></div></div></div><div class="section" title="Learning NumPy"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Learning NumPy</h2></div></div></div><p>So let's <a id="id28" class="indexterm"/>import NumPy and play a bit with it. For that, we need to start the Python interactive shell:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; import numpy</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; numpy.version.full_version</strong></span>
<span class="strong"><strong>1.8.1</strong></span>
</pre></div><p>As we do not want to pollute our namespace, we certainly should not use the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; from numpy import *</strong></span>
</pre></div><p>Because, for instance, <code class="literal">numpy.array</code> will potentially shadow the array package that is included in standard Python. Instead, we will use the following convenient shortcut:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; import numpy as np</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; a = np.array([0,1,2,3,4,5])</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; a</strong></span>
<span class="strong"><strong>array([0, 1, 2, 3, 4, 5])</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; a.ndim</strong></span>
<span class="strong"><strong>1</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; a.shape</strong></span>
<span class="strong"><strong>(6,)</strong></span>
</pre></div><p>So, we just created an array like we would create a list in Python. However, the NumPy arrays have additional information about the shape. In this case, it is a one-dimensional array of six elements. No surprise so far.</p><p>We can now transform this array to a two-dimensional matrix:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; b = a.reshape((3,2))</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; b</strong></span>
<span class="strong"><strong>array([[0, 1],</strong></span>
<span class="strong"><strong>       [2, 3],</strong></span>
<span class="strong"><strong>       [4, 5]])</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; b.ndim</strong></span>
<span class="strong"><strong>2</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; b.shape</strong></span>
<span class="strong"><strong>(3, 2)</strong></span>
</pre></div><p>The funny thing<a id="id29" class="indexterm"/> starts when we realize just how much the NumPy package is optimized. For example, doing this avoids copies wherever possible:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; b[1][0] = 77</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; b</strong></span>
<span class="strong"><strong>array([[ 0,  1],</strong></span>
<span class="strong"><strong>       [77,  3],</strong></span>
<span class="strong"><strong>       [ 4,  5]])</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; a</strong></span>
<span class="strong"><strong>array([ 0,  1, 77,  3,  4,  5])</strong></span>
</pre></div><p>In this case, we have modified value <code class="literal">2</code> to <code class="literal">77</code> in <code class="literal">b</code>, and immediately see the same change reflected in <code class="literal">a</code> as well. Keep in mind that whenever you need a true copy, you can always perform:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; c = a.reshape((3,2)).copy()</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; c</strong></span>
<span class="strong"><strong>array([[ 0,  1],</strong></span>
<span class="strong"><strong>       [77,  3],</strong></span>
<span class="strong"><strong>       [ 4,  5]])</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; c[0][0] = -99</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; a</strong></span>
<span class="strong"><strong>array([ 0,  1, 77,  3,  4,  5])</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; c</strong></span>
<span class="strong"><strong>array([[-99,   1],</strong></span>
<span class="strong"><strong>       [ 77,   3],</strong></span>
<span class="strong"><strong>       [  4,   5]])</strong></span>
</pre></div><p>Note that here, <code class="literal">c</code> and <code class="literal">a</code> are totally independent copies.</p><p>Another big advantage of NumPy arrays is that the operations are propagated to the individual elements. For example, multiplying a NumPy array will result in an array of the same size with all of its elements being multiplied:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; d = np.array([1,2,3,4,5])</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; d*2</strong></span>
<span class="strong"><strong>array([ 2,  4,  6,  8, 10])</strong></span>
</pre></div><p>Similarly, for other operations:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; d**2</strong></span>
<span class="strong"><strong>array([ 1,  4,  9, 16, 25])</strong></span>
</pre></div><p>Contrast<a id="id30" class="indexterm"/> that to ordinary Python lists:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; [1,2,3,4,5]*2</strong></span>
<span class="strong"><strong>[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; [1,2,3,4,5]**2</strong></span>
<span class="strong"><strong>Traceback (most recent call last):</strong></span>
<span class="strong"><strong>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong></span>
<span class="strong"><strong>TypeError: unsupported operand type(s) for ** or pow(): 'list' and 'int'</strong></span>
</pre></div><p>Of course by using NumPy arrays, we sacrifice the agility Python lists offer. Simple operations such as adding or removing are a bit complex for NumPy arrays. Luckily, we have both at our hands and we will use the right one for the task at hand.</p><div class="section" title="Indexing"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec01"/>Indexing</h3></div></div></div><p>Part <a id="id31" class="indexterm"/>of the power of NumPy comes from the versatile ways in which its arrays can be accessed.</p><p>In addition to normal list indexing, it allows you to use arrays themselves as indices by performing:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; a[np.array([2,3,4])]</strong></span>
<span class="strong"><strong>array([77,  3,  4])</strong></span>
</pre></div><p>Together with the fact that conditions are also propagated to individual elements, we gain a very convenient way to access our data:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; a&gt;4</strong></span>
<span class="strong"><strong>array([False, False,  True, False, False,  True], dtype=bool)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; a[a&gt;4]</strong></span>
<span class="strong"><strong>array([77,  5])</strong></span>
</pre></div><p>By performing the following command, this can be used to trim outliers:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; a[a&gt;4] = 4</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; a</strong></span>
<span class="strong"><strong>array([0, 1, 4, 3, 4, 4])</strong></span>
</pre></div><p>As this is a frequent use case, there is the special clip function for it, clipping the values at both ends of an interval with one function call:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; a.clip(0,4)</strong></span>
<span class="strong"><strong>array([0, 1, 4, 3, 4, 4])</strong></span>
</pre></div></div><div class="section" title="Handling nonexisting values"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec02"/>Handling nonexisting values</h3></div></div></div><p>The <a id="id32" class="indexterm"/>power of NumPy's indexing capabilities comes in handy when preprocessing data that we have just read in from a text file. Most likely, that will contain invalid values that we will mark as not being a real number using <code class="literal">numpy.NAN</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; c = np.array([1, 2, np.NAN, 3, 4]) # let's pretend we have read this from a text file</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; c</strong></span>
<span class="strong"><strong>array([  1.,   2.,  nan,   3.,   4.])</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; np.isnan(c)</strong></span>
<span class="strong"><strong>array([False, False,  True, False, False], dtype=bool)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; c[~np.isnan(c)]</strong></span>
<span class="strong"><strong>array([ 1.,  2.,  3.,  4.])</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; np.mean(c[~np.isnan(c)])</strong></span>
<span class="strong"><strong>2.5</strong></span>
</pre></div></div><div class="section" title="Comparing the runtime"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec03"/>Comparing the runtime</h3></div></div></div><p>Let's <a id="id33" class="indexterm"/>compare the runtime behavior of NumPy compared with normal Python lists. In the following code, we will calculate the sum of all squared numbers from 1 to 1000 and see how much time it will take. We perform it 10,000 times and report the total time so that our measurement is accurate enough.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>import timeit</strong></span>
<span class="strong"><strong>normal_py_sec = timeit.timeit('sum(x*x for x in range(1000))',</strong></span>
<span class="strong"><strong>                              number=10000)</strong></span>
<span class="strong"><strong>naive_np_sec = timeit.timeit(</strong></span>
<span class="strong"><strong>                'sum(na*na)',</strong></span>
<span class="strong"><strong>                setup="import numpy as np; na=np.arange(1000)",</strong></span>
<span class="strong"><strong>                number=10000)</strong></span>
<span class="strong"><strong>good_np_sec = timeit.timeit(</strong></span>
<span class="strong"><strong>                'na.dot(na)',</strong></span>
<span class="strong"><strong>                setup="import numpy as np; na=np.arange(1000)",</strong></span>
<span class="strong"><strong>                number=10000)</strong></span>

<span class="strong"><strong>print("Normal Python: %f sec" % normal_py_sec)</strong></span>
<span class="strong"><strong>print("Naive NumPy: %f sec" % naive_np_sec)</strong></span>
<span class="strong"><strong>print("Good NumPy: %f sec" % good_np_sec)</strong></span>

<span class="strong"><strong>Normal Python: 1.050749 sec</strong></span>
<span class="strong"><strong>Naive NumPy: 3.962259 sec</strong></span>
<span class="strong"><strong>Good NumPy: 0.040481 sec</strong></span>
</pre></div><p>We make <a id="id34" class="indexterm"/>two interesting observations. Firstly, by just using NumPy as data storage (Naive NumPy) takes 3.5 times longer, which is surprising since we believe it must be much faster as it is written as a C extension. One reason for this is that the access of individual elements from Python itself is rather costly. Only when we are able to apply algorithms inside the optimized extension code is when we get speed improvements. The other observation is quite a tremendous one: using the <code class="literal">dot()</code> function of NumPy, which does exactly the same, allows us to be more than 25 times faster. In summary, in every algorithm we are about to implement, we should always look how we can move loops over individual elements from Python to some of the highly optimized NumPy or SciPy extension functions.</p><p>However, the speed comes at a price. Using NumPy arrays, we no longer have the incredible flexibility of Python lists, which can hold basically anything. NumPy arrays always have only one data type.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; a = np.array([1,2,3])</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; a.dtype</strong></span>
<span class="strong"><strong>dtype('int64')</strong></span>
</pre></div><p>If we try to use elements of different types, such as the ones shown in the following code, NumPy will do its best to coerce them to be the most reasonable common data type:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; np.array([1, "stringy"])</strong></span>
<span class="strong"><strong>array(['1', 'stringy'], dtype='&lt;U7')</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; np.array([1, "stringy", set([1,2,3])])</strong></span>
<span class="strong"><strong>array([1, stringy, {1, 2, 3}], dtype=object)</strong></span>
</pre></div></div></div><div class="section" title="Learning SciPy"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"/>Learning SciPy</h2></div></div></div><p>On top <a id="id35" class="indexterm"/>of the efficient data structures of NumPy, SciPy offers a magnitude of algorithms working on those arrays. Whatever numerical heavy algorithm you take from current books on numerical recipes, most likely you will find support for them in SciPy in one way or the other. Whether it is matrix manipulation, linear algebra, optimization, clustering, spatial operations, or even fast Fourier transformation, the toolbox is readily filled. Therefore, it is a good habit to always inspect the <code class="literal">scipy</code> module before you start implementing a numerical algorithm.</p><p>For convenience, the complete namespace of NumPy is also accessible via SciPy. So, from now on, we will use NumPy's machinery via the SciPy namespace. You can check this easily <a id="id36" class="indexterm"/>comparing the function references of any base function, such as:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; import scipy, numpy</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; scipy.version.full_version</strong></span>
<span class="strong"><strong>0.14.0</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; scipy.dot is numpy.dot</strong></span>
<span class="strong"><strong>True</strong></span>
</pre></div><p>The diverse algorithms are grouped into<a id="id37" class="indexterm"/> the following toolboxes:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>SciPy packages</p>
</th><th style="text-align: left" valign="bottom">
<p>Functionalities</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">cluster</code>
</p>
</td><td style="text-align: left" valign="top">
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Hierarchical clustering (<code class="literal">cluster.hierarchy</code>)</li><li class="listitem" style="list-style-type: disc">Vector <a id="id38" class="indexterm"/>quantization / k-means (<code class="literal">cluster.vq</code>)</li></ul></div>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">constants</code>
</p>
</td><td style="text-align: left" valign="top">
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Physical<a id="id39" class="indexterm"/> and mathematical constants</li><li class="listitem" style="list-style-type: disc">Conversion methods</li></ul></div>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">fftpack</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Discrete <a id="id40" class="indexterm"/>Fourier transform algorithms</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">integrate</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Integration <a id="id41" class="indexterm"/>routines</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">interpolate</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Interpolation (linear, cubic, and<a id="id42" class="indexterm"/> so on)</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">io</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Data<a id="id43" class="indexterm"/> input and output</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">linalg</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Linear <a id="id44" class="indexterm"/>algebra routines using the optimized BLAS and LAPACK libraries</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ndimage</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<span class="emphasis"><em>n</em></span>-dimensional<a id="id45" class="indexterm"/> image package</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">odr</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Orthogonal <a id="id46" class="indexterm"/>distance regression</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">optimize</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Optimization (finding <a id="id47" class="indexterm"/>minima and roots)</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">signal</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Signal <a id="id48" class="indexterm"/>processing</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">sparse</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Sparse <a id="id49" class="indexterm"/>matrices</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">spatial</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Spatial <a id="id50" class="indexterm"/>data structures and algorithms</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">special</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Special <a id="id51" class="indexterm"/>mathematical functions such as Bessel or Jacobian</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">stats</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Statistics <a id="id52" class="indexterm"/>toolkit</p>
</td></tr></tbody></table></div><p>The toolboxes<a id="id53" class="indexterm"/> most<a id="id54" class="indexterm"/> interesting to our endeavor are <code class="literal">scipy.stats</code>, <code class="literal">scipy.interpolate</code>, <code class="literal">scipy.cluster</code>, and <code class="literal">scipy.signal</code>. For the sake of brevity, we will briefly explore some features of the stats package and leave the others to be explained when they show up in the individual chapters.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Our first (tiny) application of machine learning"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Our first (tiny) application of machine learning</h1></div></div></div><p>Let's get <a id="id55" class="indexterm"/>our <a id="id56" class="indexterm"/>hands dirty and take a look at our hypothetical web start-up, MLaaS, which sells the service of providing machine learning algorithms via HTTP. With increasing success of our company, the demand for better infrastructure increases to serve all incoming web requests successfully. We don't want to allocate too many resources as that would be too costly. On the other side, we will lose money, if we have not reserved enough resources to serve all incoming requests. Now, the question is, when will we hit the limit of our current infrastructure, which we estimated to be at 100,000 requests per hour. We<a id="id57" class="indexterm"/> would like to know in advance when we have to <a id="id58" class="indexterm"/>request additional servers in the cloud to serve all the incoming requests successfully without paying for unused ones.</p><div class="section" title="Reading in the data"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"/>Reading in the data</h2></div></div></div><p>We have collected <a id="id59" class="indexterm"/>the web stats for the last month and aggregated them in <code class="literal">ch01/data/web_traffic.tsv</code> (<code class="literal">.tsv</code> because it contains tab-separated values). They are stored as the number of hits per hour. Each line contains the hour consecutively and the number of web hits in that hour.</p><p>The first few lines look like the following:</p><div class="mediaobject"><img src="images/2772OS_01_09.jpg" alt="Reading in the data"/></div><p>Using SciPy's <code class="literal">genfromtxt()</code>, we can easily read in the data using the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; import scipy as sp</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; data = sp.genfromtxt("web_traffic.tsv", delimiter="\t")</strong></span>
</pre></div><p>We have to specify tab as the delimiter so that the columns are correctly determined.</p><p>A quick check shows that we have correctly read in the data:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; print(data[:10])</strong></span>
<span class="strong"><strong>[[  1.00000000e+00   2.27200000e+03]</strong></span>
<span class="strong"><strong> [  2.00000000e+00              nan]</strong></span>
<span class="strong"><strong> [  3.00000000e+00   1.38600000e+03]</strong></span>
<span class="strong"><strong> [  4.00000000e+00   1.36500000e+03]</strong></span>
<span class="strong"><strong> [  5.00000000e+00   1.48800000e+03]</strong></span>
<span class="strong"><strong> [  6.00000000e+00   1.33700000e+03]</strong></span>
<span class="strong"><strong> [  7.00000000e+00   1.88300000e+03]</strong></span>
<span class="strong"><strong> [  8.00000000e+00   2.28300000e+03]</strong></span>
<span class="strong"><strong> [  9.00000000e+00   1.33500000e+03]</strong></span>
<span class="strong"><strong> [  1.00000000e+01   1.02500000e+03]]</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; print(data.shape)</strong></span>
<span class="strong"><strong>(743, 2)</strong></span>
</pre></div><p>As you can see, we <a id="id60" class="indexterm"/>have 743 data points with two dimensions.</p></div><div class="section" title="Preprocessing and cleaning the data"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"/>Preprocessing and cleaning the data</h2></div></div></div><p>It is more <a id="id61" class="indexterm"/>convenient for SciPy to separate the dimensions into two vectors, each of size 743. The first vector, <code class="literal">x</code>, will contain<a id="id62" class="indexterm"/> the hours, and the other, <code class="literal">y</code>, will contain the Web hits in that particular hour. This splitting is done using the special index notation of SciPy, by which we can choose the columns individually:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>x = data[:,0]</strong></span>
<span class="strong"><strong>y = data[:,1]</strong></span>
</pre></div><p>There are many more ways in which data can be selected from a SciPy array. Check out <a class="ulink" href="http://www.scipy.org/Tentative_NumPy_Tutorial">http://www.scipy.org/Tentative_NumPy_Tutorial</a> for more details on indexing, slicing, and iterating.</p><p>One caveat is still that we have some values in <code class="literal">y</code> that contain invalid values, <code class="literal">nan</code>. The question is what we can do with them. Let's check how many hours contain invalid data, by running the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; sp.sum(sp.isnan(y))</strong></span>
<span class="strong"><strong>8</strong></span>
</pre></div><p>As you can see, we are missing only 8 out of 743 entries, so we can afford to remove them. Remember that we can index a SciPy array with another array. <code class="literal">Sp.isnan(y)</code> returns an array of <a id="id63" class="indexterm"/>Booleans<a id="id64" class="indexterm"/> indicating whether an entry is a number or not. Using <code class="literal">~</code>, we logically negate that array so that we choose only those elements from <code class="literal">x</code> and <code class="literal">y</code> where <code class="literal">y</code> contains valid numbers:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; x = x[~sp.isnan(y)]</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; y = y[~sp.isnan(y)]</strong></span>
</pre></div><p>To get the first impression of our data, let's plot the data in a scatter plot using matplotlib. matplotlib contains the pyplot package, which tries to mimic MATLAB's interface, which is a very convenient and easy to use one as you can see in the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; import matplotlib.pyplot as plt</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; # plot the (x,y) points with dots of size 10</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.scatter(x, y, s=10)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.title("Web traffic over the last month")</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.xlabel("Time")</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.ylabel("Hits/hour")</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.xticks([w*7*24 for w in range(10)],</strong></span>
<span class="strong"><strong>               ['week %i' % w for w in range(10)])</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.autoscale(tight=True)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; # draw a slightly opaque, dashed grid</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.grid(True, linestyle='-', color='0.75')</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.show()</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>You can find more tutorials on plotting at <a class="ulink" href="http://matplotlib.org/users/pyplot_tutorial.html">http://matplotlib.org/users/pyplot_tutorial.html</a>.</p></div></div><p>In the resulting chart, we can see that while in the first weeks the traffic stayed more or less the same, the last week shows a steep increase:</p><div class="mediaobject"><img src="images/2772OS_01_01.jpg" alt="Preprocessing and cleaning the data"/></div></div><div class="section" title="Choosing the right model and learning algorithm"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec14"/>Choosing the right model and learning algorithm</h2></div></div></div><p>Now that we have a <a id="id65" class="indexterm"/>first impression of the data, we return to<a id="id66" class="indexterm"/> the initial question: How long will our server handle the incoming web traffic? To answer this we have to do the following:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Find the real model behind the noisy data points.</li><li class="listitem">Following this, use the model to extrapolate into the future to find the point in time where our infrastructure has to be extended.</li></ol></div><div class="section" title="Before building our first model…"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec04"/>Before building our first model…</h3></div></div></div><p>When we talk <a id="id67" class="indexterm"/>about models, you <a id="id68" class="indexterm"/>can think of them as simplified theoretical approximations of complex reality. As such there is always some inferiority involved, also called the approximation error. This error will guide us in choosing the right model among the myriad of choices we have. And this error will be calculated as the squared distance of the model's prediction to the real data; for example, for a learned model function <code class="literal">f</code>, the error is calculated as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>def error(f, x, y):</strong></span>
<span class="strong"><strong>    return sp.sum((f(x)-y)**2)</strong></span>
</pre></div><p>The vectors <code class="literal">x</code> and <code class="literal">y</code> contain the web stats data that we have extracted earlier. It is the beauty of SciPy's vectorized functions that we exploit here with <code class="literal">f(x)</code>. The trained model is assumed to take a vector and return the results again as a vector of the same size so that we can use it to calculate the difference to <code class="literal">y</code>.</p></div><div class="section" title="Starting with a simple straight line"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec05"/>Starting with a simple straight line</h3></div></div></div><p>Let's assume <a id="id69" class="indexterm"/>for a second that the underlying model is a straight line. Then the challenge is how to best put that line into the chart so that it results in the smallest approximation error. SciPy's <code class="literal">polyfit()</code> function does exactly that. Given data <code class="literal">x</code> and <code class="literal">y</code> and the desired order of the polynomial (a straight line has order 1), it finds the model function that minimizes the error function defined earlier:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>fp1, residuals, rank, sv, rcond = sp.polyfit(x, y, 1, full=True)</strong></span>
</pre></div><p>The <code class="literal">polyfit()</code> function returns the parameters of the fitted model function, <code class="literal">fp1</code>. And by setting <code class="literal">full=True</code>, we also get additional background information on the fitting process. Of this, only residuals are of interest, which is exactly the error of the approximation:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; print("Model parameters: %s" % fp1)</strong></span>
<span class="strong"><strong>Model parameters: [   2.59619213  989.02487106]</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; print(residuals)</strong></span>
<span class="strong"><strong>[  3.17389767e+08]</strong></span>
</pre></div><p>This means the best straight line fit is the following function</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>f(x) = 2.59619213 * x + 989.02487106.</strong></span>
</pre></div><p>We then use <code class="literal">poly1d()</code> to create a model function from the model parameters:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; f1 = sp.poly1d(fp1)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; print(error(f1, x, y))</strong></span>
<span class="strong"><strong>317389767.34</strong></span>
</pre></div><p>We have used <code class="literal">full=True</code> to retrieve more details on the fitting process. Normally, we would not need it, in which case only the model parameters would be returned.</p><p>We can <a id="id70" class="indexterm"/>now use <code class="literal">f1()</code> to plot our first trained model. In addition to the preceding plotting instructions, we simply add the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>fx = sp.linspace(0,x[-1], 1000) # generate X-values for plotting</strong></span>
<span class="strong"><strong>plt.plot(fx, f1(fx), linewidth=4)</strong></span>
<span class="strong"><strong>plt.legend(["d=%i" % f1.order], loc="upper left")</strong></span>
</pre></div><p>This will produce the following plot:</p><div class="mediaobject"><img src="images/2772OS_01_02.jpg" alt="Starting with a simple straight line"/></div><p>It seems like the first 4 weeks are not that far off, although we clearly see that there is something wrong with our initial assumption that the underlying model is a straight line. And then, how good or how bad actually is the error of 317,389,767.34?</p><p>The absolute <a id="id71" class="indexterm"/>value of the error is seldom of use in isolation. However, when comparing two competing models, we can use their errors to judge which one of them is better. Although our first model clearly is not the one we would use, it serves a very important purpose in the workflow. We will use it as our baseline until we find a better one. Whatever model we come up with in the future, we will compare it against the current baseline.</p></div><div class="section" title="Towards some advanced stuff"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec06"/>Towards some advanced stuff</h3></div></div></div><p>Let's now fit a <a id="id72" class="indexterm"/>more complex model, a polynomial of degree 2, to see whether it better understands our data:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; f2p = sp.polyfit(x, y, 2)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; print(f2p)</strong></span>
<span class="strong"><strong>array([  1.05322215e-02,  -5.26545650e+00,   1.97476082e+03])</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; f2 = sp.poly1d(f2p)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; print(error(f2, x, y))</strong></span>
<span class="strong"><strong>179983507.878</strong></span>
</pre></div><p>You will get the following plot:</p><div class="mediaobject"><img src="images/2772OS_01_03.jpg" alt="Towards some advanced stuff"/></div><p>The error<a id="id73" class="indexterm"/> is 179,983,507.878, which is almost half the error of the straight line model. This is good but unfortunately this comes with a price: We now have a more complex function, meaning that we have one parameter more to tune inside <code class="literal">polyfit()</code>. The fitted polynomial is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>f(x) = 0.0105322215 * x**2  - 5.26545650 * x + 1974.76082</strong></span>
</pre></div><p>So, if more complexity gives better results, why not increase the complexity even more? Let's try it for degrees 3, 10, and 100.</p><div class="mediaobject"><img src="images/2772OS_01_04.jpg" alt="Towards some advanced stuff"/></div><p>Interestingly, we<a id="id74" class="indexterm"/> do not see <code class="literal">d=53</code> for the polynomial that had been fitted with 100 degrees. Instead, we see lots of warnings on the console:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>RankWarning: Polyfit may be poorly conditioned</strong></span>
</pre></div><p>This means because of numerical errors, polyfit cannot determine a good fit with 100 degrees. Instead, it figured that 53 must be good enough.</p><p>It seems like the curves capture and better the fitted data the more complex they get. And also, the errors seem to tell the same story:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Error d=1: 317,389,767.339778</strong></span>
<span class="strong"><strong>Error d=2: 179,983,507.878179</strong></span>
<span class="strong"><strong>Error d=3: 139,350,144.031725</strong></span>
<span class="strong"><strong>Error d=10: 121,942,326.363461</strong></span>
<span class="strong"><strong>Error d=53: 109,318,004.475556</strong></span>
</pre></div><p>However, taking <a id="id75" class="indexterm"/>a closer look at the fitted curves, we start to wonder whether they also capture the true process that generated that data. Framed differently, do our models correctly represent the underlying mass behavior of customers visiting our website? Looking at the polynomial of degree 10 and 53, we see wildly oscillating behavior. It seems that the models are fitted too much to the data. So much that it is now capturing not only the underlying process but also the noise. This is called <a id="id76" class="indexterm"/>
<span class="strong"><strong>overfitting</strong></span>.</p><p>At this point, we have the following choices:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Choosing one of the fitted polynomial models.</li><li class="listitem" style="list-style-type: disc">Switching to another more complex model class. Splines?</li><li class="listitem" style="list-style-type: disc">Thinking differently about the data and start again.</li></ul></div><p>Out of the five fitted models, the first order model clearly is too simple, and the models of order 10 and 53 are clearly overfitting. Only the second and third order models seem to somehow match the data. However, if we extrapolate them at both borders, we see them going berserk.</p><p>Switching to a more complex class seems also not to be the right way to go. What arguments would back which class? At this point, we realize that we probably have not fully understood our data.</p></div><div class="section" title="Stepping back to go forward – another look at our data"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec07"/>Stepping back to go forward – another look at our data</h3></div></div></div><p>So, we step <a id="id77" class="indexterm"/>back and take another look at the data. It seems that there is an inflection point between weeks 3 and 4. So let's separate the data and train two lines using week 3.5 as a separation point:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>inflection = 3.5*7*24 # calculate the inflection point in hours</strong></span>
<span class="strong"><strong>xa = x[:inflection] # data before the inflection point</strong></span>
<span class="strong"><strong>ya = y[:inflection]</strong></span>
<span class="strong"><strong>xb = x[inflection:] # data after</strong></span>
<span class="strong"><strong>yb = y[inflection:]</strong></span>

<span class="strong"><strong>fa = sp.poly1d(sp.polyfit(xa, ya, 1))</strong></span>
<span class="strong"><strong>fb = sp.poly1d(sp.polyfit(xb, yb, 1))</strong></span>

<span class="strong"><strong>fa_error = error(fa, xa, ya)</strong></span>
<span class="strong"><strong>fb_error = error(fb, xb, yb)</strong></span>
<span class="strong"><strong>print("Error inflection=%f" % (fa_error + fb_error))</strong></span>
<span class="strong"><strong>Error inflection=132950348.197616</strong></span>
</pre></div><p>From the <a id="id78" class="indexterm"/>first line, we train with the data up to week 3, and in the second line we train with the remaining data.</p><div class="mediaobject"><img src="images/2772OS_01_05.jpg" alt="Stepping back to go forward – another look at our data"/></div><p>Clearly, the combination of these two lines seems to be a much better fit to the data than anything we have modeled before. But still, the combined error is higher than the higher order polynomials. Can we trust the error at the end?</p><p>Asked differently, why do we trust the straight line fitted only at the last week of our data more than any of the more complex models? It is because we assume that it will capture future data better. If we plot the models into the future, we see how right we are (<span class="strong"><strong>d=1</strong></span> is again our initial straight line).</p><div class="mediaobject"><img src="images/2772OS_01_06.jpg" alt="Stepping back to go forward – another look at our data"/></div><p>The models of <a id="id79" class="indexterm"/>degree 10 and 53 don't seem to expect a bright future of our start-up. They tried so hard to model the given data correctly that they are clearly useless to extrapolate beyond. This is called overfitting. On the other hand, the lower degree models seem not to be capable of capturing the data good enough. This is called <a id="id80" class="indexterm"/>
<span class="strong"><strong>underfitting</strong></span>.</p><p>So let's play fair to models of degree 2 and above and try out how they behave if we fit them only to the data of the last week. After all, we believe that the last week says more about the future than the data prior to it. The result can be seen in the following psychedelic chart, which further shows how badly the problem of overfitting is.</p><div class="mediaobject"><img src="images/2772OS_01_07.jpg" alt="Stepping back to go forward – another look at our data"/></div><p>Still, judging from <a id="id81" class="indexterm"/>the errors of the models when trained only on the data from week 3.5 and later, we still should choose the most complex one (note that we also calculate the error only on the time after the inflection point):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Error d=1:   22,143,941.107618</strong></span>
<span class="strong"><strong>Error d=2:   19,768,846.989176</strong></span>
<span class="strong"><strong>Error d=3:   19,766,452.361027</strong></span>
<span class="strong"><strong>Error d=10:  18,949,339.348539</strong></span>
<span class="strong"><strong>Error d=53:  18,300,702.038119</strong></span>
</pre></div></div><div class="section" title="Training and testing"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec08"/>Training and testing</h3></div></div></div><p>If we only<a id="id82" class="indexterm"/> had some data from the future that we could use to measure our models against, then we should be able to judge our model choice only on the resulting approximation error.</p><p>Although we<a id="id83" class="indexterm"/> cannot look into the future, we can and should simulate a similar effect by holding out a part of our data. Let's remove, for instance, a certain percentage of the data and train on the remaining one. Then we used the held-out data to calculate the error. As the model has been trained not knowing the held-out data, we should get a more realistic picture of how the model will behave in the future.</p><p>The test errors for the models trained only on the time after inflection point now show a completely different picture:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Error d=1: 6397694.386394</strong></span>
<span class="strong"><strong>Error d=2: 6010775.401243</strong></span>
<span class="strong"><strong>Error d=3: 6047678.658525</strong></span>
<span class="strong"><strong>Error d=10: 7037551.009519</strong></span>
<span class="strong"><strong>Error d=53: 7052400.001761</strong></span>
</pre></div><p>Have a look at the following plot:</p><div class="mediaobject"><img src="images/2772OS_01_08.jpg" alt="Training and testing"/></div><p>It seems<a id="id84" class="indexterm"/> that we <a id="id85" class="indexterm"/>finally have a clear winner: The model with degree 2 has the lowest test error, which is the error when measured using data that the model did not see during training. And this gives us hope that we won't get bad surprises when future data arrives.</p></div><div class="section" title="Answering our initial question"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec09"/>Answering our initial question</h3></div></div></div><p>Finally we have arrived at a model which we think represents the underlying process best; it is now a simple task of finding out when our infrastructure will reach 100,000 requests per hour. We<a id="id86" class="indexterm"/> have to calculate when our model function reaches the value 100,000.</p><p>Having a polynomial of degree 2, we could simply compute the inverse of the function and calculate its value at 100,000. Of course, we would like to have an approach that is applicable to any model function easily.</p><p>This can be done <a id="id87" class="indexterm"/>by subtracting 100,000 from the polynomial, which results in another polynomial, and finding its root. SciPy's <code class="literal">optimize</code> module has the function <code class="literal">fsolve</code> that achieves this, when providing an initial starting position with parameter <code class="literal">x0</code>. As every entry in our input data file corresponds to one hour, and we have 743 of them, we set the starting position to some value after that. Let <code class="literal">fbt2</code> be the winning polynomial of degree 2.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; fbt2 = sp.poly1d(sp.polyfit(xb[train], yb[train], 2))</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; print("fbt2(x)= \n%s" % fbt2)</strong></span>
<span class="strong"><strong>fbt2(x)=</strong></span>
<span class="strong"><strong>       2</strong></span>
<span class="strong"><strong>0.086 x - 94.02 x + 2.744e+04</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; print("fbt2(x)-100,000= \n%s" % (fbt2-100000))</strong></span>
<span class="strong"><strong>fbt2(x)-100,000=</strong></span>
<span class="strong"><strong>       2</strong></span>
<span class="strong"><strong>0.086 x - 94.02 x - 7.256e+04</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; from scipy.optimize import fsolve</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; reached_max = fsolve(fbt2-100000, x0=800)/(7*24)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; print("100,000 hits/hour expected at week %f" % reached_max[0])</strong></span>
</pre></div><p>It is expected to have 100,000 hits/hour at week 9.616071, so our model tells us that, given the current user behavior and traction of our start-up, it will take another month until we have reached our capacity threshold.</p><p>Of course, there is a certain uncertainty involved with our prediction. To get a real picture of it, one could draw in more sophisticated statistics to find out about the variance we have to expect when looking farther and farther into the future.</p><p>And then there are the user and underlying user behavior dynamics that we cannot model accurately. However, at this point, we are fine with the current predictions. After all, we can prepare all time-consuming actions now. If we then monitor our web traffic closely, we will see in time when we have to allocate new resources.</p></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Summary</h1></div></div></div><p>Congratulations! You just learned two important things, of which the most important one is that as a typical machine learning operator, you will spend most of your time in understanding and refining the data—exactly what we just did in our first tiny machine learning example. And we hope that this example helped you to start switching your mental focus from algorithms to data. Then you learned how important it is to have the correct experiment setup and that it is vital to not mix up training and testing.</p><p>Admittedly, the use of polynomial fitting is not the coolest thing in the machine learning world. We have chosen it to not distract you by the coolness of some shiny algorithm when we conveyed the two most important messages we just summarized earlier.</p><p>So, let's move to the next chapter in which we will dive deep into scikit-learn, the marvelous machine learning toolkit, give an overview of different types of learning, and show you the beauty of feature engineering.</p></div></div>
</body></html>