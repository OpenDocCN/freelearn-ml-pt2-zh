["```py\n    import matplotlib.pyplot as plt\n    import mlxtend.frequent_patterns\n    import mlxtend.preprocessing\n    import numpy\n    import pandas\n    ```", "```py\n    example = [['milk', 'bread', 'apples', 'cereal', 'jelly', \\\n                'cookies', 'salad', 'tomatoes'], \\\n               ['beer', 'milk', 'chips', 'salsa', 'grapes', \\\n                'wine', 'potatoes', 'eggs', 'carrots'], \\\n               ['diapers', 'baby formula', 'milk', 'bread', \\\n                'chicken', 'asparagus', 'cookies'], \\\n               ['milk', 'cookies', 'chicken', 'asparagus', \\\n                'broccoli', 'cereal', 'orange juice'], \\\n               ['steak', 'asparagus', 'broccoli', 'chips', \\\n                'salsa', 'ketchup', 'potatoes', 'salad'], \\\n               ['beer', 'salsa', 'asparagus', 'wine', 'cheese', \\\n                'crackers', 'strawberries', 'cookies'],\\\n               ['chocolate cake', 'strawberries', 'wine', 'cheese', \\\n                'beer', 'milk', 'orange juice'],\\\n               ['chicken', 'peas', 'broccoli', 'milk', 'bread', \\\n                'eggs', 'potatoes', 'ketchup', 'crackers'],\\\n               ['eggs', 'bread', 'cheese', 'turkey', 'salad', \\\n                'tomatoes', 'wine', 'steak', 'carrots'],\\\n               ['bread', 'milk', 'tomatoes', 'cereal', 'chicken', \\\n                'turkey', 'chips', 'salsa', 'diapers']]\n    print(example)\n    ```", "```py\n    # the number of transactions\n    N = len(example)\n    # the frequency of milk\n    f_x = sum(['milk' in i for i in example])\n    # the frequency of bread\n    f_y = sum(['bread' in i for i in example]) \n    # the frequency of milk and bread\n    f_x_y = sum([all(w in i for w in ['milk', 'bread']) \\\n                 for i in example])\n    # print out the metrics computed above\n    print(\"N = {}\\n\".format(N) + \"Freq(x) = {}\\n\".format(f_x) \\\n          + \"Freq(y) = {}\\n\".format(f_y) \\\n          + \"Freq(x, y) = {}\".format(f_x_y))\n    ```", "```py\n    N = 10\n    Freq(x) = 7\n    Freq(y) = 5\n    Freq(x, y) = 4\n    ```", "```py\n    support = f_x_y / N\n    print(\"Support = {}\".format(round(support, 4)))\n    ```", "```py\n    confidence = support / (f_x / N)\n    print(\"Confidence = {}\".format(round(confidence, 4)))\n    ```", "```py\n    lift = confidence / (f_y / N)\n    print(\"Lift = {}\".format(round(lift, 4)))\n    ```", "```py\n    leverage = support - ((f_x / N) * (f_y / N))\n    print(\"Leverage = {}\".format(round(leverage, 4)))\n    ```", "```py\n    conviction = (1 - (f_y / N)) / (1 - confidence)\n    print(\"Conviction = {}\".format(round(conviction, 4)))\n    ```", "```py\n    online = pandas.read_excel(io=\"./Online Retail.xlsx\", \\\n                               sheet_name=\"Online Retail\", \\\n                               header=0)\n    ```", "```py\n    online.head(10)\n    ```", "```py\n    online.dtypes\n    ```", "```py\n    InvoiceNo              object\n    StockCode              object\n    Description            object\n    Quantity                int64\n    InvoiceDate    datetime64[ns]\n    UnitPrice             float64\n    CustomerID            float64\n    Country                object\n    dtype: object\n    ```", "```py\n    print(\"Data dimension (row count, col count): {dim}\" \\\n          .format(dim=online.shape))\n    print(\"Count of unique invoice numbers: {cnt}\" \\\n          .format(cnt=online.InvoiceNo.nunique()))\n    print(\"Count of unique customer ids: {cnt}\" \\\n          .format(cnt=online.CustomerID.nunique()))\n    ```", "```py\n    Data dimension (row count, col count): (541909, 8)\n    Count of unique invoice numbers: 25900\n    Count of unique customer ids: 4372\n    ```", "```py\n    # create new column called IsCPresent\n    online['IsCPresent']  = (# looking for C in InvoiceNo column \\\n                             .astype(str)\\\n                             .apply(lambda x: 1 if x.find('C') \\\n                                    != -1 else 0))\n    ```", "```py\n    online1 = (online\\\n               # filter out non-positive quantity values\\\n               .loc[online[\"Quantity\"] > 0]\\\n               # remove InvoiceNos starting with C\\\n               .loc[online['IsCPresent'] != 1]\\\n               # column filtering\\\n               .loc[:, [\"InvoiceNo\", \"Description\"]]\\\n               # dropping all rows with at least one missing value\\\n               .dropna())\n    ```", "```py\n    online1.head(10)\n    ```", "```py\n    print(\"Data dimension (row count, col count): {dim}\"\\\n          .format(dim=online1.shape)\\\n    )\n    print(\"Count of unique invoice numbers: {cnt}\"\\\n          .format(cnt=online1.InvoiceNo.nunique())\\\n    )\n    ```", "```py\n    Data dimension (row count, col count): (530693, 2)\n    Count of unique invoice numbers: 20136\n    ```", "```py\n    invoice_no_list = online1.InvoiceNo.tolist()\n    invoice_no_list = list(set(invoice_no_list))\n    print(\"Length of list of invoice numbers: {ln}\" \\\n          .format(ln=len(invoice_no_list)))\n    ```", "```py\n    Length of list of invoice numbers: 20136\n    ```", "```py\n    subset_invoice_no_list = invoice_no_list[0:5000]\n    print(\"Length of subset list of invoice numbers: {ln}\"\\\n          .format(ln=len(subset_invoice_no_list)))\n    ```", "```py\n    Length of subset list of invoice numbers: 5000\n    ```", "```py\n    online1 = online1.loc[online1[\"InvoiceNo\"]\\\n                         .isin(subset_invoice_no_list)]\n    ```", "```py\n    online1.head(10)\n    ```", "```py\n    print(\"Data dimension (row count, col count): {dim}\"\\\n          .format(dim=online1.shape))\n    print(\"Count of unique invoice numbers: {cnt}\"\\\n          .format(cnt=online1.InvoiceNo.nunique()))\n    ```", "```py\n    Data dimension (row count, col count): (133315, 2)\n    Count of unique invoice numbers: 5000\n    ```", "```py\n    invoice_item_list = []\n    for num in list(set(online1.InvoiceNo.tolist())):\n        # filter dataset down to one invoice number\n        tmp_df = online1.loc[online1['InvoiceNo'] == num]\n        # extract item descriptions and convert to list\n        tmp_items = tmp_df.Description.tolist()\n        # append list invoice_item_list\n        invoice_item_list.append(tmp_items)\n    print(invoice_item_list[1:5])\n    ```", "```py\ndef manual_encoding(ll):\n    # unlist the list of lists input\n    # result is one list with all the elements of the sublists\n    list_dup_unsort_items = \\\n    [element for sub in ll for element in sub]\n    # two cleaning steps:\n    \"\"\"\n    1\\. remove duplicate items, only want one of each item in list\n    \"\"\"\n    #     2\\. sort items in alphabetical order\n    list_nondup_sort_items = \\\n    sorted(list(set(list_dup_unsort_items)))\n    # initialize DataFrame with all elements having False value\n    # name the columns the elements of list_dup_unsort_items\n    manual_df = pandas.DataFrame(False, \\\n                                 index=range(len(ll)), \\\n                                 columns=list_dup_unsort_items)\n    \"\"\"\n    change False to True if element is \n    in individual transaction list\n    \"\"\"\n    \"\"\"\n    each row is represents the contains of an individual transaction\n    \"\"\"\n    # (sublist from the original list of lists)\n    for i in range(len(ll)):\n        for j in ll[i]:\n            manual_df.loc[i, j] = True\n    # return the True/False DataFrame\n    return manual_df\n```", "```py\n    online_encoder = mlxtend.preprocessing.TransactionEncoder()\n    online_encoder_array = online_encoder\\\n                           .fit_transform(invoice_item_list)\n    print(online_encoder_array)\n    ```", "```py\n    [[False False False ... False False False]\n     [False False False ... False False False]\n     [False False False ... False False False]\n     ...\n     [False False False ... False False False]\n     [False False False ... False False False]\n     [False False False ... False False False]]\n    ```", "```py\n    online_encoder_df = pandas.DataFrame(online_encoder_array, \\\n                                         columns=online_encoder\\\n                                         .columns_)\n    \"\"\"\n    this is a very big table, so for more \n    easy viewing only a subset is printed\n    \"\"\"\n    online_encoder_df.loc[4970:4979, \\\n                          online_encoder_df.columns.tolist()[0:8]]\n    ```", "```py\n    print(\"Data dimension (row count, col count): {dim}\"\\\n          .format(dim=online_encoder_df.shape))\n    ```", "```py\n    Data dimension (row count, col count): (5000, 3135)\n    ```", "```py\nL1 = {frequent items}\nk = 1\nL = {}\nwhile Lk.Length is not an empty set do\n    Ck+1 = candidate item sets derived from Lk\n    For each transaction t in the dataset do\n        Increment the count of the candidates \\\n            in Ck+1 that appear in t\n    Compute the support for the candidates in Ck+1 \\\n        using the appearance counts\n    Lk+1 = the candidates in Ck+1 meeting \\\n          the minimum support requirement\n    L.append(Lk)\n    k = k + 1\nEnd\nReturn L = all frequent item sets with corresponding support values\n```", "```py\n    mod = mlxtend.frequent_patterns.apriori(online_encoder_df)\n    mod\n    ```", "```py\n    mod_minsupport = mlxtend.frequent_patterns\\\n                     .apriori(online_encoder_df, \\\n                     min_support=0.01)\n    mod_minsupport.loc[0:6]\n    ```", "```py\n    mod_colnames_minsupport = mlxtend.frequent_patterns\\\n                              .apriori(online_encoder_df, \\\n                                       min_support=0.01, \\\n                                       use_colnames=True)\n    mod_colnames_minsupport.loc[0:6]\n    ```", "```py\n    mod_colnames_minsupport['length'] = \\\n    (mod_colnames_minsupport['itemsets'].apply(lambda x: len(x)))\n    mod_colnames_minsupport.loc[0:6]\n    ```", "```py\n    mod_colnames_minsupport[mod_colnames_minsupport['itemsets'] \\\n                            == frozenset({'10 COLOUR SPACEBOY PEN'})]\n    ```", "```py\n    mod_colnames_minsupport[(mod_colnames_minsupport['length'] == 2) \\\n                             & (mod_colnames_minsupport\\\n                                ['support'] >= 0.02) \\\n                             & (mod_colnames_minsupport\\\n                                ['support'] < 0.021)]\n    ```", "```py\n    mod_colnames_minsupport.hist(\"support\", grid=False, bins=30)\n    plt.xlabel(\"Support of item\")\n    plt.ylabel(\"Number of items\")\n    plt.title(\"Frequency distribution of Support\")\n    plt.show()\n    ```", "```py\n    rules = mlxtend.frequent_patterns\\\n            .association_rules(mod_colnames_minsupport, \\\n            metric=\"confidence\", \\\n            min_threshold=0.6,  \\\n            support_only=False)\n    rules.loc[0:6]\n    ```", "```py\n    print(\"Number of Associations: {}\".format(rules.shape[0]))\n    ```", "```py\n    rules2 = mlxtend.frequent_patterns\\\n             .association_rules(mod_colnames_minsupport, \\\n             metric=\"lift\", \\\n             min_threshold=50,\\\n             support_only=False)\n    rules2.loc[0:6]\n    ```", "```py\n    print(\"Number of Associations: {}\".format(rules2.shape[0]))\n    ```", "```py\n    rules.plot.scatter(\"support\", \"confidence\", \\\n                       alpha=0.5, marker=\"*\")\n    plt.xlabel(\"Support\")\n    plt.ylabel(\"Confidence\")\n    plt.title(\"Association Rules\")\n    plt.show()\n    ```", "```py\n    rules.hist(\"confidence\", grid=False, bins=30)\n    plt.xlabel(\"Confidence of item\")\n    plt.ylabel(\"Number of items\")\n    plt.title(\"Frequency distribution of Confidence\")\n    plt.show()\n    ```", "```py\n    rules.hist(\"lift\", grid=False, bins=30)\n    plt.xlabel(\"Lift of item\")\n    plt.ylabel(\"Number of items\")\n    plt.title(\"Frequency distribution of Lift\")\n    plt.show()\n    ```", "```py\n    rules.hist(\"leverage\", grid=False, bins=30)\n    plt.xlabel(\"Leverage of item\")\n    plt.ylabel(\"Number of items\")\n    plt.title(\"Frequency distribution of Leverage\")\n    plt.show()\n    ```", "```py\n    plt.hist(rules[numpy.isfinite(rules['conviction'])]\\\n                                  .conviction.values, bins = 30)\n    plt.xlabel(\"Coviction of item\")\n    plt.ylabel(\"Number of items\")\n    plt.title(\"Frequency distribution of Conviction\")\n    plt.show()\n    ```"]