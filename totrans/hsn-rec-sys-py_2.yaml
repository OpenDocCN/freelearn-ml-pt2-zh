- en: Manipulating Data with the Pandas Library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the next few portions of the book, we are going to get our hands dirty by
    building the various kinds of recommender systems that were introduced in chapter
    one. However, before we do so, it is important that we know how to handle, manipulate,
    and analyze data efficiently in Python.
  prefs: []
  type: TYPE_NORMAL
- en: The datasets we'll be working with will be several megabytes in size. Historically,
    Python has never been well-known for its speed of execution. Therefore, analyzing
    such huge amounts of data using vanilla Python and the built-in data structures
    it provides us is simply impossible.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we're going to get ourselves acquainted with the pandas library,
    which aims to overcome the aforementioned limitations, making data analysis in
    Python extremely efficient and user-friendly. We'll also introduce ourselves to
    the *Movies Dataset *that we're going to use to build our recommenders as well
    as use pandas to extract some interesting facts and narrate the history of movies
    using data.
  prefs: []
  type: TYPE_NORMAL
- en: '**Disclaimer:** If you are already familiar with the pandas library, you may
    skip this chapter and move on to the next, *Building an IMDB Top 250 Clone with p**andas*.'
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will be required to have Python installed on a system. Finally, to use the
    Git repository of this book, the user needs to install Git.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files of this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Hands-On-Recommendation-Systems-with-Python](https://github.com/PacktPublishing/Hands-On-Recommendation-Systems-with-Python)[.](https://github.com/PacktPublishing/Hands-On-Recommendation-Systems-with-Python)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2LoZEUj](http://bit.ly/2LoZEUj)[.](http://bit.ly/2LoZEUj)'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start coding, we should probably set up our development environment.
    For data scientists and analysts using Python, the Jupyter Notebook is, by far,
    the most popular tool for development. Therefore, we strongly advise that you
    use this environment.
  prefs: []
  type: TYPE_NORMAL
- en: We will also need to download the pandas library. The easiest way to obtain
    both is to download Anaconda. Anaconda is a distribution that comes with the Jupyter
    software and the SciPy packages (which includes pandas).
  prefs: []
  type: TYPE_NORMAL
- en: You can download the distribution here**: **[https://www.anaconda.com/download/](https://www.anaconda.com/download/).
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to create a new folder (I'm going to name it `RecoSys`) in
    your desired location. This will be the master folder that contains all the code
    we write as part of this book. Within this folder, create another folder named `Chapter2`, which
    will contain all the code we write as part of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, open your Terminal application, navigate to the `Chapter2`folder, and
    run the `jupyter notebook` command. The commands should look something like this
    if you''re on a Mac or Linux (the cdpath will differ in Windows):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Jupyter Notebooks run on the browser on the localhost. Therefore, they're OS-independent.
    In other words, the experience will be the same regardless of whether you're on
    a Mac, a PC, or a Linux box.
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon running the `jupyter notebook`command, your default browser should open
    up to the `localhost:8888/tree`URL and a window that looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c47502be-6824-45a2-a0a1-712a0b5bf4ea.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To the right of the window, you should be able to see a Newdropdown. Click
    it and create a new Python 3 (or Python 2) Notebook. Doing so will open a new
    tab with an untitled notebook. You''ll also be able to see an input cellwith a
    pointer in it. This is space where we write our code (and markdown). Go ahead
    and type the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To execute the code in this cell, press *Shift *+ *Enter. *If all goes well,
    you should see a new output cell, which prints the version of the pandas library
    (for us, it is 0.20.3):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e403f392-9129-4d5b-aa26-efa72fa65a3a.png)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations!
  prefs: []
  type: TYPE_NORMAL
- en: You've now successfully set up your development environment. Of course, there
    is much more to Jupyter Notebooks than running a cell. We will be talking about
    these other features as and when we use them. Since this is not a book on Jupyter,
    we will be redirecting you to the free tutorials online if you're interested in
    learning the fundamentals of the Jupyter Notebook first. DataCamp has a definitive
    article on the subject.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the DataCamp Jupyter Notebook Tutorial here: [https://www.datacamp.com/community/tutorials/tutorial-jupyter-notebook](https://www.datacamp.com/community/tutorials/tutorial-jupyter-notebook).
  prefs: []
  type: TYPE_NORMAL
- en: In case you're having trouble setting up your environment, googling the error
    should direct you to a page suggesting a suitable solution. Websites such as Stack
    Overflow have thousands of questions on Anaconda setup and it is extremely likely
    that the problem you're facing has been faced by someone else before.
  prefs: []
  type: TYPE_NORMAL
- en: The Pandas library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pandas is a package that gives us access to high-performance, easy-to-use tools
    and data structures for data analysis in Python.
  prefs: []
  type: TYPE_NORMAL
- en: As we stated in the introduction, Python is a slow language. Pandas overcomes
    this by implementing heavy optimization using the C programming language. It also
    gives us access to Series and DataFrame, two extremely powerful and user-friendly
    data structures imported from the R Statistical Package.
  prefs: []
  type: TYPE_NORMAL
- en: Pandas also makes importing data from external files into the Python environment
    a breeze. It supports a wide variety of formats, such as JSON, CSV, HDF5, SQL,
    NPY, and XLSX.
  prefs: []
  type: TYPE_NORMAL
- en: As a first step toward working with pandas, let's import our movies data into
    our Jupyter Notebook. To do this, we need the path to where our dataset is located.
    This can be a URL on the internet or your local computer. We highly recommend
    downloading the data to your local computer and accessing it from a local path
    instead of from a web URL.
  prefs: []
  type: TYPE_NORMAL
- en: Go to the following URL to download the required CSV file**:** [https://www.kaggle.com/rounakbanik/the-movies-dataset/downloads/movies_metadata.csv/7.](https://www.kaggle.com/rounakbanik/the-movies-dataset/downloads/movies_metadata.csv/7.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new folder called `data` in the `RecoSys` directory and move the `movies_metadata.csv` file
    that you just downloaded into this folder. Now, let''s witness some pandas magic.
    In the Jupyter Notebook you ran in the previous section, go to the second cell
    and type the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Et voila! You should be able to see a table-like structure with five rows, each
    row representing a movie. You can also see that the table has 24 columns, although
    the columns were truncated to fit in the display.
  prefs: []
  type: TYPE_NORMAL
- en: 'What is this structure though? Let''s find out by running the familiar `type`command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You should get an output stating that df is a `pandas.core.frame.DataFrame`*. *In
    other words, our code has read the CSV file into a pandas DataFrame object. But
    what are DataFrames? Let's find that out in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The Pandas DataFrame
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we saw in the previous section, the `df.head()`code outputted a table-like
    structure. In essence, the DataFrame is just that: a two-dimensional data structure
    with columns of different data types. You can think of it as an SQL Table. Of
    course, just being a table of rows and columns isn''t what makes the DataFrame
    special. The DataFrame gives us access to a wide variety of functionality, some
    of which we''re going to explore in this section.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each row in our DataFrame represents a movie. But how many movies are there?
    We can find this out by running the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The result gives us the number of rows and columns present in df. We can see
    that we have data on 45,466 movies.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also see that we have 24 columns. Each column represents a feature or a
    piece of metadata about the movie. When we ran `df.head()`*, *we saw that most
    of the columns were truncated to fit in the display. To view all the columns (henceforth,
    called features) we have, we can run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We see that we have a lot of information on these movies, including their title,
    budget, genres, release date, and revenue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s find out how to access a particular movie (or row). The first
    way to do this is by using the `.iloc`method. This allows us to select rows based
    on the numeric position, starting from zero. For example, if we wanted to access
    the second movie in the DataFrame, we''d run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The output will give you information about the movie on each of its 24 features.
    We see that the title of the movie is *Jumanji* and that it was released on December
     15th, 1995, among other things.
  prefs: []
  type: TYPE_NORMAL
- en: A cell will always print the output of the last line of code. Therefore, we
    don't need to explicitly write it within a `print`function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second way to do it is by accessing the DataFrame index. Since we didn''t
    explicitly set an index while reading the CSV file, pandas defaulted it to zero-based
    indexing. We can change the index of df quite easily. Let''s change the index
    to the title of the movie and try to access `Jumanji` using this index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see an output identical to the previous cell. Let''s revert back
    to our zero-based numeric index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to create a new, smaller DataFrame with fewer columns.
    Let''s create a new DataFrame that only has the following features: `title`, `release_date`,
    `budget`, `revenue`, `runtime`, and `genres`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You should see a table with five movies and only the features that we've mentioned.
    The `.head()`method simply displays the first five rows of the DataFrame. You
    can display as many rows as you want by passing it as an argument into `.head()`*:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s check out the data types of our various features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: A curious observation here is that pandas correctly deciphers `revenue`and `runtime`as
    float data, but assigns the generic object data type to `budget`*. *
  prefs: []
  type: TYPE_NORMAL
- en: 'However, pandas allows us to manually convert the data type of a feature. Let''s
    try to convert the `budget`feature to `float`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Running this cell throws `ValueError`. It is easy to guess that one of the budget
    fields had a `'/zaSf...'` string as its value, and pandas was not able to convert
    this into a floating number.
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, we will use the `apply()`method. This will allow us
    to apply a function to every field in a particular column and convert it into
    the return value. We are going to convert every number field in `budget`to float
    and, if that fails, convert it to `NaN`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This time around, there are no errors thrown. Also, we notice that the `budget`feature
    is now of the `float64` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s try to define a new feature, called `year`, that represents the
    year of release. The recommended way to do this would be by using the `datetime`
    functionality that pandas gives us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'What are the oldest movies available in this dataset? To answer this question,
    we can sort the DataFrame based on the year of release:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We see that we have movies from as early as the 1870s, with *Passage of Venus *being
    the oldest movie on record. Next, let''s find out the most successful movies of
    all time. To do this, we''ll use the `sort_values()`method once again, but with
    an additional `ascending=False`parameter to sort `DataFrame` in descending order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: From our results, we observe that *Avatar *is the most successful movie of all
    time, with a revenue of over $2.78 billion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we wanted to create a new DataFrame of movies that satisfied a certain
    condition. For instance, we only want movies that earned more than $1 billion.
    Pandas makes this possible using its Boolean Indexing feature. Let''s see this
    in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to apply multiple conditions. For instance, let''s say
    we only wanted movies that earned more than $1 billion, but where the outlay less
    than $150 million, we''d do it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Only four movies make it into this list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is, of course, much more to what you can do with DataFrames (such as
    handling missing data), but we''ll stop our exploration with it for now. Let''s
    move on to another data structure we have unknowingly used extensively in this
    section: the Pandas Series.'
  prefs: []
  type: TYPE_NORMAL
- en: The Pandas Series
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we accessed the Jumanjimovie using `.loc`and `.iloc`*, *the data structures
    returned to us were Pandas Series objects. You may have also noticed that we were
    accessing entire columns using `df[column_name]`*. *This, too, was a Pandas Series
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The Pandas Series is a one-dimensional labelled array capable of holding data
    of any type. You may think of it as a Python list on steroids. When we were using
    the `.apply()`and `.astype()`methods in the previous section, we were actually
    using them on these Series objects.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, like the DataFrame, the Series object comes with its own group of
    extremely useful methods that make data analysis a breeze.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s check out the shortest- and longest-running movies of all time.
    We will do this by accessing the `runtime`column of the DataFrame as a Series
    object and applying its methods on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We see that the longest movie is more than 1,256 minutes in length and the shortest
    is 0! Of course, such strange results demand a deeper inspection of the data but
    we shall skip that, for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to calculate the mean and median of the Series in this
    way. Let''s do so for the movie budgets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The average budget of a movie is $4.2 million and the median budget is 0! This
    suggests that at least half the movies in our dataset have no budget at all! Like
    in the previous case, such strange results demand closer inspection. In this case,
    it is highly likely that a zero budget indicates that the data is not available.
  prefs: []
  type: TYPE_NORMAL
- en: 'What is the revenue that the 90th-percentile movie generated? We can discover
    this using the `quantile`function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We get a result of $8.26 million. What this means is that only 10% of the movies
    in our dataset earned more than $8.26 million in revenue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s find out the number of movies released each year. We do this
    using the `value_counts()`method on the `year`series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We have the highest number of movies released in 2014\. There are also six years
    in our dataset (including 2020) that have only one movie on record.
  prefs: []
  type: TYPE_NORMAL
- en: We'll stop our tour of the pandas library here. As I have already mentioned,
    there is much more to pandas than what we have covered in this chapter. However,
    this should be sufficient to tackle the data-wrangling and analysis tasks that
    we'll encounter while building our recommenders.
  prefs: []
  type: TYPE_NORMAL
- en: You may rename the notebook as `Chapter2`by clicking on Untitled and then close
    it. For the next chapter, we will create a new notebook.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we gained an understanding of the limitations of using vanilla
    Python and its built-in data structures. We acquainted ourselves with the Pandas
    library and learned how it overcomes the aforementioned difficulties by giving
    us access to extremely powerful and easy-to-use data structures. We then explored
    the two main data structures, Series and DataFrame, by analyzing our movies-metadata
    dataset.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will use our newfound skills to build an IMDB Top 250
    Clone and its variant, a type of knowledge-based recommender.
  prefs: []
  type: TYPE_NORMAL
