- en: Chapter 1
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章
- en: Thinking Probabilistically
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概率思维
- en: Probability theory is nothing but common sense reduced to calculation. – Pierre
    Simon Laplace
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 概率论无非是将常识简化为计算。——皮埃尔·西蒙·拉普拉斯
- en: In this chapter, we will learn about the core concepts of Bayesian statistics
    and some of the instruments in the Bayesian toolbox. We will use some Python code,
    but this chapter will be mostly theoretical; most of the concepts we will see
    here will be revisited many times throughout this book. This chapter, being heavy
    on the theoretical side, is perhaps a little anxiogenic for the coder in you,
    but I think it will ease the path to effectively applying Bayesian statistics
    to your problems.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将学习贝叶斯统计的核心概念以及贝叶斯工具箱中的一些工具。我们会使用一些 Python 代码，但这一章大部分内容将是理论性的；我们在这里看到的大部分概念将在本书的许多部分中反复出现。这一章理论性较强，可能会让你这个编码者有些焦虑，但我认为它会为有效地将贝叶斯统计应用于你的问题铺平道路。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将涵盖以下主题：
- en: Statistical modeling
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 统计建模
- en: Probabilities and uncertainty
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概率与不确定性
- en: Bayes’ theorem and statistical inference
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 贝叶斯定理与统计推断
- en: Single-parameter inference and the classic coin-flip problem
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单参数推断和经典的抛硬币问题
- en: Choosing priors and why people often don’t like them but should
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择先验分布及为何人们通常不喜欢它们，但其实应该喜欢
- en: Communicating a Bayesian analysis
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传达贝叶斯分析结果
- en: 1.1 Statistics, models, and this book’s approach
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1 统计学、模型和本书的方法
- en: 'Statistics is about collecting, organizing, analyzing, and interpreting data,
    and hence statistical knowledge is essential for data analysis. Two main statistical
    methods are used in data analysis:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 统计学是关于收集、整理、分析和解释数据的，因此统计知识对数据分析至关重要。在数据分析中使用了两种主要的统计方法：
- en: '**Exploratory Data Analysis (EDA)**: This is about numerical summaries, such
    as the mean, mode, standard deviation, and interquartile ranges. EDA is also about
    visually inspecting the data, using tools you may be already familiar with, such
    as histograms and scatter plots.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**探索性数据分析（EDA）**：这涉及到数值汇总，例如均值、众数、标准差和四分位数范围。EDA 还涉及通过可视化检查数据，使用你可能已经熟悉的工具，比如直方图和散点图。'
- en: '**Inferential statistics**: This is about making statements beyond the current
    data. We may want to understand some particular phenomenon, maybe we want to make
    predictions for future (yet unobserved) data points, or we need to choose among
    several competing explanations for the same set of observations. In summary, inferential
    statistics allow us to draw meaningful insights from a limited set of data and
    make informed decisions based on the results of our analysis.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**推断统计**：这是关于超越当前数据进行推理。我们可能想要了解某种特定现象，或者我们想要对未来（尚未观察到的）数据点进行预测，或者我们需要在多个竞争性解释之间做出选择，针对同一组观察数据。总之，推断统计让我们能够从有限的数据中提取有意义的见解，并基于分析结果做出明智的决策。'
- en: A Match Made in Heaven
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 天作之合
- en: The focus of this book is on how to perform Bayesian inferential statistics,
    but we will also use ideas from EDA to summarize, interpret, check, and communicate
    the results of Bayesian inference.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的重点是如何进行贝叶斯推断统计，但我们也会借用探索性数据分析（EDA）中的一些思想来总结、解释、检查并传达贝叶斯推断的结果。
- en: 'Most introductory statistical courses, at least for non-statisticians, are
    taught as a collection of recipes that go like this: go to the statistical pantry,
    pick one tin can and open it, add data to taste, and stir until you obtain a consistent
    p-value, preferably under 0.05\. The main goal of these courses is to teach you
    how to pick the proper can. I never liked this approach, mainly because the most
    common result is a bunch of confused people unable to grasp, even at the conceptual
    level, the unity of the different learned methods. We will take a different approach:
    we will learn some recipes, but they will be homemade rather than canned food;
    we will learn how to mix fresh ingredients that will suit different statistical
    occasions and, more importantly, that will let you apply concepts far beyond the
    examples in this book.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数入门级统计课程，至少对于非统计学专业的人来说，通常被教授为一系列的“配方”，大致如下：走进统计学的储藏室，挑选一罐罐头打开，加入数据，按个人口味调味，搅拌直到得到一个一致的
    p 值，最好小于 0.05。 这些课程的主要目标是教你如何选择合适的罐头。我从不喜欢这种方法，主要是因为最常见的结果是一群困惑的人，甚至在概念层面也无法理解不同学习方法的统一性。我们将采取不同的方法：我们将学习一些配方，但它们是自制的，而非罐头食品；我们将学习如何混合新鲜的原料，适用于不同的统计场合，更重要的是，这将让你能将这些概念应用到本书中的例子之外的场景中。
- en: 'Taking this approach is possible for two reasons:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种方法是因为两个原因：
- en: '**Ontological**: Statistics is a form of modeling unified under the mathematical
    framework of probability theory. Using a probabilistic approach provides a unified
    view of what may seem like very disparate methods; statistical methods and machine
    learning methods look much more similar under the probabilistic lens.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本体论**：统计学是一种建模方法，统一于概率论的数学框架下。采用概率方法能够提供一个统一的视角来看待那些看似截然不同的方法；统计方法和机器学习方法在概率视角下显得更加相似。'
- en: '**Technical**: Modern software, such as PyMC, allows practitioners, just like
    you and me, to define and solve models in a relatively easy way. Many of these
    models were unsolvable just a few years ago or required a high level of mathematical
    and technical sophistication.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**技术性**：现代软件，如 PyMC，使得从业者——就像你我一样——能够相对轻松地定义和解决模型。几年前，许多这样的模型是无法求解的，或者需要高水平的数学和技术精湛。'
- en: 1.2 Working with data
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2 处理数据
- en: Data is an essential ingredient in statistics and data science. Data comes from
    several sources, such as experiments, computer simulations, surveys, and field
    observations. If we are the ones in charge of generating or gathering the data,
    it is always a good idea to first think carefully about the questions we want
    to answer and which methods we will use, and only then proceed to get the data.
    There is a whole branch of statistics dealing with data collection, known as experimental
    design. In the era of the data deluge, we can sometimes forget that gathering
    data is not always cheap. For example, while it is true that the **Large Hadron
    Collider** (**LHC**) produces hundreds of terabytes a day, its construction took
    years of manual and intellectual labor.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 数据是统计学和数据科学的核心要素。数据来源于多个渠道，例如实验、计算机模拟、调查和实地观察。如果我们负责生成或收集数据，首先仔细思考我们想要回答的问题以及我们将使用哪些方法是非常重要的，只有在此之后，我们才应该开始收集数据。统计学中有一个专门研究数据收集的分支，称为实验设计。在数据泛滥的时代，我们有时会忘记，收集数据并不总是便宜的。例如，虽然**大型强子对撞机**（**LHC**）每天能产生数百
    TB 的数据，但它的建造过程花费了数年的人工和智力劳动。
- en: As a general rule, we can think of the process of generating the data as stochastic,
    because there is ontological, technical, and/or epistemic uncertainty, that is,
    the system is intrinsically stochastic, there are technical issues adding noise
    or restricting us from measuring with arbitrary precision, and/or there are conceptual
    limitations veiling details from us. For all these reasons, we always need to
    interpret data in the context of models, including mental and formal ones. Data
    does not speak but through models.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，我们可以认为数据生成的过程是随机的，因为存在本体论、技术性和/或认识论的不确定性，也就是说，系统本质上是随机的，技术性问题会增加噪声或限制我们以任意精度进行测量，和/或存在概念性局限遮蔽了我们无法看到的细节。基于这些原因，我们总是需要在模型的框架下解读数据，包括心智模型和形式化模型。数据不直接发声，只有通过模型才有意义。
- en: In this book, we will assume that we already have collected the data. Our data
    will also be clean and tidy, something that’s rarely true in the real world. We
    will make these assumptions to focus on the subject of this book. I just want
    to emphasize, especially for newcomers to data analysis, that even when not covered
    in this book, there are important skills that you should learn and practice to
    successfully work with data.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们假设我们已经收集好了数据。我们的数据也将是干净且整洁的，而这在现实世界中是极少见的。我们作出这些假设是为了集中讨论本书的主题。我特别想强调，尤其是对于数据分析的新人来说，即使本书没有涉及，仍然有一些重要的技能需要你去学习和实践，以便能够成功地处理数据。
- en: A very useful skill when analyzing data is knowing how to write code in a programming
    language, such as Python. Manipulating data is usually necessary given that we
    live in a messy world with even messier data, and coding helps to get things done.
    Even if you are lucky and your data is very clean and tidy, coding will still
    be very useful since modern Bayesian statistics is done mostly through programming
    languages such as Python or R. If you want to learn how to use Python for cleaning
    and manipulating data, you can find a good introduction in *Python for Data Analysis*
    by [McKinney](Bibliography.xhtml#Xmckinney_2022) [[2022](Bibliography.xhtml#Xmckinney_2022)].
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 分析数据时，一个非常有用的技能是知道如何在编程语言中编写代码，例如 Python。由于我们生活在一个杂乱的世界中，数据更加杂乱，因此操控数据通常是必要的，编程有助于完成任务。即使你很幸运，数据非常干净整洁，编程仍然非常有用，因为现代贝叶斯统计主要通过像
    Python 或 R 这样的编程语言进行。如果你想学习如何使用 Python 来清理和操控数据，可以参考 [McKinney](Bibliography.xhtml#Xmckinney_2022) 的
    *Python for Data Analysis* 一书 [[2022](Bibliography.xhtml#Xmckinney_2022)]。
- en: 1.3 Bayesian modeling
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3 贝叶斯建模
- en: 'Models are simplified descriptions of a given system or process that, for some
    reason, we are interested in. Those descriptions are deliberately designed to
    capture only the most relevant aspects of the system and not to explain every
    minor detail. This is one reason a more complex model is not always a better one.
    There are many different kinds of models; in this book, we will restrict ourselves
    to Bayesian models. We can summarize the Bayesian modeling process using three
    steps:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 模型是对某个系统或过程的简化描述，出于某些原因，我们对此系统或过程感兴趣。这些描述是刻意设计的，只捕捉系统中最相关的方面，而不解释每一个微小的细节。这也是为什么更复杂的模型不一定是更好的模型的原因之一。有许多不同种类的模型；在本书中，我们将只讨论贝叶斯模型。我们可以用三个步骤总结贝叶斯建模过程：
- en: Given some data and some assumptions on how this data could have been generated,
    we design a model by combining building blocks known as **probability distributions**.
    Most of the time these models are crude approximations, but most of the time that’s
    all we need.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定一些数据和关于这些数据如何生成的假设，我们通过结合称为**概率分布**的构建模块来设计一个模型。大多数时候，这些模型是粗略的近似，但大多数情况下，这正是我们所需要的。
- en: We use Bayes’ theorem to add data to our models and derive the logical consequences
    of combining the data and our assumptions. We say we are **conditioning** the
    model on our data.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用贝叶斯定理将数据添加到我们的模型中，并推导出结合数据和假设的逻辑后果。我们说我们正在**对模型进行条件化**。
- en: We evaluate the model, and its predictions, under different criteria, including
    the data, our expertise on the subject, and sometimes by comparing it to other
    models.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们根据不同的标准评估模型及其预测，包括数据、我们对该主题的专业知识，有时还会通过与其他模型进行比较。
- en: 'In general, we will find ourselves performing these three steps in an iterative
    non-linear fashion. We will retrace our steps at any given point: maybe we made
    a silly coding mistake, or we found a way to change the model and improve it,
    or we realized that we need to add more data or collect a different kind of data.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们会发现自己在一个迭代的非线性方式中执行这三个步骤。我们会在任何时候重新追溯我们的步骤：也许我们犯了一个愚蠢的编码错误，或者我们找到了一种方法来改变模型并改进它，或者我们意识到需要添加更多的数据或收集不同种类的数据。
- en: Bayesian models are also known as **probabilistic models** because they are
    built using probabilities. Why probabilities? Because probabilities are a very
    useful tool to model uncertainty; we even have good arguments to state they are
    the correct mathematical concept. So let’s take a walk through *the garden of
    forking paths* [[Borges](Bibliography.xhtml#Xborges), [1944](Bibliography.xhtml#Xborges)].
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 贝叶斯模型也被称为**概率模型**，因为它们是通过概率构建的。为什么是概率？因为概率是建模不确定性的非常有用的工具；我们甚至有充分的理由认为它们是正确的数学概念。所以让我们一起走进
    *叉路花园* [[Borges](Bibliography.xhtml#Xborges), [1944](Bibliography.xhtml#Xborges)]。
- en: 1.4 A probability primer for Bayesian practitioners
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.4 贝叶斯实践者的概率入门
- en: In this section, we are going to discuss a few general and important concepts
    that are key for better understanding Bayesian methods. Additional probability-related
    concepts will be introduced or elaborated on in future chapters, as we need them.
    For a detailed study of probability theory, however, I highly recommend the book
    *Introduction to Probability* by [Blitzstein](Bibliography.xhtml#Xblitzstein_2019) [[2019](Bibliography.xhtml#Xblitzstein_2019)].
    Those already familiar with the basic elements of probability theory can skip
    this section or skim it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论一些对于更好理解贝叶斯方法至关重要的通用概念和重要概念。未来的章节将根据需要介绍或详细说明其他与概率相关的概念。然而，对于概率论的详细学习，我强烈推荐[Blitzstein](Bibliography.xhtml#Xblitzstein_2019)的《*Introduction
    to Probability*》[[2019](Bibliography.xhtml#Xblitzstein_2019)]一书。已经熟悉概率论基本要素的读者可以跳过本节或快速浏览。
- en: 1.4.1 Sample space and events
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4.1 样本空间与事件
- en: 'Let’s say we are surveying to see how people feel about the weather in their
    area. We asked three individuals whether they enjoy sunny weather, with possible
    responses being “yes” or “no.” The sample space of all possible outcomes can be
    denoted by *S* and consists of eight possible combinations:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在调查人们对自己所在地区天气的看法。我们问了三个人是否喜欢晴天，可能的回答是“是”或“否”。所有可能结果的样本空间可以用*S*表示，并包含八种可能的组合：
- en: '*S* = {(yes, yes, yes), (yes, yes, no), (yes, no, yes), (no, yes, yes), (yes,
    no, no), (no, yes, no), (no, no, yes), (no, no, no)}'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*S* = {(是, 是, 是), (是, 是, 否), (是, 否, 是), (否, 是, 是), (是, 否, 否), (否, 是, 否), (否,
    否, 是), (否, 否, 否)}'
- en: Here, each element of the sample space represents the responses of the three
    individuals in the order they were asked. For example, (yes, no, yes) means the
    first and third people answered “yes” while the second person answered “no.”
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，样本空间中的每个元素代表三个人根据被问到的顺序所做出的回答。例如，(是, 否, 是)表示第一和第三个人回答了“是”，而第二个人回答了“否”。
- en: 'We can define events as subsets of the sample space. For example, event *A*
    is when all three individuals answered “yes”:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将事件定义为样本空间的子集。例如，事件*A*就是所有三个人都回答“是”时发生的事件：
- en: '*A* = {(yes, yes, yes)}'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*A* = {(是, 是, 是)}'
- en: 'Similarly, we can define event *B* as when at least one person answered “no,”
    and then we will have:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以定义事件*B*为至少有一个人回答“否”的情况，然后我们将得到：
- en: '*B* = {(yes, yes, no), (yes, no, yes), (no, yes, yes), (yes, no, no), (no,
    yes, no), (no, no, yes), (no, no, no)}'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*B* = {(是, 是, 否), (是, 否, 是), (否, 是, 是), (是, 否, 否), (否, 是, 否), (否, 否, 是), (否,
    否, 否)}'
- en: 'We can use probabilities as a measure of how likely these events are. Assuming
    all events are equally likely, the probability of event *A*, which is the event
    that all three individuals answered “yes,” is:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用概率来衡量这些事件发生的可能性。假设所有事件发生的概率相等，那么事件*A*的概率，即所有三个人都回答“是”的事件概率为：
- en: '![ number of outcomes in A P (A) = ---------------------------- total number
    of outcomes in S ](img/file4.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![ A 事件的结果数 P (A) = ---------------------------- 样本空间 S 的总结果数 ](img/file4.jpg)'
- en: 'In this case, there is only one outcome in *A*, and there are eight outcomes
    in *S*. Therefore, the probability of *A* is:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，*A*中只有一个结果，而*S*中有八个结果。因此，*A*的概率为：
- en: '![ 1 P(A ) = 8 = 0.125 ](img/file5.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![ 1 P(A ) = 8 = 0.125 ](img/file5.jpg)'
- en: 'Similarly, we can calculate the probability of event *B*, which is the event
    that at least one person answered “no.” Since there are seven outcomes in *B*
    and eight outcomes in *S*, the probability of *B* is:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以计算事件*B*的概率，这个事件表示至少有一个人回答“否”。由于*B*中有七个结果，而*S*中有八个结果，事件*B*的概率为：
- en: '![P(B ) = 7-= 0.875 8 ](img/file6.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![P(B ) = 7-= 0.875 8 ](img/file6.jpg)'
- en: 'Considering all events equally likely is just a particular case that makes
    calculating probabilities easier. This is something called the naive definition
    of probability since it is restrictive and relies on strong assumptions. However,
    it is still useful if we are cautious when using it. For instance, it is not true
    that all yes-no questions have a 50-50 chance. Another example. What is the probability
    of seeing a purple horse? The right answer can vary a lot depending on whether
    we’re talking about the natural color of a real horse, a horse from a cartoon,
    a horse dressed in a parade, etc. Anyway, no matter if the events are equally
    likely or not, the probability of the entire sample space is always equal to 1\.
    We can see that this is true by computing:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有事件视为同样可能的事件只是一个特殊情况，它使得计算概率更为简便。这被称为朴素的概率定义，因为它具有局限性并依赖于强假设。然而，如果我们谨慎使用，它仍然是有用的。例如，并不是所有的“是-否”问题都有50-50的概率。再举个例子，看到一匹紫色的马的概率是多少？正确答案可以有很大的不同，具体取决于我们是在谈论一匹真实马的自然颜色、卡通中的马、一匹穿着游行服装的马，等等。无论事件是否等可能，整个样本空间的概率总是等于1。我们可以通过计算来验证这一点：
- en: '![ number of outcomes in S P (S) = ---------------------------- total number
    of outcomes in S ](img/file7.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![ 结果数目 S P (S) = ---------------------------- S 中结果的总数 ](img/file7.jpg)'
- en: 1 is the highest value a probability can take. Saying that *P*(*S*) = 1 is saying
    that *S* is not only very likely, it is certain. If everything that can happen
    is defined by *S*, then *S* will happen.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 1是概率能达到的最高值。说*P*(*S*) = 1就意味着*S*不仅非常可能，它是确定的。如果*S*定义了所有可能发生的事情，那么*S*一定会发生。
- en: 'If an event is impossible, then its probability is 0\. Let’s define the event
    *C* as the event of three persons saying “banana”:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个事件是不可能的，那么它的概率就是0。我们定义事件*C*为三个人都说“香蕉”的事件：
- en: '*C* = {(banana, banana, banana)}'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*C* = {(香蕉, 香蕉, 香蕉)}'
- en: As *C* is not part of *S*, by definition, it cannot happen. Think of this as
    the questionnaire from our survey only having two boxes, *yes* and *no*. By design,
    our survey is restricting all other possible options.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于*C*不是*S*的一部分，根据定义，它是无法发生的。可以把它看作是我们的调查问卷只有两个选项，*yes*和*no*。根据设计，我们的调查限制了所有其他可能的选项。
- en: 'We can take advantage of the fact that Python includes sets and define a Python
    function to compute probabilities following their naive definition:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用Python包含集合的事实，并定义一个Python函数来按照它们的朴素定义计算概率：
- en: '**Code 1.1**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码 1.1**'
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: I left for the reader the joy of playing with this function.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我把玩这个函数的乐趣留给读者了。
- en: One useful way to conceptualize probabilities is as conserved quantities distributed
    throughout the sample space. This means that if the probability of one event increases,
    the probability of some other event or events must decrease so that the total
    probability remains equal to 1\. This can be illustrated with a simple example.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一种有用的理解概率的方式是将概率视为分布在样本空间中的守恒量。这意味着如果一个事件的概率增加，其他一些事件的概率必须减少，以便总概率保持为1。可以通过一个简单的例子来说明这一点。
- en: Suppose we ask one person whether it will rain tomorrow, with possible responses
    of “yes” and “no.” The sample space for possible responses is given by *S* = {yes,
    no}. An event that will rain tomorrow is represented by *A* = {yes}. If *P*(*A*),
    is 0.5, then the probability of the complement of event *A*, denoted by *P*![(Ac)](img/file8.jpg),
    must also be 0.5\. If for some reason *P*(*A*) increases to 0.8, then *P*![ c
    (A )](img/file9.jpg) must decrease to 0.2\. This property holds for disjoint events,
    which are events that cannot occur simultaneously. For instance, it cannot *rain*
    and *not rain* at the same time tomorrow. You may object that it can rain during
    the morning and not rain during the afternoon. That is true, but that’s a different
    sample space!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们问某人明天是否会下雨，可能的回答是“是”或“否”。可能的回答的样本空间是*S* = {是, 否}。表示明天会下雨的事件是*A* = {是}。如果*P*(*A*)是0.5，那么事件*A*的补集事件的概率，即*P*![(Ac)](img/file8.jpg)，也必须是0.5。如果由于某种原因*P*(*A*)增加到0.8，那么*P*![
    c (A )](img/file9.jpg)必须减少到0.2。这个特性适用于互斥事件，即不能同时发生的事件。例如，明天不可能同时“下雨”和“不下雨”。你可能会反驳，早上可能下雨，下午不下雨。没错，但那是不同的样本空间！
- en: 'So far, we have avoided directly defining probabilities, and instead, we have
    just shown some of their properties and ways to compute them. A general definition
    of probability that works for non-equally likely events is as follows. Given a
    sample space *S*, and the event *A*, which is a subset of *S*, a probability is
    a function *P*, which takes *A* as input and returns a real number between 0 and
    1, as output. The function *P* has some restrictions, defined by the following
    3 axioms. Keep in mind that an axiom is a statement that is taken to be true and
    that we use as the starting point in our reasoning:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们避免了直接定义概率，而是展示了一些概率的性质以及计算方法。适用于非等可能事件的概率的一个一般定义如下。给定一个样本空间*S*，以及事件*A*，它是*S*的一个子集，概率是一个函数*P*，它以*A*为输入，返回一个介于0和1之间的实数作为输出。函数*P*有一些限制，这些限制由以下三个公理定义。请记住，公理是被认为为真的陈述，我们用它作为推理的起点：
- en: The probability of an event is a non-negative real number
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 事件的概率是一个非负实数。
- en: '*P*(*S*) = 1'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*P*(*S*) = 1'
- en: If *A*1*,A*2*,…* are disjoint events, meaning they cannot occur simultaneously
    then *P*(*A*1*,A*2*,…*) = *P*(*A*1) + *P*(*A*2) + *…*
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果*A*1*, A*2*, …*是互斥事件，意味着它们不能同时发生，那么*P*(*A*1*, A*2*, …*) = *P*(*A*1) + *P*(*A*2)
    + *…*
- en: If this were a book on probability theory, we would likely dedicate a few pages
    to demonstrating the consequences of these axioms and provide exercises for manipulating
    probabilities. That would help us to become proficient in manipulating probabilities.
    However, our main focus is not on those topics. My motivation to present these
    axioms is just to show that probabilities are well-defined mathematical concepts
    with rules that govern their operations. They are a particular type of function,
    and there is no mystery surrounding them.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是一本关于概率论的书，我们可能会专门用几页来展示这些公理的后果，并提供一些练习来操作概率。这将帮助我们熟练地操作概率。然而，我们的主要关注点不在这些话题上。我展示这些公理的动机仅仅是为了说明概率是一个定义明确的数学概念，并且有规则来支配它们的运算。它们是特定类型的函数，并且并不神秘。
- en: 1.4.2 Random variables
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4.2 随机变量
- en: A random variable is a function that maps the sample space into the real numbers
    ℝ (see *Figure [1.1](#x1-22003r1)*). Let’s assume the events of interest are the
    number of a die, the mapping is very simple, we associate ![PIC](img/dice_1.png)
    with the number 1, ![PIC](img/dice_2.png) with 2, etc. Another simple example
    is the answer to the question, will it rain tomorrow? We can map “yes” to 1 and
    “no” to 0\. It is common, but not always the case, to use a capital letter for
    random variables like *X* and a lowercase letter for their outcomes *x*. For example,
    if *X* represents a single roll of a die, then *x* represents some specific integer
    {1*,*2*,*3*,*4*,*5*,*6}. Thus, we can write *P*(*X* = 3) to indicate the probability
    of getting the value 3, when rolling a die. We can also leave *x* unspecified,
    for instance, we can write *P*(*X* = *x*) to indicate the probability of getting
    some value *x*, or *P*(*X* ≤ *x*), to indicate the probability of getting a value
    less than or equal to *x*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 随机变量是一个将样本空间映射到实数ℝ的函数（见*图 [1.1](#x1-22003r1)*）。假设我们关注的事件是骰子的点数，映射非常简单，我们将![PIC](img/dice_1.png)与数字1关联，![PIC](img/dice_2.png)与2，依此类推。另一个简单的例子是回答问题“明天会下雨吗？”，我们可以将“是”映射为1，将“否”映射为0。通常，随机变量使用大写字母表示，如*X*，而其结果使用小写字母表示，如*x*。例如，如果*X*表示一次骰子投掷，那么*x*表示某个特定的整数{1,*2*,*3*,*4*,*5*,*6*}。因此，我们可以写*P*(*X*
    = 3)来表示投掷骰子得到3的概率。我们也可以不指定*x*，例如，我们可以写*P*(*X* = *x*)来表示得到某个值*x*的概率，或者写*P*(*X*
    ≤ *x*)，表示得到小于或等于*x*的概率。
- en: Being able to map symbols like ![PIC](img/dice_1.png) or strings like “yes”
    to numbers makes analysis simpler as we already know how to do math with numbers.
    Random variables are also useful because we can operate with them without directly
    thinking in terms of the sample space. This feature becomes more and more relevant
    as the sample space becomes more complex. For example, when simulating molecular
    systems, we need to specify the position and velocity of each atom; for complex
    molecules like proteins this means that we will need to track thousands, millions,
    or even larger numbers. Instead, we can use random variables to summarize certain
    properties of the system, such as the total energy or the relative angles between
    certain atoms of the system.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 能够将符号如![PIC](img/dice_1.png)或字符串如“yes”映射到数字上，使得分析变得更加简单，因为我们已经知道如何用数字进行数学运算。随机变量也很有用，因为我们可以在不直接考虑样本空间的情况下对它们进行操作。随着样本空间变得越来越复杂，这一特点变得愈加重要。例如，在模拟分子系统时，我们需要指定每个原子的位置信息和速度；对于像蛋白质这样复杂的分子，这意味着我们需要追踪成千上万甚至更多的数字。相反，我们可以使用随机变量来总结系统的某些属性，比如总能量或系统中某些原子之间的相对角度。
- en: If you are still confused, that’s fine. The concept of a random variable may
    sound too abstract at the beginning, but we will see plenty of examples throughout
    the book that will help you cement these ideas. Before moving on, let me try one
    analogy that I hope you find useful. Random variables are useful in a similar
    way to how Python functions are useful. We often encapsulate code within functions,
    so we can store, reuse, and *hide* complex manipulations of data into a single
    call. Even more, once we have a few functions, we can sometimes combine them in
    many ways, like adding the output of two functions or using the output of one
    function as the input of the other. We can do all this without functions, but
    abstracting away the inner workings not only makes the code cleaner, it also helps
    with understanding and fostering new ideas. Random variables play a similar role
    in statistics.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然感到困惑，那也没关系。随机变量的概念刚开始可能显得过于抽象，但我们将在全书中看到许多例子，帮助你巩固这些概念。在继续之前，我想举一个类比，希望对你有帮助。随机变量的作用类似于Python函数的作用。我们通常将代码封装在函数中，这样就可以将复杂的数据操作存储、重用，并通过一次调用来*隐藏*。更进一步，当我们拥有多个函数时，有时可以通过多种方式组合它们，比如将两个函数的输出相加，或将一个函数的输出作为另一个函数的输入。我们也可以在没有函数的情况下完成这些操作，但将内部工作抽象化不仅让代码更简洁，还帮助理解和激发新的创意。随机变量在统计学中起着类似的作用。
- en: '![PIC](img/file10.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file10.png)'
- en: '**Figure 1.1**: A random variable *X* defined on a sample space with 5 elements
    {*S*[1]*,*![⋅⋅⋅](img/file11.jpg)*S*[5]}, and possible values -1, 2, and *π*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 1.1**：在一个包含5个元素的样本空间上定义的随机变量*X*，其中元素包括{*S*[1]*，*![⋅⋅⋅](img/file11.jpg)*S*[5]}，其可能的值为-1、2
    和 *π*。'
- en: The mapping between the sample space and ℝ is deterministic. There is no randomness
    involved. So why do we call it a *random* variable? Because we can *ask* the variable
    for values, and every time we ask, we will get a different number. The randomness
    comes from the probability associated with the events. In *Figure [1.1](#x1-22003r1)*,
    we have represented *P* as the size of the circles.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 样本空间与ℝ之间的映射是确定性的。这里没有涉及随机性。那么，为什么我们称其为*随机*变量呢？因为我们可以*请求*该变量的值，每次请求时，得到的数字都会不同。随机性来源于与事件相关的概率。在*图
    [1.1](#x1-22003r1)*中，我们通过圆圈的大小表示了*P*。
- en: The two most common types of random variables are discrete and continuous ones.
    Without going into a proper definition, we are going to say that discrete variables
    take only discrete values and we usually use integers to represent them, like
    1, 5, 42\. And continuous variables take real values, so we use floats to work
    with them, like 3.1415, 1.01, 23.4214, and so on. When we use one or the other
    is problem-dependent. If we ask people about their favorite color, we will get
    answers like “red,” “blue,” and “green.” This is an example of a discrete random
    variable. The answers are categories – there are no intermediate values between
    “red” and “green.” But if we are studying the properties of light absorption,
    then discrete values like “red” and “green” may not be adequate and instead working
    with wavelength could be more appropriate. In that case, we will expect to get
    values like 650 nm and 510 nm and any number in between, including 579.1\.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 两种最常见的随机变量类型是离散型和连续型。虽然不做正式定义，但我们可以说离散型变量只取离散值，通常使用整数表示，例如 1、5、42。连续型变量则取实数值，因此我们使用浮点数来表示它们，例如
    3.1415、1.01、23.4214 等等。我们使用哪种类型取决于具体问题。如果我们询问人们最喜欢的颜色，答案可能是“红色”、“蓝色”和“绿色”。这是一个离散随机变量的例子。答案是类别间的——“红色”和“绿色”之间没有中间值。但如果我们研究光的吸收特性，那么像“红色”和“绿色”这样的离散值可能不够准确，转而使用波长可能更为合适。在这种情况下，我们会得到类似
    650 纳米和 510 纳米的值，并且任何中间值也都可能出现，包括 579.1 纳米。
- en: 1.4.3 Discrete random variables and their distributions
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4.3 离散随机变量及其分布
- en: Instead of calculating the probability that all three individuals answered “yes,”
    or the probability of getting a 3 when rolling a die, we may be more interested
    in finding out the *list of probabilities* for all possible answers or all possible
    numbers from a die. Once this list is computed, we can inspect it visually or
    use it to compute other quantities like the probability of getting at least one
    “no,” the probability of getting an odd number, or the probability of getting
    a number equal to or larger than 5\. The formal name of this *list* is **probability**
    **distribution**.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能不仅仅想计算所有三个人都回答“是”的概率，或者掷骰子得到3的概率，我们可能更感兴趣的是找到所有可能答案或骰子上所有可能数字的*概率列表*。一旦这个列表计算出来，我们可以通过可视化查看它，或者利用它来计算其他量，比如至少得到一个“否”的概率、得到奇数的概率，或者得到大于或等于5的数字的概率。这个*列表*的正式名称是**概率**
    **分布**。
- en: We can get the empirical probability distribution of a die, by rolling it a
    few times and tabulating how many times we got each number. To turn each value
    into a probability and the entire list into a valid probability distribution,
    we need to *normalize* the counts. We can do this by dividing the value we got
    for each number by the number of times we roll the die.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过掷骰子几次并记录每个数字出现的次数来获得骰子的经验概率分布。为了将每个值转化为概率，并使整个列表成为有效的概率分布，我们需要*归一化*这些计数。我们可以通过将每个数字出现的次数除以掷骰子的次数来实现这一点。
- en: Empirical distributions are very useful, and we are going to extensively use
    them. But instead of rolling dice by hand, we are going to use advanced computational
    methods to do the hard work for us; this will not only save us time and boredom
    but it will allow us to get samples from really complicated distributions effortlessly.
    But we are getting ahead of ourselves. Our priority is to concentrate on theoretical
    distributions, which are central in statistics because, among other reasons, they
    allow the construction of probabilistic models.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 经验分布非常有用，我们将广泛使用它们。但我们不会再手动掷骰子，而是将使用先进的计算方法来为我们完成这项繁重的工作；这不仅能节省我们的时间和避免无聊，还能让我们轻松地从非常复杂的分布中获取样本。不过我们现在有点急于求成。我们的优先任务是集中精力研究理论分布，因为它们在统计学中占据核心地位，原因之一是它们能够构建概率模型。
- en: 'As we saw, there is nothing random or mysterious about random variables; they
    are just a type of mathematical function. The same goes for theoretical probability
    distributions. I like to compare probability distributions with circles. Because
    we are all familiar with circles even before we get into school, we are not afraid
    of them and they don’t look mysterious to us. We can define a circle as the geometric
    space of points on a plane that is equidistant from another point called the center.
    We can go further and provide a mathematical expression for this definition. If
    we assume the location of the center is irrelevant, then the circle of radius
    *r* can simply be described as the set of all points (*x,y*) such that:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '![x2 + y2 = r2 ](img/file12.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
- en: From this expression, we can see that given the **parameter** *r*, the circle
    is completely defined. This is all we need to plot it and all we need to compute
    properties such as the perimeter, which is 2*πr*.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Now notice that all circles look very similar to each other and that any two
    circles with the same value of *r* are essentially the same objects. Thus we can
    think of the family of circles, where each member is set apart from the rest precisely
    by the value of *r*.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: So far, so good, but why are we talking about circles? Because all this can
    be directly applied to probability distributions. Both circles and probability
    distributions have mathematical expressions that define them, and these expressions
    have parameters that we can change to define all members of a family of probability
    distributions. *Figure [1.2](#x1-23006r2)* shows four members of one probability
    distribution known as BetaBinomial. In *Figure [1.2](#x1-23006r2)*, the height
    of the bars represents the probability of each *x* value. The values of *x* below
    1 or above 6 have a probability of 0 as they are out of the support of the distribution.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file13.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
- en: '**Figure 1.2**: Four members of the BetaBinomial distribution with parameters
    *α* and *β*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the mathematical expression for the BetaBinomial distribution:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '![ ( ) pmf (x ) = n- B-(x-+-𝛼,n-−-x-+-𝛽)- x B(𝛼,𝛽 ) ](img/file14.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
- en: pmf stands for **probability mass function**. For discrete random variables,
    the pmf is the function that returns probabilities. In mathematical notation,
    if we have a random variable *X*, then pmf(*x*) = *P*(*X* = *x*).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Understanding or remembering the pmf of the BetaBinomial has zero importance
    for us. I’m just showing it here so you can see that this is just another function;
    you put in one number and you get out another number. Nothing weird, at least
    not in principle. I must concede that to fully understand the details of the BetaBinomial
    distribution, we need to know what ![( ) nx](img/file15.jpg) is, known as the
    binomial coefficient, and what *B* is, the Beta function. But that’s not fundamentally
    different from showing *x*² + *y*² = *r*².
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'Mathematical expressions can be super useful, as they are concise and we can
    use them to derive properties from them. But sometimes that can be too much work,
    even if we are good at math. Visualization can be a good alternative (or complement)
    to help us understand probability distributions. I cannot fully show this on paper,
    but if you run the following, you will get an interactive plot that will update
    every time you move the sliders for the parameters `alpha`, `beta`, and `n`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '**Code 1.2**'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Figure [1.3](#x1-23013r3)* shows a static version of this interactive plot.
    The black dots represent the probabilities for each value of the random variable,
    while the dotted black line is just a visual aid.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file16.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
- en: '**Figure 1.3**: The output of `pz.BetaBinomial(alpha=10, beta=10, n=6).plot_interactive()`'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: On the x-axis, we have the support of the BetaBinomial distribution, i.e., the
    values it can take, *x* ∈{0*,*1*,*2*,*3*,*4*,*5}. On the y-axis, the probabilities
    associated with each of those values. The full list is shown in *Table [1.1](#x1-23014r1)*.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '| **x value** | **probability** |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0.047 |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0.168 |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
- en: '| 2 | 0.285 |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
- en: '| 3 | 0.285 |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
- en: '| 4 | 0.168 |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
- en: '| 5 | 0.047 |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
- en: '**Table 1.1**: Probabilities for `pz.BetaBinomial(alpha=10, beta=10, n=6)`'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Notice that for a `BetaBinomial(alpha=10, beta=10, n=6)` distribution, the probability
    of values not in {0*,*1*,*2*,*3*,*4*,*5}, including values such as −1*,*0*.*5*,π,*42,
    is 0.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'We previously mentioned that we can *ask* a random variable for values and
    every time we ask, we will get a different number. We can simulate this with PreliZ
    [[Icazatti et al.](Bibliography.xhtml#Xicazatti2023), [2023](Bibliography.xhtml#Xicazatti2023)],
    a Python library for prior elicitation. Take the following code snippet for instance:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '**Code 1.3**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will give us an integer between 0 and 5\. Which one? We don’t know! But
    let’s run the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '**Code 1.4**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We will get something similar to *Figure [1.4](#x1-23026r4)*. Even when we cannot
    predict the next value from a random variable, we can predict the probability
    of getting any particular value and by the same token, if we get many values,
    we can predict their overall distribution.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file17.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: '**Figure 1.4**: The gray dots represent the pmf of the BetaBinomial sample.
    In light gray, a histogram of 1,000 draws from that distribution'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'In this book, we will sometimes know the parameters of a given distribution
    and we will want to get random samples from it. Other times, we are going to be
    in the opposite scenario: we will have a set of samples and we will want to estimate
    the parameters of a distribution. Playing back and forth between these two scenarios
    will become second nature as we move forward through the pages.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 1.4.4 Continuous random variables and their distributions
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Probably the most widely known continuous probability distribution is the **Normal
    distribution**, also known as the **Gaussian distribution**. Its **probability
    density function** is:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '![ { } 1 1( x − μ)2 pdf(x) = -√----exp − -- ----- σ 2π 2 σ ](img/file18.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
- en: 'Again, we only show this expression to remove the mystery veil. No need to
    pay too much attention to its details, other than to the fact that this distribution
    has two parameters *μ*, which controls the location of the peak of the curve,
    and *σ*, which controls the spread of the curve. *Figure [1.5](#x1-24006r5)* shows
    3 examples from the Gaussian family. If you want to learn more about this distribution,
    I recommend you watch this video: [https://www.youtube.com/watch?v=cy8r7WSuT1I](https://www.youtube.com/watch?v=cy8r7WSuT1I).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file19.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
- en: '**Figure 1.5**: Three members of the Gaussian family'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: If you have been paying attention, you may have noticed that we said **probability
    density function** (**pdf**) instead of **probability mass** **function** (**pmf**).
    This was no typo – they are actually two different objects. Let’s take one step
    back and think about this; the output of a discrete probability distribution is
    a probability. The height of the bars in *Figure [1.2](#x1-23006r2)* or the height
    of the dots in *Figure [1.3](#x1-23013r3)* are probabilities. Each bar or dot
    will never be higher than 1 and if you sum all the bars or dots, you will always
    get 1\. Let’s do the same but with the curve in *Figure [1.5](#x1-24006r5)*. The
    first thing to notice is that we don’t have bars or dots; we have a continuous,
    smooth curve. So maybe we can think that the curve is made up of super thin bars,
    so thin that we assign one bar for every real value in the support of the distributions,
    we measure the height of each bar, and we perform an infinite sum. This is a sensible
    thing to do, right?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Well yes, but it is not immediately obvious what are we going to get from this.
    Will this sum give us exactly 1? Or are we going to get a large number instead?
    Is the sum finite? Or does the result depend on the parameters of the distribution?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'A proper answer to these questions requires measure theory, and this is a very
    informal introduction to probability, so we are not going into that rabbit hole.
    But the answer essentially is that for a continuous random variable, we can only
    assign a probability of 0 to every individual value it may take; instead, we can
    assign densities to them and then we can calculate probabilities for a range of
    values. Thus, for a Gaussian, the probability of getting exactly the number -2,
    i.e. the number -2 followed by an infinite number of zeros after the decimal point,
    is 0\. But the probability of getting a number between -2 and 0 is some number
    larger than 0 and smaller than 1\. To find out the exact answer, we need to compute
    the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '![ ∫ b P(a < X < b) = pdf(x)dx a ](img/file20.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
- en: And to compute that, we need to replace the symbols for a concrete quantity.
    If we replace the pdf by Normal(0*,*1), and *a* = −2, *b* = 0, we will get that
    *P*(−2 *< X <* 0) ≈ 0*.*477, which is the shaded area in *Figure [1.6](#x1-24010r6)*.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file21.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
- en: '**Figure 1.6**: The black line represents the pdf of a Gaussian with parameters
    mu=0 and sigma=1, the gray area is the probability of a value being larger than
    -2 and smaller than 0'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'You may remember that we can approximate an integral by summing areas of rectangles
    and the approximation becomes more and more accurate as we reduce the length of
    the base of the rectangles (see the Wikipedia entry for [Riemann integral](Bibliography.xhtml#Xwikipedia_riemann_2023)).
    Based on this idea and using PreliZ, we can estimate *P*(−2 *< X <* 0) as:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '**Code 1.5**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If we increase the value of `num`, we will get a better approximation.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 1.4.5 Cumulative distribution function
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have seen the pmf and the pdf, but these are not the only ways to characterize
    distributions. An alternative is the **cumulative distribution** **function**
    (**cdf**). The cdf of a random variable *X* is the function *F*[*X*] given by
    *F*[*X*](*x*) = *P*(*X* ≤ *x*). In words, the cdf is the answer to the question:
    what is the probability of getting a number lower than or equal to *x*? On the
    first column of *Figure [1.7](#x1-25003r7)*, we can see the pmf and cdf of a BetaBinomial,
    and in the second column, the pdf and cdf of a Gaussian. Notice how the cdf *jumps*
    for the discrete variable but it is smooth for the continuous variable. The height
    of each jump represents a probability – just compare them with the height of the
    dots. We can use the plot of the cdf of a continuous variable as visual proof
    that probabilities are zero for any value of the continuous variable. Just notice
    how there are no *jumps* for continuous variables, which is equivalent to saying
    that the height of the jumps is exactly zero.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file22.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
- en: '**Figure 1.7**: The pmf of the BetaBinomial distribution with its corresponding
    cdf and the pdf of the Normal distribution with its corresponding cdf'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Just by looking at a cdf, it is easier to find what is the probability of getting
    a number smaller than, let’s say, 1\. We just need to go to the value 1 on the
    x-axis, move up until we cross the black line, and then check the value of the
    y-axis. For instance, in *Figure [1.7](#x1-25003r7)* and for the Normal distribution,
    we can see that the value lies between 0.75 and 1\. Let’s say it is ≈ 0*.*85\.
    This is way harder to do with the pdf because we would need to compare the entire
    area below 1 to the total area to get the answer. Humans are worse at judging
    areas than judging heights or lengths.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 1.4.6 Conditional probability
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Given two events *A* and *B* with *P*(*B*) *>* 0, the probability of *A* given
    *B*, which we write as *P*(*A*|*B*) is defined as:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '![P(A | B ) = P-(A,-B-) P (B) ](img/file23.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
- en: '*P*(*A,B*) is the probability that both the event *A* and event *B* occur.
    *P*(*A*|*B*) is known as conditional probability, and it is the probability that
    event *A* occurs, **conditioned** by the fact that we know (or assume, imagine,
    hypothesize, etc.) that *B* has occurred. For example, the probability that the
    pavement is wet is different from the probability that the pavement is wet if
    we know it’s raining.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: A conditional probability can be larger than, smaller than, or equal to the
    unconditional probability. If knowing *B* does not provide us with information
    about *A*, then *P*(*A*|*B*) = *P*(*A*). This will be true only if *A* and *B*
    are independent of each other. On the contrary, if knowing *B* gives us useful
    information about *A*, then the conditional probability could be larger or smaller
    than the unconditional probability, depending on whether knowing *B* makes *A*
    less or more likely. Let’s see a simple example using a fair six-sided die. What
    is the probability of getting the number 3 if we roll the die? *P*(die = 3) =
    ![16](img/file25.jpg) since each of the six numbers has the same chance for a
    fair six-sided die. And what is the probability of getting the number 3 given
    that we have obtained an odd number? *P*(die = 3 | die = {1,3,5}) = ![1 3](img/file27.jpg),
    because if we know we have an odd number, the only possible numbers are {1*,*3*,*5}
    and each of them has the same chance. Finally, what is the probability of getting
    3 if we have obtained an even number? This is *P*(die = 3 | die = {2,4,6}) = 0,
    because if we know the number is even, then the only possible ones are {2*,*4*,*6}
    and thus getting a 3 is not possible.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: As we can see from these simple examples, by conditioning on observed data,
    we are changing the sample space. When asking about *P*(die = 3), we need to evaluate
    the sample space *S* = {1*,*2*,*3*,*4*,*5*,*6}, but when we **condition** **on**
    having got an even number, then the new sample space becomes *T* = {2*,*4*,*6}.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Conditional probabilities are at the heart of statistics, irrespective of whether
    your problem is rolling dice or building self-driving cars.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: The central panel of *Figure [1.8](#x1-26005r8)* represents *p*(*A,B*) using
    a grayscale with darker colors for higher probability densities. We see the joint
    distribution is elongated, indicating that the higher the value of *A*, the higher
    the one of *B*, and vice versa. Knowing the value of *A* tells us something about
    the values of *B* and the other way around. On the top and right *margins* of
    *Figure [1.8](#x1-26005r8)* we have the **marginal distributions** *p*(*A*) and
    *p*(*B*) respectively. To compute the marginal of *A*, we take *p*(*A,B*) and
    we average overall values of *B*, intuitively this is like taking a 2D object,
    the joint distribution, and projecting it into one dimension. The marginal distribution
    of *B* is computed similarly. The dashed lines represent the **conditional probability**
    *p*(*A*|*B*) for 3 different values of *B*. We get them by slicing the joint *p*(*A,B*)
    at a given value of *B*. We can think of this as the distribution of *A* given
    that we have observed a particular value of *B*.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file30.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
- en: '**Figure 1.8**: Representation of the relationship between the joint *p*(*A,B*),
    the marginals *p*(*A*) and *p*(*B*), and the conditional *p*(*A*|*B*) probabilities'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 1.4.7 Expected values
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If *X* is a discrete random variable, we can compute its expected value as:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '![ ∑ 𝔼 (X ) = xP (X = x) x ](img/file31.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
- en: This is just the mean or average value.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: You are probably used to computing means or averages of samples or collections
    of numbers, either by hand, on a calculator, or using Python. But notice that
    here we are not talking about the mean of a bunch of numbers; we are talking about
    the mean of a distribution. Once we have defined the parameters of a distribution,
    we can, in principle, compute its expected values. Those are properties of the
    distribution in the same way that the perimeter is a property of a circle that
    gets defined once we set the value of the radius.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Another expected value is the variance, which we can use to describe the spread
    of a distribution. The variance appears *naturally* in many computations in statistics,
    but in practice, it is often more useful to use the standard deviation, which
    is the square root of the variance. The reason is that the standard deviation
    is in the same units as the random variable.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: The mean and variance are often called the **moments** of a distribution. Other
    moments are skewness, which tells us about the asymmetry of a distribution, and
    the kurtosis, which tells us about the behavior of the tails or the *extreme values*
    [[Westfall](Bibliography.xhtml#Xwestfall2014), [2014](Bibliography.xhtml#Xwestfall2014)].
    *Figure [1.9](#x1-27006r9)* shows examples of different distributions and their
    mean *μ*, standard deviation *σ*, skew *γ*, and kurtosis ![](img/K.png). Notice
    that for some distributions, some moments may not be defined or they may be inf.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file32.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
- en: '**Figure 1.9**: Four distributions with their first four moments'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned about some of the basic concepts and jargon from probability
    theory, we can move on to the moment everyone was waiting for.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 1.4.8 Bayes’ theorem
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Without further ado, let’s contemplate, in all its majesty, Bayes’ theorem:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '![ p(Y-| θ)p(θ) p(θ | Y ) = p(Y) ](img/file33.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
- en: 'Well, it’s not that impressive, is it? It looks like an elementary school formula,
    and yet, paraphrasing Richard Feynman, this is all you need to know about Bayesian
    statistics. Learning where Bayes’ theorem comes from will help us understand its
    meaning. According to the product rule, we have:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '![p (θ,Y ) = p(θ | Y ) p(Y ) ](img/file34.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
- en: 'This can also be written as:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '![p(θ,Y) = p(Y | θ) p(θ) ](img/file35.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
- en: 'Given that the terms on the left are equal for both equations, we can combine
    them and write:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '![p(θ | Y) p(Y) = p(Y | θ) p(θ) ](img/file36.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
- en: 'On reordering, we get Bayes’ theorem:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '![ p(Y | θ)p(θ) p(θ | Y ) =---p(Y)---- ](img/file37.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
- en: Why is Bayes’ theorem that important? Let’s see.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: First, it says that *p*(*θ*|*Y* ) is not necessarily the same as *p*(*Y* |*θ*).
    This is a very important fact – one that is easy to miss in daily situations,
    even for people trained in statistics and probability. Let’s use a simple example
    to clarify why these quantities are not necessarily the same. The probability
    of a person being the Pope given that this person is Argentinian is not the same
    as the probability of being Argentinian given that this person is the Pope. As
    there are around 47,000,000 Argentinians alive and a single one of them is the
    current Pope, we have *p*(Pope | Argentinian ) ≈![470100000](img/file39.jpg) and
    we also have *p*(Argentinian | Pope ) = 1.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: If we replace *θ* with “hypothesis” and *Y* with “data,” Bayes’ theorem tells
    us how to compute the probability of a hypothesis, *θ*, given the data, *Y* ,
    and that’s the way you will find Bayes’ theorem is explained in a lot of places.
    But, how do we turn a hypothesis into something that we can put inside Bayes’
    theorem? Well, we do it by using probability distributions. So, in general, our
    hypothesis is a hypothesis in a very, very, very narrow sense; we will be more
    precise if we talk about finding a suitable value for parameters in our models,
    that is, parameters of probability distributions. By the way, don’t try to set
    *θ* to statements such as ”unicorns are real,” unless you are willing to build
    a realistic probabilistic model of unicorn existence!
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'Bayes’ theorem is central to Bayesian statistics. As we will see in *Chapter
    [2](CH02.xhtml#x1-440002)*, using tools such as PyMC frees us of the need to explicitly
    write Bayes’ theorem every time we build a Bayesian model. Nevertheless, it is
    important to know the name of its parts because we will constantly refer to them
    and it is important to understand what each part means because this will help
    us to conceptualize models. So, let me rewrite Bayes’ theorem now with labels:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '![ posterior ◜likeli◞h◟ood◝p◜r◞io◟r◝ ◜--◞◟-◝ p (Y | θ)p(θ) p(θ | Y) =--------------
    p◟(◝Y◜)◞ marginal likelihood ](img/file41.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
- en: The **prior distribution** should reflect what we know about the value of the
    parameter *θ* before seeing the data, *Y* . If we know nothing, like Jon Snow,
    we could use flat priors that do not convey too much information. In general,
    we can do better than flat priors, as we will learn in this book. The use of priors
    is why some people still talk about Bayesian statistics as subjective, even when
    priors are just another assumption that we made when modeling and hence are just
    as subjective (or objective) as any other assumption, such as likelihoods.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: The **likelihood** is how we will introduce data in our analysis. It is an expression
    of the plausibility of the data given the parameters. In some texts, you will
    find people call this term sampling model, statistical model, or just model. We
    will stick to the name likelihood and we will model the combination of priors
    and likelihood.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'The **posterior distribution** is the result of the Bayesian analysis and reflects
    all that we know about a problem (given our data and model). The posterior is
    a probability distribution for the parameters in our model and not a single value.
    This distribution is a balance between the prior and the likelihood. There is
    a well-known joke: a Bayesian is one who, vaguely expecting a horse, and catching
    a glimpse of a donkey, strongly believes they have seen a mule. One excellent
    way to kill the mood after hearing this joke is to explain that if the likelihood
    and priors are both vague, you will get a posterior reflecting vague beliefs about
    seeing a mule rather than strong ones. Anyway, I like the joke, and I like how
    it captures the idea of a posterior being somehow a compromise between prior and
    likelihood. Conceptually, we can think of the posterior as the updated prior in
    light of (new) data. In theory, the posterior from one analysis can be used as
    the prior for a new analysis (in practice, life can be harder). This makes Bayesian
    analysis particularly suitable for analyzing data that becomes available in sequential
    order. One example could be an early warning system for natural disasters that
    processes online data coming from meteorological stations and satellites. For
    more details, read about online machine-learning methods.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: The last term is the **marginal likelihood**, sometimes referred to as the **evidence**.
    Formally, the marginal likelihood is the probability of observing the data averaged
    over all the possible values the parameters can take (as prescribed by the prior).
    We can write this as ∫ [Θ]^(*p*(*Y* |*θ*)*p*(*θ*)d*θ*. We will not really care
    about the marginal likelihood until *Chapter [5](CH05.xhtml#x1-950005)*. But for
    the moment, we can think of it as a normalization factor that ensures the posterior
    is a proper pmf or pdf. If we ignore the marginal likelihood, we can write Bayes’
    theorem as a proportionality, which is also a common way to write Bayes’ theorem:)
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '![p(θ | Y ) ∝ p(Y | θ)p(θ) ](img/file42.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
- en: Understanding the exact role of each term in Bayes’ theorem will take some time
    and practice, and it will require a few examples, but that’s what the rest of
    this book is for.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 1.5 Interpreting probabilities
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Probabilities can be interpreted in various useful ways. For instance, we can
    think that *P*(*A*) = 0*.*125 means that if we repeat the survey many times, we
    would expect all three individuals to answer “yes” about 12.5% of the time. We
    are interpreting probabilities as the outcome of long-run experiments. This is
    a very common and useful interpretation. It not only can help us think about probabilities
    but can also provide an empirical method to estimate probabilities. Do we want
    to know the probability of a car tire exploding if filled with air beyond the
    manufacturer’s recommendation? Just inflate 120 tires or so, and you may get a
    good approximation. This is usually called the frequentist interpretation.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Another interpretation of probability, usually called subjective or Bayesian
    interpretation, states that probabilities can be interpreted as measures of an
    individual’s uncertainty about events. In this interpretation, probabilities are
    about our state of knowledge of the world and are not necessarily based on repeated
    trials. Under this definition of probability, it is valid and natural to ask about
    the probability of life on Mars, the probability of the mass of an electron being
    9*.*1 × 10^(−31) kg, or the probability that the 9^(th) of July of 1816 was a
    sunny day in Buenos Aires. All these are one-time events. We cannot re-create
    1 million universes, each with one Mars, and check how many of them develop life.
    Of course, we can do this as a mental experiment, so long-term frequencies can
    still be a valid mental scaffold.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes the Bayesian interpretation of probabilities is described in terms
    of personal beliefs; I don’t like that. I think it can lead to unnecessary confusion
    as beliefs are generally associated with the notion of faith or unsupported claims.
    This association can easily lead people to think that Bayesian probabilities,
    and by extension Bayesian statistics, is less objective or less scientific than
    alternatives. I think it also helps to generate confusion about the role of prior
    knowledge in statistics and makes people think that being objective or rational
    means not using prior information.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'Bayesian methods are as subjective (or objective) as any other well-established
    scientific method we have. Let me explain myself with an example: life on Mars
    exists or does not exist; the outcome is binary, a yes-no question. But given
    that we are not sure about that fact, a sensible course of action is trying to
    find out how likely life on Mars is. To answer this question any honest and scientific-minded
    person will use all the relevant geophysical data about Mars, all the relevant
    biochemical knowledge about necessary conditions for life, and so on. The response
    will be necessarily about our epistemic state of knowledge, and others could disagree
    and even get different probabilities. But at least, in principle, they all will
    be able to provide arguments in favor of their data, their methods, their modeling
    decisions, and so on. A scientific and rational debate about life on Mars does
    not admit *arguments* such as ”an angel told me about tiny green creatures.” Bayesian
    statistics, however, is just a procedure to make scientific statements using probabilities
    as building blocks.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 1.6 Probabilities, uncertainty, and logic
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Probabilities can help us to quantify uncertainty. If we do not have information
    about a problem, it is reasonable to state that every possible event is equally
    likely. This is equivalent to assigning the same probability to every possible
    event. In the absence of information, our uncertainty is maximum, and I am not
    saying this colloquially; this is something we can compute using probabilities.
    If we know instead that some events are more likely, then this can be formally
    represented by assigning a higher probability to those events and less to the
    others. Notice that when we talk about events in stats-speak, we are not restricting
    ourselves to things that can happen, such as an asteroid crashing into Earth or
    my auntie’s 60^(th) birthday party. An event is just any of the possible values
    (or a subset of values) a variable can take, such as the event that you are older
    than 30, the price of a Sachertorte, or the number of bikes that will be sold
    next year around the world.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'The concept of probability is also related to the subject of logic. Under classical
    logic, we can only have statements that take the values of true or false. Under
    the Bayesian definition of probability, certainty is just a special case: a true
    statement has a probability of 1, and a false statement has a probability of 0\.
    We would assign a probability of 1 to the statement that there is Martian life
    only after having conclusive data indicating something is growing, reproducing,
    and doing other activities we associate with living organisms.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Notice, however, that assigning a probability of 0 is harder because we could
    always think that there is some Martian spot that is unexplored, or that we have
    made mistakes with some experiments, or there are several other reasons that could
    lead us to falsely believe life is absent on Mars even if it is not. This is related
    to Cromwell’s rule, which states that we should reserve the probabilities of 0
    or 1 to logically true or false statements. Interestingly enough, it can be shown
    that if we want to extend the logic to include uncertainty, we must use probabilities
    and probability theory.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: As we will soon see, Bayes’ theorem is just a logical consequence of the rules
    of probability. Thus, we can think of Bayesian statistics as an extension of logic
    that is useful whenever we are dealing with uncertainty. Thus, one way to justify
    using the Bayesian method is to recognize that uncertainty is commonplace. We
    generally have to deal with incomplete and or noisy data, we are intrinsically
    limited by our evolution-sculpted primate brain, and so on.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: The Bayesian Ethos
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Probabilities are used to measure the uncertainty we have about parameters,
    and Bayes’ theorem is a mechanism to correctly update those probabilities in light
    of new data, hopefully reducing our uncertainty.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 1.7 Single-parameter inference
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know what Bayesian statistics is, let’s learn how to do Bayesian
    statistics with a simple example. We are going to begin inferring a single, unknown
    parameter.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 1.7.1 The coin-flipping problem
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The coin-flipping problem, or the BetaBinomial model if you want to sound fancy
    at parties, is a classical problem in statistics and goes like this: we toss a
    coin several times and record how many heads and tails we get. Based on this data,
    we try to answer questions such as, is the coin fair? Or, more generally, how
    biased is the coin? While this problem may sound dull, we should not underestimate
    it.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: The coin-flipping problem is a great example to learn the basics of Bayesian
    statistics because it is a simple model that we can solve and compute with ease.
    Besides, many real problems consist of binary, mutually exclusive outcomes such
    as 0 or 1, positive or negative, odds or evens, spam or ham, hotdog or not a hotdog,
    cat or dog, safe or unsafe, and healthy or unhealthy. Thus, even when we are talking
    about coins, this model applies to any of those problems. To estimate the bias
    of a coin, and in general, to answer any questions in a Bayesian setting, we will
    need data and a probabilistic model. For this example, we will assume that we
    have already tossed a coin several times and we have a record of the number of
    observed heads, so the data-gathering part is already done. Getting the model
    will take a little bit more effort. Since this is our first model, we will explicitly
    write Bayes’ theorem and do all the necessary math (don’t be afraid, I promise
    it will be painless) and we will proceed very slowly. From [2](CH02.xhtml#x1-440002)
    onward, we will use PyMC and our computer to do the math for us.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we will do is generalize the concept of bias. We will say that
    a coin with a bias of 1 will always land heads, one with a bias of 0 will always
    land tails, and one with a bias of 0.5 will land heads half of the time and tails
    half of the time. To represent the bias, we will use the parameter *θ*, and to
    represent the total number of heads for several tosses, we will use the variable
    *Y* . According to Bayes’ theorem, we have to specify the prior, *p*(*θ*), and
    likelihood, *p*(*Y* |*θ*), we will use. Let’s start with the likelihood.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 1.7.2 Choosing the likelihood
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s assume that only two outcomes are possible—heads or tails—and let’s also
    assume that a coin toss does not affect other tosses, that is, we are assuming
    coin tosses are independent of each other. We will further assume all coin tosses
    come from the same distribution. Thus the random variable coin toss is an example
    of an **independent and identically distributed** (**iid**) variable. I hope you
    agree that these are very reasonable assumptions to make for our problem. Given
    these assumptions, a good candidate for the likelihood is the Binomial distribution:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '![ ----N-!--- y N− y p(Y | θ) = y!(N − y)! θ (1 − θ) ◟---◝◜---◞ normalizing
    constant ](img/file43.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
- en: This is a discrete distribution returning the probability of getting *y* heads
    (or, in general, successes) out of *N* coin tosses (or, in general, trials or
    experiments) given a fixed value of *θ*.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure [1.10](#x1-33003r10)* shows nine distributions from the Binomial family;
    each subplot has its legend indicating the values of the parameters. Notice that
    for this plot, I did not omit the values on the y-axis. I did this so you can
    check for yourself that if you sum the height of all bars, you will get 1, that
    is, for discrete distributions, the height of the bars represents actual probabilities.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file44.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
- en: '**Figure 1.10**: Nine members of the Binomial family'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: The Binomial distribution is a reasonable choice for the likelihood. We can
    see that *θ* indicates how likely it is to obtain a head when tossing a coin.
    This is easier to see when *N* = 1 but is valid for any value of *N*, just compare
    the value of *θ* with the height of the bar for *y* = 1 (heads).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 1.7.3 Choosing the prior
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As a prior, we will use a Beta distribution, which is a very common distribution
    in Bayesian statistics and looks as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '![p(θ) = --Γ (𝛼-+-𝛽)- θ𝛼−1(1− θ)𝛽−1 Γ◟-(𝛼-)+◝◜Γ (𝛽)◞ normalizing constant ](img/file45.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
- en: If we look carefully, we will see that the Beta distribution looks similar to
    the Binomial except for the first term. Γ is the Greek uppercase gamma letter,
    which represents the gamma function, but that’s not really important. What is
    relevant for us is that the first term is a normalizing constant that ensures
    the distribution integrates to 1\. We can see from the preceding formula that
    the Beta distribution has two parameters, *α* and *β*. *Figure [1.11](#x1-34002r11)*
    shows nine members of the Beta family.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file46.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
- en: '**Figure 1.11**: Nine members of the Beta family'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: I like the Beta distribution and all the shapes we can get from it, but why
    are we using it for our model? There are many reasons to use a Beta distribution
    for this and other problems. One of them is that the Beta distribution is restricted
    to be between 0 and 1, in the same way our *θ* parameter is. In general, we use
    the Beta distribution when we want to model the proportions of a Binomial variable.
    Another reason is its versatility. As we can see in *Figure [1.11](#x1-34002r11)*,
    the distribution adopts several shapes (all restricted to the [0*,*1] interval),
    including a Uniform distribution, Gaussian-like distributions, and U-like distributions.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: As a third reason, the Beta distribution is the conjugate prior to the Binomial
    distribution (which we are using as the likelihood). A conjugate prior of a likelihood
    is a prior that, when used in combination with a given likelihood, returns a posterior
    with the same functional form as the prior. Untwisting the tongue, every time
    we use a Beta distribution as the prior and a Binomial distribution as the likelihood,
    we will get a Beta as the posterior distribution. There are other pairs of conjugate
    priors; for example, the Normal distribution is the conjugate prior to itself.
    For many years, Bayesian analysis was restricted to the use of conjugate priors.
    Conjugacy ensures mathematical tractability of the posterior, which is important
    given that a common problem in Bayesian statistics ends up with a posterior we
    cannot solve analytically. This was a deal breaker before the development of suitable
    computational methods to solve probabilistic methods. From *Chapter [2](CH02.xhtml#x1-440002)*
    onwards, we will learn how to use modern computational methods to solve Bayesian
    problems, whether we choose conjugate priors or not.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 1.7.4 Getting the posterior
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s remember that Bayes’ theorem says the posterior is proportional to the
    likelihood times the prior. So, for our problem, we have to multiply the Binomial
    and the Beta distributions:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '![ likelihood prior ◜---------◞◟---------◝ ◜----------◞◟-----------◝ p(θ |
    Y ) =---N-!---θy(1− θ)N −y -Γ-(𝛼+-𝛽-)-θ𝛼− 1(1 − θ)𝛽−1 y!(N − y )! Γ (𝛼) + Γ (𝛽)
    ](img/file47.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
- en: 'We can simplify this expression by dropping all the terms that do not depend
    on *θ* and our results will still be valid. Accordingly, we can write:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '![ -likelihood--- -----prior---- ◜y ◞◟ N −◝y ◜𝛼−1 ◞◟ 𝛽−◝1 p(θ | Y) ∝ θ) ](img/file48.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
- en: 'Reordering it, and noticing this has the form of a Beta distribution, we get:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '![p(θ | Y ) = Beta (𝛼prior + y,𝛽prior+N −y) ](img/file49.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
- en: Based on this analytical expression, we can compute the posterior. *Figure [1.12](#x1-35014r12)*
    shows the results for 3 priors and different numbers of trials. The following
    block of code shows the gist to generate *Figure [1.12](#x1-35014r12)* (omitting
    the code necessary for plotting).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '**Code 1.6**'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![PIC](img/file50.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
- en: '**Figure 1.12**: The first subplot shows 3 priors. The rest show successive
    updates as we get new data'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'On the first subplot of *Figure [1.12](#x1-35014r12)*, we have zero trials,
    thus the three curves represent our priors:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'The Uniform prior (black): This represents all the possible values for the
    bias being equally probable a priori.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Gaussian-like prior (dark gray): This is centered and concentrated around
    0.5, so this prior is compatible with information indicating that the coin has
    more or less about the same chance of landing heads or tails. We could also say
    this prior is compatible with the knowledge that coins are fair.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The skewed prior (light gray): This puts most of the weight on a tail-biased
    outcome.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The rest of the subplots show posterior distributions for successive trials.
    The number of trials (or coin tosses) and the number of heads are indicated in
    each subplot’s legend. There is also a black dot at 0.35 representing the true
    value for *θ*. Of course, in real problems, we do not know this value, and it
    is here just for pedagogical reasons. *Figure [1.12](#x1-35014r12)*, can teach
    us a lot about Bayesian analysis, so grab your coffee, tea, or favorite drink,
    and let’s take a moment to understand it:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: The result of a Bayesian analysis is a posterior distribution – not a single
    value but a distribution of plausible values given the data and our model.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most probable value is given by the mode of the posterior (the peak of the
    distribution).
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The spread of the posterior is proportional to the uncertainty about the value
    of a parameter; the more spread out the distribution, the less certain we are.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intuitively, we are more confident in a result when we have observed more data
    supporting that result. Thus, even when numerically ![1 2](img/file51.jpg) = ![48](img/file52.jpg)
    = 0*.*5, seeing four heads out of eight trials gives us more confidence that the
    bias is 0.5 than observing one head out of two trials. This intuition is reflected
    in the posterior, as you can check for yourself if you pay attention to the (black)
    posterior in the third and sixth subplots; while the mode is the same, the spread
    (uncertainty) is larger in the third subplot than in the sixth subplot.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given a sufficiently large amount of data, two or more Bayesian models with
    different priors will tend to converge to the same result. In the limit of infinite
    data, no matter which prior we use, all of them will provide the same posterior.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that infinite is a limit and not a number, so from a practical point
    of view, we could get practically equivalent posteriors for a finite and relatively
    small number of data points.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How fast posteriors converge to the same distribution depends on the data and
    the model. We can see that the posteriors arising from the black prior (Uniform)
    and gray prior (biased towards tails) converge faster to almost the same distribution,
    while it takes longer for the dark gray posterior (the one arising from the concentrated
    prior). Even after 150 trials, it is somehow easy to recognize the dark gray posterior
    as a different distribution from the two others.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Something not obvious from the figure is that we will get the same result if
    we update the posterior sequentially as if we do it all at once. We can compute
    the posterior 150 times, each time adding one more observation and using the obtained
    posterior as the new prior, or we can just compute one posterior for the 150 tosses
    at once. The result will be exactly the same. This feature not only makes perfect
    sense, but it also leads to a natural way of updating our estimations when we
    get new data, a situation common in many data-analysis problems.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1.7.5 The influence of the prior
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: From the preceding example, it is clear that priors can influence inferences.
    That’s fine – priors are supposed to do that. Maybe it would be better to not
    have priors at all. That would make modeling easier, right? Well, not necessarily.
    If you are not setting the prior, someone else will be doing it for you. Sometimes
    this is fine – *default priors* can be useful and have their place – but sometimes
    it is better to have more control. Let me explain.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'We can think that every (statistical) model, Bayesian or not, has some kind
    of prior, even if the prior is not set explicitly. For instance, many procedures
    typically used in frequentist statistics can be seen as special cases of a Bayesian
    model under certain conditions, such as flat priors. One common way to estimate
    parameters is known as maximum likelihood; this method avoids setting a prior
    and works just by finding the single value maximizing the likelihood. This value
    is usually notated by adding a little hat on top of the name of the parameter
    we are estimating, such as ![](img/hat_theta.png). Contrary to the posterior estimate,
    which is a distribution, ![](img/hat_theta.png) is a point estimate, a number.
    For the coin-flipping problem, we can compute it analytically:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '![ y ˆθ = -- N ](img/file53.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
- en: If you go back to *Figure [1.12](#x1-35014r12)*, you will be able to check for
    yourself that the mode of the black posterior (the one corresponding to the uniform/flat
    prior) agrees with the values of ![](img/hat_theta.png), computed for each subplot.
    This is not a coincidence; it is a consequence of the fact that setting a Uniform
    prior and then taking the mode of the posterior is equivalent to maximum likelihood.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: We cannot avoid priors, but if we include them in our analysis, we can get some
    potential benefits. The most direct benefit is that we get a posterior distribution,
    which is a distribution of plausible values and not only the most probable ones.
    Having a distribution can be more informative than a single-point estimate, as
    we saw the width of the distribution is related to the uncertainty we have for
    the estimate. Another benefit is that computing the posteriors means to average
    over the prior. This can lead to models that are more difficult to overfit and
    more robust predictions [[Wilson and Izmailov](Bibliography.xhtml#Xwilson_2022), [2022](Bibliography.xhtml#Xwilson_2022)].
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Priors can bring us other benefits. Starting in the next chapter, we are going
    to use numerical methods to get posteriors. These methods feel like magic, until
    they don’t. The folk theorem of statistical computing states, ”When you have computational
    problems, often there’s a problem with your model” [[Gelman](Bibliography.xhtml#Xgelman_folk_2008), [2008](Bibliography.xhtml#Xgelman_folk_2008)].
    Sometimes a wise choice of prior can make inference easier or faster. It is important
    to remark that we are not advocating for setting priors specifically to make inference
    faster, but it is often the case that by thinking about priors, we can get faster
    models.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: One advantage of priors, one that is sometimes overlooked, is that having to
    think about priors can *force us* to think a little bit deeper about the problem
    we are trying to solve and the data we have. Sometimes the modeling process leads
    to a better understanding by itself irrespective of how well we end and fit the
    data or make predictions. By being explicit about priors, we get more transparent
    models, meaning they’re easier to criticize, debug (in a broad sense of the word),
    explain to others, and hopefully improve.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 1.8 How to choose priors
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Newcomers to Bayesian analysis (as well as detractors of this paradigm) are
    generally a little nervous about how to choose priors. Usually, they are afraid
    that the prior distribution will not let the data speak for itself! That’s OK,
    but we have to remember that data does not speak; at best, data murmurs. We can
    only make sense of data in the context of our models, including mathematical and
    mental models. There are plenty of examples in the history of science where the
    same data led people to think differently about the same topics, and this can
    happen even if you base your opinions on formal models.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Some people like the idea of using non-informative priors (also known as flat,
    vague, or diffuse priors). These priors have the least possible amount of impact
    on the analysis. While it is possible to use them for some problems deriving truly
    non-informative priors can be hard or just impossible. Additionally, we generally
    can do better as we usually have some prior information.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this book, we will follow the recommendations of Gelman, McElreath,
    Kruschke, and many others, and we will prefer weakly informative priors. For many
    problems, we often know something about the values a parameter can take. We may
    know that a parameter is restricted to being positive, or we may know the approximate
    range it can take, or whether we expect the value to be close to zero or below/above
    some value. In such cases, we can use priors to put some weak information in our
    models without being afraid of being too pushy. Because these priors work to keep
    the posterior distribution within certain reasonable bounds, they are also known
    as regularizing priors.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Informative priors are very strong priors that convey a lot of information.
    Using them is also a valid option. Depending on your problem, it could be easy
    or not to find good-quality information from your domain knowledge and turn it
    into priors. I used to work on structural bioinformatics. In this field, people
    have been using, in Bayesian and non-Bayesian ways, all the prior information
    they could get to study and predict the structure of proteins. This is reasonable
    because we have been collecting data from thousands of carefully designed experiments
    for decades and hence we have a great amount of trustworthy prior information
    at our disposal. Not using it would be absurd! There is nothing “objective” or
    “scientific” about throwing away valuable information. If you have reliable prior
    information, you should use it. Imagine if every time an automotive engineer had
    to design a new car, they had to start from scratch and reinvent the combustion
    engine, the wheel, and for that matter, the whole concept of a car.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'PreliZ is a very new Python library for prior elicitation [[Mikkola et al.](Bibliography.xhtml#Xmikkola_2021), [2023](Bibliography.xhtml#Xmikkola_2021), [Icazatti
    et al.](Bibliography.xhtml#Xicazatti2023), [2023](Bibliography.xhtml#Xicazatti2023)].
    Its mission is to help you to elicit, represent, and visualize your prior knowledge.
    For instance, we can ask PreliZ to compute the parameters of a distribution satisfying
    a set of constraints. Let’s say we want to find the Beta distribution with 90%
    of the mass between 0.1 and 0.7, then we can write:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '**Code 1.7**'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The result is a Beta distribution with parameters *α* = 2*.*5 and *β* = 3*.*6
    (rounded to the first decimal point). The `pz.maxent` function computes the **maximum**
    **entropy** distribution given the constraints we specified. Why maximum entropy
    distribution? Because that is equivalent to computing the least informative distribution
    under those constraints. By default, PreliZ will plot the distribution as shown
    here:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file54.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
- en: '**Figure 1.13**: Maximum entropy Beta distribution with 90% of the mass between
    0.1 and 0.7'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: As eliciting prior has many facets, PreliZ offers many other ways to elicit
    priors. If you are interested in learning more about PreliZ, you can check the
    documentation at [https://preliz.readthedocs.io](https://preliz.readthedocs.io).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Building models is an iterative process; sometimes the iteration takes a few
    minutes, and sometimes it could take years. Reproducibility matters and transparent
    assumptions in a model contribute to it. We are free to use more than one prior
    (or likelihood) for a given analysis if we are not sure about any special one;
    exploring the effect of different priors can also bring valuable information to
    the table. Part of the modeling process is about questioning assumptions, and
    priors (and likelihoods) are just that. Different assumptions will lead to different
    models and probably different results. By using data and our domain knowledge
    of the problem, we will be able to compare models and, if necessary, decide on
    a winner. *Chapter [5](CH05.xhtml#x1-950005)* will be devoted to this issue. Since
    priors have a central role in Bayesian statistics, we will keep discussing them
    as we face new problems. So if you have doubts and feel a little bit confused
    about this discussion, just keep calm and don’t worry, people have been confused
    for decades and the discussion is still going on.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 1.9 Communicating a Bayesian analysis
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating reports and communicating results is central to the practice of statistics
    and data science. In this section, we will briefly discuss some of the peculiarities
    of this task when working with Bayesian models. In future chapters, we will keep
    looking at examples of this important matter.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 1.9.1 Model notation and visualization
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to communicate the results of an analysis, you should also communicate
    the model you used. A common notation to succinctly represent probabilistic models
    is:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '|  | *θ* ∼ Beta(**α*,*β**) |  |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
- en: '|  | *y* ∼ Bin(*n* = 1*,p* = *θ*) |  |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
- en: This is just the model we use for the coin-flip example. As you may remember,
    the ∼ symbol indicates that the variable on the left of it is a random variable
    distributed according to the distribution on the right. In many contexts, this
    symbol is used to indicate that a variable takes *approximately* some value, but
    when talking about probabilistic models, we will read this symbol out loud, saying
    *is distributed as*. Thus, we can say *θ* is distributed as a Beta with parameters
    *α* and *β*, and *y* is distributed as a Binomial with parameters *n* = 1 and
    *p* = *θ*. The very same model can be represented graphically using Kruschke diagrams
    as in *Figure [1.14](#x1-39001r14)*.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file55.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
- en: '**Figure 1.14**: A Kruschke diagram of a BetaBinomial model'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: On the first level, we have the prior that generates the values for *θ*, then
    the likelihood, and on the last line, the data, *y*. Arrows indicate the relationship
    between variables and the symbol ∼ indicates the stochastic nature of the variables.
    All Kruschke diagrams in the book were made using the templates provided by Rasmus
    Bååth ( [http://www.sumsar.net/blog/2013/10/diy-kruschke-style-diagrams/](http://www.sumsar.net/blog/2013/10/diy-kruschke-style-diagrams/)).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 1.9.2 Summarizing the posterior
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The result of a Bayesian analysis is a posterior distribution, and all the information
    about the parameters (given a model and dataset) is contained in the posterior
    distribution. Thus, by summarizing the posterior, we are summarizing the logical
    consequences of a model and data. A common practice is to report, for each parameter,
    the mean (or mode or median) to have an idea of the location of the distribution
    and some measure of dispersion, such as the standard deviation, to have an idea
    of uncertainty in our estimates. The standard deviation works well for Normal-like
    distributions but can be misleading for other types of distributions, such as
    skewed ones.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: A commonly used device to summarize the spread of a posterior distribution is
    to use a **Highest-Density Interval** (**HDI**). An HDI is the shortest interval
    containing a given portion of the probability density. If we say that the 95%
    HDI for some analysis is [2*,*5], we mean that according to our data and model,
    the parameter in question is between 2 and 5 with a probability of 0.95\. There
    is nothing special about choosing 95%, 50%, or any other value. We are free to
    choose the 82% HDI interval if we like. Ideally, justifications should be context-dependent
    and not automatic, but it is okay to settle on some common value like 95%. As
    a friendly reminder of the arbitrary nature of this choice, the ArviZ default
    is 94%.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'ArviZ is a Python package for exploratory analysis of Bayesian models, and
    it has many functions to help us summarize the posterior. One of those functions
    is `az.plot_posterior`, which we can use to generate a plot with the mean and
    HDI of *θ*. The distribution does not need to be a posterior distribution; any
    distribution will work. *Figure [1.15](#x1-40007r15)* shows the result for a random
    sample from a Beta distribution:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '**Code 1.8**'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![PIC](img/file56.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
- en: '**Figure 1.15**: A KDE of a sample from a Beta distribution with its mean and
    94% HDI'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Not Confidence Intervals
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: If you are familiar with the frequentist paradigm, please note that HDIs are
    not the same as confidence intervals. In the frequentist framework, parameters
    are fixed by design; a frequentist confidence interval either contains or does
    not contain the true value of a parameter. In the Bayesian framework, parameters
    are random variables, and thus we can talk about the probability of a parameter
    having specific values or being inside some interval. The unintuitive nature of
    confident intervals makes them easily misinterpreted and people often talk about
    frequentist confidence intervals as if they were Bayesian credible intervals.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 1.10 Summary
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We began our Bayesian journey with a very brief discussion of statistical modeling,
    probabilities, conditional probabilities, random variables, probability distributions
    and Bayes’ theorem. We then used the coin-flipping problem as an excuse to introduce
    basic aspects of Bayesian modeling and data analysis. We used this classic toy
    example to convey some of the most important ideas of Bayesian statistics, such
    as using probability distributions to build models and represent uncertainties.
    We tried to demystify the use of priors and put them on an equal footing with
    other elements that are part of the modeling process, such as the likelihood,
    or even more meta-questions, such as why we are trying to solve a particular problem
    in the first place.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'We ended the chapter by discussing the interpretation and communication of
    the results of a Bayesian analysis. We assume there is a true distribution that
    in general is unknown (and in principle also unknowable), from which we get a
    finite sample, either by doing an experiment, a survey, an observation, or a simulation.
    To learn something from the true distribution, given that we have only observed
    a sample, we build a probabilistic model. A probabilistic model has two basic
    ingredients: a prior and a likelihood. Using the model and the sample, we perform
    Bayesian inference and obtain a posterior distribution; this distribution encapsulates
    all the information about a problem, given our model and data. From a Bayesian
    perspective, the posterior distribution is the main object of interest and everything
    else is derived from it, including predictions in the form of a posterior predictive
    distribution. As the posterior distribution (and any other derived quantity from
    it) is a consequence of the model and data, the usefulness of Bayesian inferences
    is restricted by the quality of models and data. Finally, we briefly summarized
    the main aspects of doing Bayesian data analysis. Throughout the rest of this
    book, we will revisit these ideas to absorb them and use them as the scaffold
    of more advanced concepts.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will introduce PyMC, which is a Python library for Bayesian
    modeling and probabilistic machine learning and will use more features from ArviZ,
    a Python library for the exploratory analysis of Bayesian models, and PreliZ a
    Python library for prior elicitation.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 1.11 Exercises
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We do not know whether the brain works in a Bayesian way, in an approximately
    Bayesian fashion, or maybe some evolutionary (more or less) optimized heuristics.
    Nevertheless, we know that we learn by exposing ourselves to data, examples, and
    exercises… Well you may say that humans never learn, given our record as a species
    on subjects such as wars or economic systems that prioritize profit and not people’s
    well-being... Anyway, I recommend you do the proposed exercises at the end of
    each chapter:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you have a jar with 4 jelly beans: 2 are strawberry-flavored, 1 is
    blueberry-flavored, and 1 is cinnamon-flavored. You draw one jelly bean at random
    from the jar.'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the sample space for this experiment?
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We define event *A* as *the jelly bean drawn is strawberry-flavored* and event
    *B* as *The jelly bean drawn is not cinnamon-flavored*. What are the probabilities
    of events *A* and *B*?
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Are events *A* and *B* mutually exclusive? Why or why not?
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Previously, we defined a Python function `P` to compute the probability of
    an event using the naive definition of probability. Generalize that function to
    compute the probability of events when they are not all equally likely. Use this
    new function to compute the probability of events *A* and *B* from the previous
    exercise. Hint: you can pass a third argument with the probability of each event.'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use PreliZ to explore different parameters for the BetaBinomial and Gaussian
    distributions. Use the methods `plot_pdf`, `plot_cdf`, and `plot_interactive`.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We discussed the probability mass/density functions and the cumulative density
    function. But there are other ways to represent functions like the percentile
    point function ppf. Using the `plot_ppf` method of PreliZ, plot the percentile
    point function for the BetaBinomial and Gaussian distributions. Can you explain
    how the ppf is related to the cdf and pmf/pdf?
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the following expressions, which one corresponds to: the probability of
    being sunny given that it is 9^(th) of July of 1816?'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*p*(sunny)'
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '*p*(sunny|July)'
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '*p*(sunny|9 of July of 1816)'
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '*p*(9^(th) of July of 1816|sunny)'
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![p(sunny,9th of July-of 1816) p(9th of July of 1816)](img/file57.jpg)'
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_IMG
- en: We showed that the probability of choosing a human at random and picking the
    Pope is not the same as the probability of the Pope being human. In the animated
    series Futurama, the (Space) Pope is a reptile. How does this change your previous
    calculations?
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Following the example in *Figure [1.9](#x1-27006r9)*, use PreliZ to compute
    the moments for the SkewNormal distribution for a different combination of parameters.
    Generate random samples of different sizes, like 10, 100, and 1,000, and see if
    you can recover the values of the first two moments (mean and variance) from the
    samples. What do you observe?
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat the previous exercise for the Student’s T distribution. Try values of
    *ν* like 2, 3, 500\. What do you observe?
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the following definition of a probabilistic model, identify the prior and
    the likelihood:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Y ∼ Normal (μ,σ) μ ∼ Normal (0,2) σ ∼ HalfNormal (0.75 ) ](img/file58.jpg)'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: In the previous model, how many parameters will the posterior have? Compare
    it with the model for the coin-flipping problem.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write Bayes’ theorem for the model in exercise 9.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s suppose that we have two coins; when we toss the first coin, half of the
    time it lands on tails and half of the time on heads. The other coin is a loaded
    coin that always lands on heads. If we take one of the coins at random and get
    a head, what is the probability that this coin is the unfair one?
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try re-plotting *Figure [1.12](#x1-35014r12)* using other priors (`beta_params`)
    and other data (`trials` and `data`).
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Read about the Cromwell rule on Wikipedia: [https://en.wikipedia.org/wiki/Cromwell%27s_rule](https://en.wikipedia.org/wiki/Cromwell%27s_rule).'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Read about probabilities and the Dutch book on Wikipedia: [https://en.wikipedia.org/wiki/Dutch_book](https://en.wikipedia.org/wiki/Dutch_book).'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Join our community Discord space
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Join our Discord community to meet like-minded people and learn alongside more
    than 5000 members at: [https://packt.link/bayesian](https://packt.link/bayesian)'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file1.png)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
