<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Managing and Understanding Data"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Managing and Understanding Data</h1></div></div></div><p>A key early component of any machine learning project involves managing and understanding data. Although this may not be as gratifying as building and deploying models—the stages in which you begin to see the fruits of your labor—it is unwise to ignore this important preparatory work.</p><p>Any learning algorithm is only as good as its input data, and in many cases, the input data is complex, messy, and spread across multiple sources and formats. Because of this complexity, often the largest portion of effort invested in machine learning projects is spent on data preparation and exploration.</p><p>This chapter approaches these topics in three ways. The first section discusses the basic data structures R uses to store data. You will become very familiar with these structures as you create and manipulate datasets. The second section is practical, as it covers several functions that are useful to get data in and out of R. In the third section, methods for understanding data are illustrated while exploring a real-world dataset.</p><p>By the end of this chapter, you will understand:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How to use R's basic data structures to store and extract data</li><li class="listitem" style="list-style-type: disc">Simple functions to get data into R from common source formats</li><li class="listitem" style="list-style-type: disc">Typical methods to understand and visualize complex data</li></ul></div><p>Since the way R thinks about data will define the way you work with data, it is helpful to know R's data structures before jumping directly into data preparation. However, if you are already familiar with R programming, feel free to skip ahead to the section on data preprocessing.</p><div class="section" title="R data structures"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec14"/>R data structures</h1></div></div></div><p>There are <a id="id100" class="indexterm"/>numerous types of data structures across programming languages, each with strengths and weaknesses suited to particular tasks. Since R is a programming language used widely for statistical data analysis, the data structures it utilizes were designed with this type of work in mind.</p><p>The R data <a id="id101" class="indexterm"/>structures used most frequently in machine learning are vectors, factors, lists, arrays and matrices, and data frames. Each is tailored to a specific data management task, which makes it important to understand how they will interact in your R project. In the sections that follow, we will review their similarities and differences.</p><div class="section" title="Vectors"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec20"/>Vectors</h2></div></div></div><p>The <a id="id102" class="indexterm"/>fundamental R data structure is the <span class="strong"><strong>vector</strong></span>, which stores an ordered <a id="id103" class="indexterm"/>set of values called <span class="strong"><strong>elements</strong></span>. A vector can contain any number of <a id="id104" class="indexterm"/>elements, but all of the elements must be of the same <span class="strong"><strong>type</strong></span> of values. For instance, a vector cannot contain both numbers and text. To determine the type of vector <code class="literal">v</code>, use the <code class="literal">typeof(v)</code> command.</p><p>Several vector types are <a id="id105" class="indexterm"/>commonly used in machine learning: <code class="literal">integer</code> (numbers without decimals), <code class="literal">double</code> (numbers with decimals), <code class="literal">character</code> (text data), and <code class="literal">logical</code> (<code class="literal">TRUE</code> or <code class="literal">FALSE</code> values). There are also two special values: <code class="literal">NULL</code>, which is used to indicate the absence of any value, and <code class="literal">NA</code>, which indicates a missing value.</p><div class="tip" title="Tip" style=""><div class="inner"><h3 class="title"><a id="tip17"/>Tip</h3><p>Some R functions will report both <code class="literal">integer</code> and <code class="literal">double</code> vectors as <code class="literal">numeric</code>, while others will distinguish between the two. As a result, although all <code class="literal">double</code> vectors are <code class="literal">numeric</code>, not all <code class="literal">numeric</code> vectors are <code class="literal">double</code> type.</p></div></div><p>It is tedious to enter large amounts of data manually, but small vectors can be created by using the <code class="literal">c()</code> combine function. The vector can also be given a name using the <code class="literal">&lt;-</code> arrow operator, which is R's way of assigning values, much like the <code class="literal">=</code> assignment operator is used in many other programming languages.</p><p>For example, let's construct several vectors to store the diagnostic data of three medical patients. We'll create a <code class="literal">character</code> vector named <code class="literal">subject_name</code> to store the three patient names, a <code class="literal">double</code> vector named <code class="literal">temperature</code> to store each patient's body temperature, and a logical vector named <code class="literal">flu_status</code> to store each patient's diagnosis (<code class="literal">TRUE</code> if he or she has influenza, <code class="literal">FALSE</code> otherwise). Let's have a look at the following code to create these three vectors:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; subject_name &lt;- c("John Doe", "Jane Doe", "Steve Graves")</strong></span>
<span class="strong"><strong>&gt; temperature &lt;- c(98.1, 98.6, 101.4)</strong></span>
<span class="strong"><strong>&gt; flu_status &lt;- c(FALSE, FALSE, TRUE)</strong></span>
</pre></div><p>Because R vectors are inherently ordered, the records can be accessed by counting the item's number in the set, beginning at one, and surrounding this number with square brackets (that is, <code class="literal">[</code> and <code class="literal">]</code>) after the name of the vector. For instance, to obtain the body temperature for patient Jane Doe (the second element in the <code class="literal">temperature</code> vector) simply type:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; temperature[2]</strong></span>
<span class="strong"><strong>[1] 98.6</strong></span>
</pre></div><p>R offers a variety of <a id="id106" class="indexterm"/>convenient methods to extract data from vectors. A range of values can be obtained using the (<code class="literal">:</code>) colon operator. For instance, to obtain the body temperature of Jane Doe and Steve Graves, type:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; temperature[2:3]</strong></span>
<span class="strong"><strong>[1] 98.6 101.4</strong></span>
</pre></div><p>Items can be excluded by specifying a negative item number. To exclude Jane Doe's <code class="literal">temperature</code> data, type:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; temperature[-2]</strong></span>
<span class="strong"><strong>[1]  98.1 101.4</strong></span>
</pre></div><p>Finally, it is also sometimes useful to specify a logical vector indicating whether each item should be included. For example, to include the first two <code class="literal">temperature</code> readings but exclude the third, type:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; temperature[c(TRUE, TRUE, FALSE)]</strong></span>
<span class="strong"><strong>[1] 98.1 98.6</strong></span>
</pre></div><p>As you will see shortly, the vector provides the foundation for many other R data structures. Therefore, the knowledge of the various vector operations is crucial to work with data in R.</p><div class="tip" title="Tip" style=""><div class="inner"><h3 class="title"><a id="tip18"/>Tip</h3><p>
<span class="strong"><strong>Downloading the example code</strong></span>
</p><p>You can download the example code files for all Packt books you have purchased from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p><p>New to the second edition of this book, the example code is also available via GitHub at <a class="ulink" href="https://github.com/dataspelunking/MLwR/">https://github.com/dataspelunking/MLwR/</a>. Check here for the most up-to-date R code, as well as issue tracking and a public wiki. Please join the community!</p></div></div></div><div class="section" title="Factors"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec21"/>Factors</h2></div></div></div><p>If you recall <a id="id107" class="indexterm"/>from <a class="link" href="ch01.html" title="Chapter 1. Introducing Machine Learning">Chapter 1</a>, <span class="emphasis"><em>Introducing Machine Learning</em></span>, features that represent a characteristic with categories of values are known as <span class="strong"><strong>nominal</strong></span>. Although <a id="id108" class="indexterm"/>it is possible to use a character vector to store nominal data, R provides a data structure specifically for this purpose. A <span class="strong"><strong>factor</strong></span> is a special <a id="id109" class="indexterm"/>case of vector that is solely used to represent categorical or ordinal variables. In the medical dataset we are building, we might use a factor to represent gender, because it uses two categories: <code class="literal">MALE</code> and <code class="literal">FEMALE</code>.</p><p>Why not use character vectors? An advantage of factors is that the category labels are stored only once. For instance, rather than storing <code class="literal">MALE</code>, <code class="literal">MALE</code>, <code class="literal">FEMALE</code>, the computer can store <code class="literal">1</code>, <code class="literal">1</code>, <code class="literal">2</code>, which reduces the size of memory needed to store the same information. Additionally, many machine learning algorithms treat nominal and numeric data differently. Coding as factors is often needed to inform an R function to treat categorical data appropriately.</p><div class="tip" title="Tip" style=""><div class="inner"><h3 class="title"><a id="tip19"/>Tip</h3><p>A factor should not be used for character vectors that are not truly categorical. If a vector stores mostly unique values like names or identification strings, keep it as a character vector.</p></div></div><p>To create a factor from a character vector, simply apply the <code class="literal">factor()</code> function. For example:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; gender &lt;- factor(c("MALE", "FEMALE", "MALE"))</strong></span>
<span class="strong"><strong>&gt; gender</strong></span>
<span class="strong"><strong>[1] MALE   FEMALE MALE</strong></span>
<span class="strong"><strong>Levels: FEMALE MALE</strong></span>
</pre></div><p>Notice that when the gender data for John Doe and Jane Doe were displayed, R printed additional information about the <code class="literal">gender</code> factor. The <code class="literal">levels</code> variable comprise the set of possible categories <code class="literal">factor</code> could take, in this case: <code class="literal">MALE</code> or <code class="literal">FEMALE</code>.</p><p>When we create factors, we can add additional levels that may not appear in the data. Suppose we add another factor for the blood type, as shown in the following example:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; blood &lt;- factor(c("O", "AB", "A"),</strong></span>
<span class="strong"><strong>                            levels = c("A", "B", "AB", "O"))</strong></span>
<span class="strong"><strong>&gt; blood[1:2]</strong></span>
<span class="strong"><strong>[1] O  AB</strong></span>
<span class="strong"><strong>Levels: A B AB O</strong></span>
</pre></div><p>Notice that when we defined the <code class="literal">blood</code> factor for the three patients, we specified an additional vector of four possible blood types using the <code class="literal">levels</code> parameter. As a result, even though our data included only types <code class="literal">O</code>, <code class="literal">AB</code>, and <code class="literal">A</code>, all the four types are stored with the <code class="literal">blood</code> factor as indicated by the output. Storing the additional level allows for the possibility of adding data with the other blood types in the future. It also ensures that if we were to create a table of blood types, we would know that the <code class="literal">B</code> type exists, despite it not being recorded in our data.</p><p>The factor data structure <a id="id110" class="indexterm"/>also allows us to include information about the order of a nominal variable's categories, which provides a convenient way to store ordinal data. For <a id="id111" class="indexterm"/>example, suppose we have data on the severity of a patient's <code class="literal">symptoms</code> coded in an increasing level of severity from mild, to moderate, to severe. We indicate the presence of ordinal data by providing the factor's <code class="literal">levels</code> in the desired order, listed in ascending order from lowest to highest, and setting the <code class="literal">ordered</code> parameter to <code class="literal">TRUE</code>, as shown:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; symptoms &lt;- factor(c("SEVERE", "MILD", "MODERATE"),</strong></span>
<span class="strong"><strong>                                levels = c("MILD", "MODERATE", "SEVERE"),</strong></span>
<span class="strong"><strong>                                ordered = TRUE)</strong></span>
</pre></div><p>The resulting <code class="literal">symptoms</code> factor now includes information about the order we requested. Unlike our prior factors, the levels value of this factor are separated by <code class="literal">&lt;</code> symbols, to indicate the presence of a sequential order from mild to severe:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; symptoms</strong></span>
<span class="strong"><strong>[1] SEVERE   MILD     MODERATE</strong></span>
<span class="strong"><strong>Levels: MILD &lt; MODERATE &lt; SEVERE</strong></span>
</pre></div><p>A helpful feature of the ordered factors is that logical tests work as you expect. For instance, we can test whether each patient's symptoms are greater than moderate:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; symptoms &gt; "MODERATE"</strong></span>
<span class="strong"><strong>[1]  TRUE FALSE FALSE</strong></span>
</pre></div><p>Machine learning algorithms capable of modeling ordinal data will expect the ordered factors, so be sure to code your data accordingly.</p></div><div class="section" title="Lists"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec22"/>Lists</h2></div></div></div><p>A <span class="strong"><strong>list</strong></span> is a data structure, much like a vector, in that it is used for storing an ordered set of elements. However, where a vector requires all its elements to be the same type, a list allows different types <a id="id112" class="indexterm"/>of elements to be collected. Due to this flexibility, lists are <a id="id113" class="indexterm"/>often used to store various types of input and output data and sets of configuration parameters for machine learning models.</p><p>To illustrate lists, consider the medical patient dataset we have been constructing with the data for three patients stored in six vectors. If we want to display all the data on John Doe (subject 1), we would need to enter five R commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; subject_name[1]</strong></span>
<span class="strong"><strong>[1] "John Doe"</strong></span>
<span class="strong"><strong>&gt; temperature[1]</strong></span>
<span class="strong"><strong>[1] 98.1</strong></span>
<span class="strong"><strong>&gt; flu_status[1]</strong></span>
<span class="strong"><strong>[1] FALSE</strong></span>
<span class="strong"><strong>&gt; gender[1]</strong></span>
<span class="strong"><strong>[1] MALE</strong></span>
<span class="strong"><strong>Levels: FEMALE MALE</strong></span>
<span class="strong"><strong>&gt; blood[1]</strong></span>
<span class="strong"><strong>[1] O</strong></span>
<span class="strong"><strong>Levels: A B AB O</strong></span>
<span class="strong"><strong>&gt; symptoms[1]</strong></span>
<span class="strong"><strong>[1] SEVERE</strong></span>
<span class="strong"><strong>Levels: MILD &lt; MODERATE &lt; SEVERE</strong></span>
</pre></div><p>This seems like a lot of work to display one patient's medical data. The list structure allows us to group all of the patient's data into one object that we can use repeatedly.</p><p>Similar to creating a vector with <code class="literal">c()</code>, a list is created using the <code class="literal">list()</code> function, as shown in the following example. One notable difference is that when a list is constructed, each component in the sequence is almost always given a name. The names are not technically required, but allow the list's values to be accessed later on by name rather than by numbered position. To create a list with named components for all of the first patient's data, type the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; subject1 &lt;- list(fullname = subject_name[1],</strong></span>
<span class="strong"><strong>                           temperature = temperature[1],</strong></span>
<span class="strong"><strong>                           flu_status = flu_status[1],</strong></span>
<span class="strong"><strong>                           gender = gender[1],</strong></span>
<span class="strong"><strong>                           blood = blood[1],</strong></span>
<span class="strong"><strong>                           symptoms = symptoms[1])</strong></span>
</pre></div><p>This patient's data is now collected in the <code class="literal">subject1</code> list:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; subject1</strong></span>
<span class="strong"><strong>$fullname</strong></span>
<span class="strong"><strong>[1] "John Doe"</strong></span>

<span class="strong"><strong>$temperature</strong></span>
<span class="strong"><strong>[1] 98.1</strong></span>

<span class="strong"><strong>$flu_status</strong></span>
<span class="strong"><strong>[1] FALSE</strong></span>

<span class="strong"><strong>$gender</strong></span>
<span class="strong"><strong>[1] MALE</strong></span>
<span class="strong"><strong>Levels: FEMALE MALE</strong></span>

<span class="strong"><strong>$blood</strong></span>
<span class="strong"><strong>[1] O</strong></span>
<span class="strong"><strong>Levels: A B AB O</strong></span>

<span class="strong"><strong>$symptoms</strong></span>
<span class="strong"><strong>[1] SEVERE</strong></span>
<span class="strong"><strong>Levels: MILD &lt; MODERATE &lt; SEVERE</strong></span>
</pre></div><p>Note that the values are labeled with the names we specified in the preceding command. However, a list can still be accessed using methods similar to a vector. To access the <code class="literal">temperature</code> value, use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; subject1[2]</strong></span>
<span class="strong"><strong>$temperature</strong></span>
<span class="strong"><strong>[1] 98.1</strong></span>
</pre></div><p>The result of using vector-style operators on a list object is another list object, which is a subset of the original list. For example, the preceding code returned a list with a single <code class="literal">temperature</code> component. To return a single list item in its native data type, use double brackets (<code class="literal">[[</code> and <code class="literal">]]</code>) when attempting to select the list component. For example, the following returns a numeric vector of length one:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; subject1[[2]]</strong></span>
<span class="strong"><strong>[1] 98.1</strong></span>
</pre></div><p>For clarity, it is often easier to access list components directly, by appending a <code class="literal">$</code> and the value's name to the name of the list component, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; subject1$temperature</strong></span>
<span class="strong"><strong>[1] 98.1</strong></span>
</pre></div><p>Like the double bracket <a id="id114" class="indexterm"/>notation, this returns the list component in its native data type (in this case, a numeric vector of length one).</p><div class="tip" title="Tip" style=""><div class="inner"><h3 class="title"><a id="tip20"/>Tip</h3><p>Accessing the value by name also ensures that the correct item is retrieved, even if the order of the list's elements is changed later on.</p></div></div><p>It is possible to obtain several <a id="id115" class="indexterm"/>items in a list by specifying a vector of names. The following returns a subset of the <code class="literal">subject1</code> list, which contains only the <code class="literal">temperature</code> and <code class="literal">flu_status</code> components:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; subject1[c("temperature", "flu_status")]</strong></span>
<span class="strong"><strong>$temperature</strong></span>
<span class="strong"><strong>[1] 98.1</strong></span>

<span class="strong"><strong>$flu_status</strong></span>
<span class="strong"><strong>[1] FALSE</strong></span>
</pre></div><p>Entire datasets could be constructed using lists and lists of lists. For example, you might consider creating a <code class="literal">subject2</code> and <code class="literal">subject3</code> list, and combining these into a single list object named <code class="literal">pt_data</code>. However, constructing a dataset in this way is common enough that R provides a specialized data structure specifically for this task.</p></div><div class="section" title="Data frames"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec23"/>Data frames</h2></div></div></div><p>By far, the most <a id="id116" class="indexterm"/>important R data structure utilized in machine learning is the <a id="id117" class="indexterm"/>
<span class="strong"><strong>data frame</strong></span>, a structure analogous to a spreadsheet or database, since it has both rows and columns of data. In R terms, a data frame can be understood as a list of vectors or factors, each having exactly the same number of values. Because the data frame is literally a list of vector type objects, it combines aspects of both vectors and lists.</p><p>Let's create a data frame for our patient dataset. Using the patient data vectors we created previously, the <code class="literal">data.frame()</code> function combines them into a data frame:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; pt_data &lt;- data.frame(subject_name, temperature, flu_status,</strong></span>
<span class="strong"><strong>      gender, blood, symptoms, stringsAsFactors = FALSE)</strong></span>
</pre></div><p>You might notice something new in the preceding code. We included an additional parameter: <code class="literal">stringsAsFactors = FALSE</code>. If we do not specify this option, R will automatically convert every character vector to a factor.</p><p>This feature is occasionally useful, but also sometimes unwarranted. Here, for example, the <code class="literal">subject_name</code> field is definitely not categorical data, as names are not categories of values. Therefore, setting the <code class="literal">stringsAsFactors</code> option to <code class="literal">FALSE</code> allows us to convert character vectors to <a id="id118" class="indexterm"/>factors only where it makes sense for the project.</p><p>When we display the <code class="literal">pt_data</code> data frame, we see that the structure is quite different from the data structures <a id="id119" class="indexterm"/>we worked with previously:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; pt_data</strong></span>
<span class="strong"><strong>  subject_name temperature flu_status gender blood symptoms</strong></span>
<span class="strong"><strong>1     John Doe        98.1      FALSE   MALE     O   SEVERE</strong></span>
<span class="strong"><strong>2     Jane Doe        98.6      FALSE FEMALE    AB     MILD</strong></span>
<span class="strong"><strong>3 Steve Graves       101.4       TRUE   MALE     A MODERATE</strong></span>
</pre></div><p>Compared to the one-dimensional vectors, factors, and lists, a data frame has two dimensions and is displayed in matrix format. This particular data frame has one column for each vector of patient data and one row for each patient. In machine learning terms, the data frame's columns are the features or attributes and the rows are the examples.</p><p>To extract entire columns (vectors) of data, we can take advantage of the fact that a data frame is simply a list of vectors. Similar to lists, the most direct way to extract a single element is by referring to it by name. For example, to obtain the <code class="literal">subject_name</code> vector, type:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; pt_data$subject_name</strong></span>
<span class="strong"><strong>[1] "John Doe"     "Jane Doe"     "Steve Graves"</strong></span>
</pre></div><p>Also similar to lists, a vector of names can be used to extract several columns from a data frame:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; pt_data[c("temperature", "flu_status")]</strong></span>
<span class="strong"><strong>  temperature flu_status</strong></span>
<span class="strong"><strong>1        98.1      FALSE</strong></span>
<span class="strong"><strong>2        98.6      FALSE</strong></span>
<span class="strong"><strong>3       101.4       TRUE</strong></span>
</pre></div><p>When we access the data frame in this way, the result is a data frame containing all the rows of data for all the requested columns. Alternatively, the <code class="literal">pt_data[2:3]</code> command will also extract the <code class="literal">temperature</code> and <code class="literal">flu_status</code> columns. However, requesting the columns by name results in a clear and easy-to-maintain R code that will not break if the data frame is restructured in the future.</p><p>To extract values in the data frame, methods like those for accessing values in vectors are used. However, there is an important exception. Because the data frame is two-dimensional, both the desired rows and columns to be extracted must be specified. Rows are specified first, followed by a comma and then the columns in a format like this: <code class="literal">[rows, columns]</code>. As with vectors, rows and columns are counted beginning at one.</p><p>For instance, to extract the <a id="id120" class="indexterm"/>value in the first row and second column of the patient data <a id="id121" class="indexterm"/>frame (the <code class="literal">temperature</code> value for John Doe), use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; pt_data[1, 2]</strong></span>
<span class="strong"><strong>[1] 98.1</strong></span>
</pre></div><p>If you like more than a single row or column of data, specify vectors for the rows and columns desired. The following command will pull data from the first and third rows and the second and fourth columns:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; pt_data[c(1, 3), c(2, 4)]</strong></span>
<span class="strong"><strong>  temperature gender</strong></span>
<span class="strong"><strong>1        98.1   MALE</strong></span>
<span class="strong"><strong>3       101.4   MALE</strong></span>
</pre></div><p>To extract all the rows or columns, simply leave the row or column portion blank. For example, to extract all the rows of the first column:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; pt_data[, 1]</strong></span>
<span class="strong"><strong>[1] "John Doe"     "Jane Doe"     "Steve Graves"</strong></span>
</pre></div><p>To extract all the columns of the first row, use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; pt_data[1, ]</strong></span>
<span class="strong"><strong>  subject_name temperature flu_status gender blood symptoms</strong></span>
<span class="strong"><strong>1     John Doe        98.1      FALSE   MALE     O   SEVERE</strong></span>
</pre></div><p>To extract everything, use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; pt_data[ , ]</strong></span>
<span class="strong"><strong>  subject_name temperature flu_status gender blood symptoms</strong></span>
<span class="strong"><strong>1     John Doe        98.1      FALSE   MALE     O   SEVERE</strong></span>
<span class="strong"><strong>2     Jane Doe        98.6      FALSE FEMALE    AB     MILD</strong></span>
<span class="strong"><strong>3 Steve Graves       101.4       TRUE   MALE     A MODERATE</strong></span>
</pre></div><p>Other methods to access values in lists and vectors can also be used to retrieve data frame rows and columns. For example, columns can be accessed by name rather than position, and negative signs can be used to exclude rows or columns of data. Therefore, the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; pt_data[c(1, 3), c("temperature", "gender")]</strong></span>
</pre></div><p>Is equivalent to:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; pt_data[-2, c(-1, -3, -5, -6)]</strong></span>
</pre></div><p>To become more familiar with data frames, try practicing similar operations with the patient dataset, or even better, use <a id="id122" class="indexterm"/>data from one of your own projects. These types of operations are crucial for much of the work we will do in the upcoming chapters.</p></div><div class="section" title="Matrixes and arrays"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec24"/>Matrixes and arrays</h2></div></div></div><p>In addition to <a id="id123" class="indexterm"/>data frames, R provides other structures that store values in a tabular <a id="id124" class="indexterm"/>form. A <span class="strong"><strong>matrix</strong></span> is a data structure that represents a two-dimensional table with rows and columns of data. Like vectors, R matrixes can contain any one type of <a id="id125" class="indexterm"/>data, although they are most often used for mathematical operations and, therefore, typically store only numeric data.</p><p>To create a matrix, simply supply a vector of data to the <code class="literal">matrix()</code> function along with a parameter specifying the number of rows (<code class="literal">nrow</code>) or number of columns (<code class="literal">ncol</code>). For example, to create a 2 x 2 matrix storing the numbers one through four, we can use the <code class="literal">nrow</code> parameter to request the data to be divided into two rows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; m &lt;- matrix(c(1, 2, 3, 4), nrow = 2)</strong></span>
<span class="strong"><strong>&gt; m</strong></span>
<span class="strong"><strong>     [,1] [,2]</strong></span>
<span class="strong"><strong>[1,]    1    3</strong></span>
<span class="strong"><strong>[2,]    2    4</strong></span>
</pre></div><p>This is equivalent to the matrix produced using <code class="literal">ncol = 2</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; m &lt;- matrix(c(1, 2, 3, 4), ncol = 2)</strong></span>
<span class="strong"><strong>&gt; m</strong></span>
<span class="strong"><strong>     [,1] [,2]</strong></span>
<span class="strong"><strong>[1,]    1    3</strong></span>
<span class="strong"><strong>[2,]    2    4</strong></span>
</pre></div><p>You will notice that R loaded the first column of the matrix first before loading the second column. This is called <span class="strong"><strong>column-major order</strong></span>, and is R's default method for loading matrices.</p><div class="tip" title="Tip" style=""><div class="inner"><h3 class="title"><a id="tip21"/>Tip</h3><p>To override this default <a id="id126" class="indexterm"/>setting and load a matrix by rows, set the parameter <code class="literal">byrow = TRUE</code> when creating the matrix.</p></div></div><p>To illustrate <a id="id127" class="indexterm"/>this further, let's see what happens if we add more values to the matrix.</p><p>With six values, requesting two rows creates a matrix with three columns:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; m &lt;- matrix(c(1, 2, 3, 4, 5, 6), nrow = 2)</strong></span>
<span class="strong"><strong>&gt; m</strong></span>
<span class="strong"><strong>     [,1] [,2] [,3]</strong></span>
<span class="strong"><strong>[1,]    1    3    5</strong></span>
<span class="strong"><strong>[2,]    2    4    6</strong></span>
</pre></div><p>Requesting two columns creates a matrix with three rows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; m &lt;- matrix(c(1, 2, 3, 4, 5, 6), ncol = 2)</strong></span>
<span class="strong"><strong>&gt; m</strong></span>
<span class="strong"><strong>     [,1] [,2]</strong></span>
<span class="strong"><strong>[1,]    1    4</strong></span>
<span class="strong"><strong>[2,]    2    5</strong></span>
<span class="strong"><strong>[3,]    3    6</strong></span>
</pre></div><p>As with data <a id="id128" class="indexterm"/>frames, values in matrixes can be extracted using <code class="literal">[row, column]</code> notation. For instance, <code class="literal">m[1, 1]</code> will return the value <code class="literal">1</code> and <code class="literal">m[3, 2]</code> will extract <code class="literal">6</code> from the <code class="literal">m</code> matrix. Additionally, entire rows or columns can be requested:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; m[1, ]</strong></span>
<span class="strong"><strong>[1] 1 4</strong></span>
<span class="strong"><strong>&gt; m[, 1]</strong></span>
<span class="strong"><strong>[1] 1 2 3</strong></span>
</pre></div><p>Closely related to the matrix structure is the <span class="strong"><strong>array</strong></span>, which is a multidimensional table of data. Where a matrix has rows and columns of values, an array has rows, columns, and any number of additional layers of values. Although we will be occasionally using matrixes in the upcoming chapters, the use of arrays is outside the scope of this book.</p></div></div></div>
<div class="section" title="Managing data with R"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Managing data with R</h1></div></div></div><p>One of the challenges <a id="id129" class="indexterm"/>faced while working with massive datasets involves <a id="id130" class="indexterm"/>gathering, preparing, and otherwise managing data from a variety of sources. Although we will cover data preparation, data cleaning, and data management in depth by working on real-world machine learning tasks in the later chapters, this section will highlight the basic functionality to get data into and out of R.</p><div class="section" title="Saving, loading, and removing R data structures"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec25"/>Saving, loading, and removing R data structures</h2></div></div></div><p>When you <a id="id131" class="indexterm"/>have spent a lot of time getting a data frame into the desired form, you shouldn't need to recreate your work each time you restart your R session. To <a id="id132" class="indexterm"/>save a data structure to a file that can be reloaded later or transferred to another system, use the <code class="literal">save()</code> function. The <code class="literal">save()</code> function writes one or <a id="id133" class="indexterm"/>more R data structures to the location specified by the <code class="literal">file</code> parameter. R data files have an <code class="literal">.RData</code> extension.</p><p>Suppose you have three objects named <code class="literal">x</code>, <code class="literal">y</code>, and <code class="literal">z</code> that you would like to save in a permanent file. Regardless of whether they are vectors, factors, lists, or data frames, we could save them to a file named <code class="literal">mydata.RData</code> using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; save(x, y, z, file = "mydata.RData")</strong></span>
</pre></div><p>The <code class="literal">load()</code> command can recreate any data structures that have been saved to an <code class="literal">.RData</code> file. To load the <code class="literal">mydata.RData</code> file we saved in the preceding code, simply type:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; load("mydata.RData")</strong></span>
</pre></div><p>This will recreate the <code class="literal">x</code>, <code class="literal">y</code>, and <code class="literal">z</code> data structures.</p><div class="tip" title="Tip" style=""><div class="inner"><h3 class="title"><a id="tip22"/>Tip</h3><p>Be careful of what you are loading! All data structures stored in the file you are importing with the <code class="literal">load()</code> command will be added to your workspace, even if they overwrite something else you are working on.</p></div></div><p>If you need to wrap up your R session in a hurry, the <code class="literal">save.image()</code> command will write your entire session to a file simply called <code class="literal">.RData</code>. By default, R will look for this file the next time you start R, and your session will be recreated just as you had left it.</p><p>After working on an R session for sometime, you may have accumulated a number of data structures. The <code class="literal">ls()</code> listing function returns a vector of all the data structures currently in the memory. For example, if you've been following along with the code in this chapter, the <code class="literal">ls()</code> function returns the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; ls()</strong></span>
<span class="strong"><strong>[1] "blood"        "flu_status"   "gender"       "m"           </strong></span>
<span class="strong"><strong>[5] "pt_data"      "subject_name" "subject1"     "symptoms"    </strong></span>
<span class="strong"><strong>[9] "temperature"</strong></span>
</pre></div><p>R will automatically remove these from its memory upon quitting the session, but for large data structures, you may want to free up the memory sooner. The <code class="literal">rm()</code> remove function can be used for this purpose. For example, to eliminate the <code class="literal">m</code> and <code class="literal">subject1</code> objects, simply type:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; rm(m, subject1)</strong></span>
</pre></div><p>The <code class="literal">rm()</code> function <a id="id134" class="indexterm"/>can also be supplied with a character vector of <a id="id135" class="indexterm"/>the object names to be removed. This works with the <code class="literal">ls()</code> function to clear the entire R session:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; rm(list=ls())</strong></span>
</pre></div><p>Be very careful while <a id="id136" class="indexterm"/>executing the preceding command, as you will not be prompted before your objects are removed!</p></div><div class="section" title="Importing and saving data from CSV files"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec26"/>Importing and saving data from CSV files</h2></div></div></div><p>It is very <a id="id137" class="indexterm"/>common for public datasets to be stored in text files. Text <a id="id138" class="indexterm"/>files can be read on virtually any computer or operating system, which makes the format nearly universal. They can also be exported and imported to and from programs such as Microsoft Excel, providing a quick and easy way to work with spreadsheet data.</p><p>A <span class="strong"><strong>tabular</strong></span> (as in "table") data <a id="id139" class="indexterm"/>file is structured in the matrix form, such that each line of text reflects one example, and each example has the same number of features. The feature values on each line are <a id="id140" class="indexterm"/>separated by a predefined symbol, known as a <span class="strong"><strong>delimiter</strong></span>. Often, the first line of a tabular data file lists the names of the columns of data. This <a id="id141" class="indexterm"/>is called a <span class="strong"><strong>header</strong></span> line.</p><p>Perhaps the most common tabular text file format is the <span class="strong"><strong>CSV </strong></span>(<span class="strong"><strong>Comma-Separated Values</strong></span>) file, which as <a id="id142" class="indexterm"/>the name suggests, uses the comma as a delimiter. The CSV files can be imported to and exported from many common applications. A CSV file representing the medical dataset constructed previously could be stored as:</p><div class="informalexample"><pre class="programlisting">subject_name,temperature,flu_status,gender,blood_type
John Doe,98.1,FALSE,MALE,O
Jane Doe,98.6,FALSE,FEMALE,AB
Steve Graves,101.4,TRUE,MALE,A</pre></div><p>Given a patient data file named <code class="literal">pt_data.csv</code> located in the R working directory, the <code class="literal">read.csv()</code> function can be used as follows to load the file into R:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; pt_data &lt;- read.csv("pt_data.csv", stringsAsFactors = FALSE)</strong></span>
</pre></div><p>This will read the CSV file into a data frame titled <code class="literal">pt_data</code>. Just as we did previously while constructing a data frame, we need to use the <code class="literal">stringsAsFactors = FALSE</code> parameter to prevent R from converting all text variables into factors. This step is better left to you, not R, to perform.</p><div class="tip" title="Tip" style=""><div class="inner"><h3 class="title"><a id="tip23"/>Tip</h3><p>If your dataset resides outside the R working directory, the full path to the CSV file (for example, <code class="literal">/path/to/mydata.csv</code>) can be used when calling the <code class="literal">read.csv()</code> function.</p></div></div><p>By default, R <a id="id143" class="indexterm"/>assumes that the CSV file includes a header line listing the names of the features in the dataset. If a CSV file does not have a header, specify the option <code class="literal">header = FALSE</code>, as shown in the following command, and R will assign default feature names in the <code class="literal">V1</code> and <code class="literal">V2</code> forms and so on:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; mydata &lt;- read.csv("mydata.csv", stringsAsFactors = FALSE, </strong></span>
<span class="strong"><strong>                                   header = FALSE)</strong></span>
</pre></div><p>The <code class="literal">read.csv()</code> function is a special case of the <code class="literal">read.table()</code> function, which can read tabular data in many different forms, including other delimited formats such as <span class="strong"><strong>Tab-Separated Values</strong></span> (<span class="strong"><strong>TSV</strong></span>). For more detailed information on the <code class="literal">read.table()</code> family of functions, refer <a id="id144" class="indexterm"/>to the R help page using the <code class="literal">?read.table</code> command.</p><p>To save a data frame to a CSV file, use the <code class="literal">write.csv()</code> function. If your data frame is named <code class="literal">pt_data</code>, simply enter:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; write.csv(pt_data, file = "pt_data.csv", row.names = FALSE)</strong></span>
</pre></div><p>This will write a CSV file with the name <code class="literal">pt_data.csv</code> to the R working folder. The <code class="literal">row.names</code> parameter overrides R's default setting, which is to output row names in the CSV file. Unless row names have been added to a data frame, this output is unnecessary and will simply inflate the size of the resulting file.</p></div></div>
<div class="section" title="Exploring and understanding data"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Exploring and understanding data</h1></div></div></div><p>After collecting <a id="id145" class="indexterm"/>data and loading it into R's data structures, the next step in the machine learning process involves examining the data in detail. It is during this step that you will begin to explore the data's features and examples, and realize the peculiarities that make your data unique. The better you understand your data, the better you will be able to match a machine learning model to your learning problem.</p><p>The best way to learn the process of data exploration is with an example. In this section, we will explore the <code class="literal">usedcars.csv</code> dataset, which contains actual data about used cars recently advertised for sale on a popular U.S. website.</p><div class="tip" title="Tip" style=""><div class="inner"><h3 class="title"><a id="tip24"/>Tip</h3><p>The <code class="literal">usedcars.csv</code> dataset is available for download on the Packt Publishing support page for this book. If you are following along with the examples, be sure that this file has been downloaded and saved to your R working directory.</p></div></div><p>Since the dataset is <a id="id146" class="indexterm"/>stored in the CSV form, we can use the <code class="literal">read.csv()</code> function to load the data into an R data frame:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; usedcars &lt;- read.csv("usedcars.csv", stringsAsFactors = FALSE)</strong></span>
</pre></div><p>Given the <code class="literal">usedcars</code> data frame, we will now assume the role of a data scientist who has the task of understanding the used car data. Although data exploration is a fluid process, the steps can be imagined as a sort of investigation in which questions about the data are answered. The exact questions may vary across projects, but the types of questions are always similar. You should be able to adapt the basic steps of this investigation to any dataset you like, whether large or small.</p><div class="section" title="Exploring the structure of data"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec27"/>Exploring the structure of data</h2></div></div></div><p>One of the first <a id="id147" class="indexterm"/>questions to ask in an investigation of a new dataset should be about how the dataset is organized. If you are fortunate, your source will provide a <a id="id148" class="indexterm"/>
<span class="strong"><strong>data dictionary</strong></span>, which is a document that describes the dataset's features. In our case, the used car data does not come with this documentation, so we'll need to create one on our own.</p><p>The <code class="literal">str()</code> function provides a method to display the structure of R data structures such as data frames, vectors, or lists. It can be used to create the basic outline for our data dictionary:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; str(usedcars)</strong></span>
<span class="strong"><strong>'data.frame':   150 obs. of 6 variables:</strong></span>
<span class="strong"><strong> $ year        : int  2011 2011 2011 2011 ...</strong></span>
<span class="strong"><strong> $ model       : chr  "SEL" "SEL" "SEL" "SEL" ...</strong></span>
<span class="strong"><strong> $ price       : int  21992 20995 19995 17809 ...</strong></span>
<span class="strong"><strong> $ mileage     : int  7413 10926 7351 11613 ...</strong></span>
<span class="strong"><strong> $ color       : chr  "Yellow" "Gray" "Silver" "Gray" ...</strong></span>
<span class="strong"><strong> $ transmission: chr  "AUTO" "AUTO" "AUTO" "AUTO" ...</strong></span>
</pre></div><p>Using such a simple command, we learn a wealth of information about the dataset. The statement <code class="literal">150 obs</code> informs us that the data includes 150 <span class="strong"><strong>observations</strong></span>, which is just another way of saying that the dataset contains 150 records or examples. The number of observations is often simply abbreviated as <span class="emphasis"><em>n</em></span>. Since we know that the data describes used cars, we can now presume that we have examples of <span class="emphasis"><em>n = 150</em></span> automobiles for sale.</p><p>The <code class="literal">6 variables</code> statement refers to the six features that were recorded in the data. These features are listed by name on separate lines. Looking at the line for the feature called <code class="literal">color</code>, we can note some additional details:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ color       : chr  "Yellow" "Gray" "Silver" "Gray" ...</strong></span>
</pre></div><p>After the variable's name, the <code class="literal">chr</code> label tells us that the feature is <code class="literal">character</code> type. In this dataset, three of the variables are character while three are noted as <code class="literal">int</code>, which indicates <code class="literal">integer</code> type. Although the <code class="literal">usedcars</code> dataset includes only <code class="literal">character</code> and <code class="literal">integer</code> variables, you are also likely to encounter <code class="literal">num</code> or <code class="literal">numeric</code> type while using noninteger data. Any factors would be listed as <code class="literal">factor</code> type. Following each variable's type, R presents a sequence of the first few feature values. The values <code class="literal">"Yellow" "Gray" "Silver" "Gray"</code> are the first four values of the <code class="literal">color</code> feature.</p><p>Applying a bit of the <a id="id149" class="indexterm"/>subject-area knowledge to the feature names and values allows us to make some assumptions about what the variables represent. The <code class="literal">year</code> variable could refer to the year the vehicle was manufactured or it could specify the year the advertisement was posted. We will have to investigate this feature more in detail later, since the four example values (<code class="literal">2011 2011 2011 2011</code>) could be used to argue for either possibility. The <code class="literal">model</code>, <code class="literal">price</code>, <code class="literal">mileage</code>, <code class="literal">color</code>, and <code class="literal">transmission</code> variables most likely refer to the characteristics of the car for sale.</p><p>Although our data seems to have been given meaningful variable names, this is not always the case. Sometimes datasets have features with nonsensical names or codes like <code class="literal">V1</code>. In these cases it may be necessary to do additional sleuthing to determine what a feature actually represents. Still, even with helpful feature names, it is always prudent to be skeptical about the labels you have been provided with. Let's investigate further.</p></div><div class="section" title="Exploring numeric variables"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec28"/>Exploring numeric variables</h2></div></div></div><p>To investigate the <a id="id150" class="indexterm"/>numeric variables in the used car data, we will employ a <a id="id151" class="indexterm"/>common set of measurements to describe values known as <span class="strong"><strong>summary statistics</strong></span>. The <code class="literal">summary()</code> function displays several common summary statistics. Let's take a look at a single feature, <code class="literal">year</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; summary(usedcars$year)</strong></span>
<span class="strong"><strong>   Min.  1st Qu.  Median    Mean 3rd Qu.    Max.</strong></span>
<span class="strong"><strong>  2000     2008     2009    2009   2010    2012</strong></span>
</pre></div><p>Even if you aren't already familiar with summary statistics, you may be able to guess some of them from the heading before the <code class="literal">summary()</code> output. Ignoring the meaning of the values for now, the fact that we see numbers such as <code class="literal">2000</code>, <code class="literal">2008</code>, and <code class="literal">2009</code> could lead us to believe that the <code class="literal">year</code> variable indicates the year of manufacture rather than the year the advertisement was posted, since we know the vehicles were recently listed for sale.</p><p>We can also use the <a id="id152" class="indexterm"/>
<code class="literal">summary()</code> function to obtain summary statistics for several <code class="literal">numeric</code> variables at the same time:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; summary(usedcars[c("price", "mileage")])</strong></span>
<span class="strong"><strong>     price           mileage     </strong></span>
<span class="strong"><strong> Min.   : 3800   Min.   :  4867  </strong></span>
<span class="strong"><strong> 1st Qu.:10995   1st Qu.: 27200  </strong></span>
<span class="strong"><strong> Median :13592   Median : 36385  </strong></span>
<span class="strong"><strong> Mean   :12962   Mean   : 44261  </strong></span>
<span class="strong"><strong> 3rd Qu.:14904   3rd Qu.: 55125  </strong></span>
<span class="strong"><strong> Max.   :21992   Max.   :151479</strong></span>
</pre></div><p>The six summary statistics that the <code class="literal">summary()</code> function provides are simple, yet powerful tools to investigate data. They can be divided into two types: measures of center and measures of spread.</p><div class="section" title="Measuring the central tendency – mean and median"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec01"/>Measuring the central tendency – mean and median</h3></div></div></div><p>Measures of <a id="id153" class="indexterm"/>
<span class="strong"><strong>central tendency</strong></span> are a class of statistics used to identify a value that falls in the middle of a set of data. You most likely are already familiar with one common measure of center: the average. In common use, when something is deemed average, it falls somewhere between the extreme ends of the scale. An average student might have marks falling in the middle of his or her classmates; an average weight is neither unusually light nor heavy. An average item is typical and not too unlike the others in the group. You might think of it as an exemplar by which all the others are judged.</p><p>In statistics, the average is also known as the <span class="strong"><strong>mean</strong></span>, which is a measurement defined as the sum of all values divided by <a id="id154" class="indexterm"/>the number of values. For example, to calculate the mean income in a group of three people with incomes of $36,000, $44,000, and $56,000, use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; (36000 + 44000 + 56000) / 3</strong></span>
<span class="strong"><strong>[1] 45333.33</strong></span>
</pre></div><p>R also provides a <code class="literal">mean()</code> function, which calculates the mean for a vector of numbers:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; mean(c(36000, 44000, 56000))</strong></span>
<span class="strong"><strong>[1] 45333.33</strong></span>
</pre></div><p>The mean income of this group of people is about $45,333. Conceptually, this can be imagined as the income each person would have, if the total amount of income were divided equally across every person.</p><p>Recall that the preceding <code class="literal">summary()</code> output listed mean values for the <code class="literal">price</code> and <code class="literal">mileage</code> variables. The means suggest that the typical used car in this dataset was listed at a price of $12,962 and had an odometer reading of 44,261. What does this tell us about our data? Since the average price is relatively low, we might expect that the dataset contains economy class cars. Of course, the data can also include late-model luxury cars with high mileage, but the relatively low mean mileage statistic doesn't provide evidence to support this <a id="id155" class="indexterm"/>hypothesis. On the other hand, it doesn't provide evidence to ignore the possibility either. We'll need to keep this in mind as we examine the data further.</p><p>Although the mean is by far the most commonly cited statistic to measure the center of a dataset, it is not always the most appropriate one. Another commonly used measure of central tendency is the <span class="strong"><strong>median</strong></span>, which is the value that occurs halfway through an ordered list of values. As with the mean, R provides a <code class="literal">median()</code> function, which we can apply to our salary data, as shown in the following example:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; median(c(36000, 44000, 56000))</strong></span>
<span class="strong"><strong>[1] 44000</strong></span>
</pre></div><p>Because the middle value is <code class="literal">44000</code>, the median income is $44,000.</p><div class="tip" title="Tip" style=""><div class="inner"><h3 class="title"><a id="tip25"/>Tip</h3><p>If a dataset has an even number of values, there is no middle value. In this case, the median is commonly calculated as the average of the two values at the center of the ordered list. For example, the median of the values 1, 2, 3, and 4 is 2.5.</p></div></div><p>At the first glance, it seems like the median and mean are very similar measures. Certainly, the mean value of $45,333 and the median value of $44,000 are not very different. Why have two measures of central tendency? The reason is due to the fact that the mean and median are affected differently by the values falling at the far ends of the range. In particular, the mean is highly sensitive to <span class="strong"><strong>outliers</strong></span>, or values that are atypically high or low in relation to the majority of data. Because the mean is sensitive to outliers, it is more likely to be shifted higher or lower by a small number of extreme values.</p><p>Recall again the reported median values in the <code class="literal">summary()</code> output for the used car dataset. Although the mean and median price are fairly similar (differing by approximately five percent), there is a much larger difference between the mean and median for mileage. For mileage, the mean of 44,261 is approximately 20 percent more than the median of 36,385. Since the mean is more sensitive to extreme values than the median, the fact that the mean is much <a id="id156" class="indexterm"/>higher than the median might lead us to suspect that there are some used cars in the dataset with extremely high mileage values. To investigate this further, we'll need to add additional summary statistics to our analysis.</p></div><div class="section" title="Measuring spread – quartiles and the five-number summary"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec02"/>Measuring spread – quartiles and the five-number summary</h3></div></div></div><p>Measuring the <a id="id157" class="indexterm"/>mean and median provides one way to quickly summarize the values, but these measures of center tell us little about whether or not there is diversity in the measurements. To measure the diversity, we need to employ another type of summary statistics that is concerned with the <span class="strong"><strong>spread</strong></span> of data, or how tightly or loosely the values are spaced. Knowing about the spread provides a sense of the data's highs and lows and whether most values are like or unlike the mean and median.</p><p>The <a id="id158" class="indexterm"/>
<span class="strong"><strong>five-number summary</strong></span> is a set of five statistics that roughly depict the spread of a feature's values. All five of the statistics are included in the output of the <code class="literal">summary()</code> function. Written in order, they are:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Minimum (<code class="literal">Min.</code>)</li><li class="listitem">First quartile, or Q1 (<code class="literal">1st Qu.</code>)</li><li class="listitem">Median, or Q2 (<code class="literal">Median</code>)</li><li class="listitem">Third quartile, or Q3 (<code class="literal">3rd Qu.</code>)</li><li class="listitem">Maximum (<code class="literal">Max.</code>)</li></ol></div><p>As you would expect, minimum and maximum are the most extreme feature values, indicating the smallest and largest values, respectively. R provides the <code class="literal">min()</code> and <code class="literal">max()</code> functions to calculate these values on a vector of data.</p><p>The span between the minimum and maximum value is known as the <span class="strong"><strong>range</strong></span>. In R, the <code class="literal">range()</code> function returns both the minimum and maximum value. Combining <code class="literal">range()</code> with the <code class="literal">diff()</code> difference function allows you to examine the range of data with a single line of code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; range(usedcars$price)</strong></span>
<span class="strong"><strong>[1]  3800 21992</strong></span>
<span class="strong"><strong>&gt; diff(range(usedcars$price))</strong></span>
<span class="strong"><strong>[1] 18192</strong></span>
</pre></div><p>The first and third quartiles—Q1 and Q3—refer to the value below or above which one quarter of the values are found. Along with the (Q2) median, the <span class="strong"><strong>quartiles</strong></span> divide a dataset into four portions, each with the same number of values.</p><p>Quartiles are a special <a id="id159" class="indexterm"/>case of a type of statistics called <span class="strong"><strong>quantiles</strong></span>, which are numbers that divide data into equally sized quantities. In addition to quartiles, commonly used quantiles include <span class="strong"><strong>tertiles</strong></span> (three parts), <span class="strong"><strong>quintiles</strong></span> (five parts), <span class="strong"><strong>deciles</strong></span> (10 parts), and <span class="strong"><strong>percentiles</strong></span> (100 parts).</p><div class="tip" title="Tip" style=""><div class="inner"><h3 class="title"><a id="tip26"/>Tip</h3><p>Percentiles are often used to describe the ranking of a value; for instance, a student whose test score was ranked at the 99<sup>th</sup> percentile performed better than, or equal to, 99 percent of the other test takers.</p></div></div><p>The middle 50 <a id="id160" class="indexterm"/>percent of data between the first and third quartiles is of particular interest because it in itself is a simple measure of spread. The difference between Q1 <a id="id161" class="indexterm"/>and Q3 is known as the <span class="strong"><strong>Interquartile Range</strong></span> (<span class="strong"><strong>IQR</strong></span>), and it can be calculated with the <code class="literal">IQR()</code> function:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; IQR(usedcars$price)</strong></span>
<span class="strong"><strong>[1] 3909.5</strong></span>
</pre></div><p>We could have also calculated this value by hand from the <code class="literal">summary()</code> output for the <code class="literal">usedcars$price</code> variable by computing <span class="emphasis"><em>14904 – 10995 = 3909</em></span>. The small difference between our calculation and the <code class="literal">IQR()</code> output is due to the fact that R automatically rounds the <code class="literal">summary()</code> output.</p><p>The <code class="literal">quantile()</code> function provides a robust tool to identify quantiles for a set of values. By default, the <code class="literal">quantile()</code> function returns the five-number summary. Applying the function to the used car data results in the same statistics as done earlier:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; quantile(usedcars$price)</strong></span>
<span class="strong"><strong>     0%     25%     50%     75%    100% </strong></span>
<span class="strong"><strong> 3800.0 10995.0 13591.5 14904.5 21992.0</strong></span>
</pre></div><div class="tip" title="Tip" style=""><div class="inner"><h3 class="title"><a id="tip27"/>Tip</h3><p>While computing quantiles, there are many methods to handle ties among values and datasets with no middle value. The <code class="literal">quantile()</code> function allows you to specify among nine different algorithms by specifying the <code class="literal">type</code> parameter. If your project requires a precisely defined quantile, it is important to read the function documentation using the <code class="literal">?quantile</code> command.</p></div></div><p>If we specify an additional <code class="literal">probs</code> parameter using a vector denoting cut points, we can obtain arbitrary quantiles, such as the 1<sup>st</sup> and 99<sup>th</sup> percentiles:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; quantile(usedcars$price, probs = c(0.01, 0.99))</strong></span>
<span class="strong"><strong>      1%      99% </strong></span>
<span class="strong"><strong> 5428.69 20505.00</strong></span>
</pre></div><p>The <code class="literal">seq()</code> function is used to generate vectors of evenly-spaced values. This makes it easy to obtain other slices of data, such as the quintiles (five groups), as shown in the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; quantile(usedcars$price, seq(from = 0, to = 1, by = 0.20))</strong></span>
<span class="strong"><strong>     0%     20%     40%     60%     80%    100% </strong></span>
<span class="strong"><strong> 3800.0 10759.4 12993.8 13992.0 14999.0 21992.0</strong></span>
</pre></div><p>Equipped with an <a id="id162" class="indexterm"/>understanding of the five-number summary, we can re-examine the used car <code class="literal">summary()</code> output. On the <code class="literal">price</code> variable, the minimum was $3,800 and the maximum was $21,992. Interestingly, the difference between the minimum and Q1 is about $7,000, as is the difference between Q3 and the maximum; yet, the difference from Q1 to the median to Q3 is roughly $2,000. This suggests that the lower and upper 25 percent of values are more widely dispersed than the middle 50 percent of values, which seem to be more tightly grouped around the center. We see a similar trend with the <code class="literal">mileage</code> variable, which is not unsurprising. As you will learn later in this chapter, this pattern of spread is common enough that it has been called a "normal" distribution of data.</p><p>The spread of the <code class="literal">mileage</code> variable also exhibits another interesting property: the difference between Q3 and the maximum value is far greater than that between the minimum value and Q1. In other words, the larger values are far more spread out than the smaller values.</p><p>This finding explains why the mean value is much greater than the median. Because the mean is sensitive to extreme <a id="id163" class="indexterm"/>values, it is pulled higher, while the median stays relatively in the same place. This is an important property, which becomes more apparent when the data is presented visually.</p></div><div class="section" title="Visualizing numeric variables – boxplots"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec03"/>Visualizing numeric variables – boxplots</h3></div></div></div><p>Visualizing <a id="id164" class="indexterm"/>numeric variables can be helpful in diagnosing data problems. A common visualization of the five-number summary is <span class="strong"><strong>boxplot</strong></span>, also known as a <span class="strong"><strong>box-and-whiskers</strong></span> plot. The boxplot displays the center and spread of a numeric <a id="id165" class="indexterm"/>variable in a format that allows you to quickly obtain a sense of the range and skew of a variable or compare it to other variables.</p><p>Let's take a look at a boxplot for the used car price and mileage data. To obtain a boxplot for a variable, we will use the <code class="literal">boxplot()</code> function. We will also specify a pair of extra parameters, <code class="literal">main</code> and <code class="literal">ylab</code>, to add a title to the figure and label the <span class="emphasis"><em>y</em></span> axis (the vertical axis), respectively. The commands to create the <code class="literal">price</code> and <code class="literal">mileage</code> boxplots are:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; boxplot(usedcars$price, main="Boxplot of Used Car Prices",</strong></span>
<span class="strong"><strong>                    ylab="Price ($)")</strong></span>
<span class="strong"><strong>&gt; boxplot(usedcars$mileage, main="Boxplot of Used Car Mileage",</strong></span>
<span class="strong"><strong>                    ylab="Odometer (mi.)")</strong></span>
</pre></div><p>R will produce figures as follows:</p><div class="mediaobject"><img src="graphics/B03905_02_01.jpg" alt="Visualizing numeric variables – boxplots"/></div><p>The box-and-whiskers <a id="id166" class="indexterm"/>plot depicts the five-number summary values using the horizontal lines and dots. The horizontal lines forming the box in the middle of each figure represent Q1, Q2 (the median), and Q3 while reading the plot from the bottom to the top. The median is denoted by the dark line, which lines up with $13,592 on the vertical axis for <code class="literal">price</code> and 36,385 mi. on the vertical axis for <code class="literal">mileage</code>.</p><div class="tip" title="Tip" style=""><div class="inner"><h3 class="title"><a id="tip28"/>Tip</h3><p>In simple boxplots such as those in the preceding diagram, the width of the box-and-whiskers plot is arbitrary and does not illustrate any characteristic of the data. For more sophisticated analyses, it is possible to use the shape and size of the boxes to facilitate comparisons of the data across several groups. To learn more about such features, begin by examining the <code class="literal">notch</code> and <code class="literal">varwidth</code> options in the R <code class="literal">boxplot()</code> documentation by typing the <code class="literal">?boxplot</code> command.</p></div></div><p>The minimum and maximum values can be illustrated using the whiskers that extend below and above the box; however, a widely used convention only allows the whiskers to extend to a minimum <a id="id167" class="indexterm"/>or maximum of 1.5 times the IQR below Q1 or above Q3. Any values that fall beyond this threshold are considered outliers and are denoted as circles or dots. For example, recall that the IQR for the <code class="literal">price</code> variable was 3,909 with a Q1 of 10,995 and a Q3 of 14,904. An outlier is therefore any value that is less than <span class="emphasis"><em>10995 - 1.5 * 3909= 5131.5</em></span> or greater than <span class="emphasis"><em>14904 + 1.5 * 3909 = 20767.5</em></span>.</p><p>The plot shows two such outliers on both the high and low ends. On the <code class="literal">mileage</code> boxplot, there are no outliers on the low end and thus, the bottom whisker extends to the minimum value, 4,867. On the high end, we see several outliers beyond the 100,000 mile mark. These outliers are responsible for our earlier finding, which noted that the mean value was much greater than the median.</p></div><div class="section" title="Visualizing numeric variables – histograms"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec04"/>Visualizing numeric variables – histograms</h3></div></div></div><p>A <span class="strong"><strong>histogram</strong></span> is another <a id="id168" class="indexterm"/>way to graphically depict the spread of a numeric variable. It is similar to a boxplot in a way that it divides the variable's values into a predefined number of portions or <span class="strong"><strong>bins</strong></span> that act as containers for values. Their similarities end there, however. On one hand, a boxplot requires that each of the four portions of data must <a id="id169" class="indexterm"/>contain the same number of values, and widens or narrows the bins as needed. On the other hand, a histogram uses any number of bins of an identical width, but allows the bins to contain different number of values.</p><p>We can create a histogram for the used car price and mileage data using the <code class="literal">hist()</code> function. As we did with the boxplot, we will specify a title for the figure using the <code class="literal">main</code> parameter, and label the <span class="emphasis"><em>x</em></span> axis with the <code class="literal">xlab</code> parameter. The commands to create the histograms are:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; hist(usedcars$price, main = "Histogram of Used Car Prices",</strong></span>
<span class="strong"><strong>              xlab = "Price ($)")</strong></span>
<span class="strong"><strong>&gt; hist(usedcars$mileage, main = "Histogram of Used Car Mileage",</strong></span>
<span class="strong"><strong>              xlab = "Odometer (mi.)")</strong></span>
</pre></div><p>This produces the following diagram:</p><div class="mediaobject"><img src="graphics/B03905_02_02.jpg" alt="Visualizing numeric variables – histograms"/></div><p>The histogram is composed of a series of bars with heights indicating the count, or <span class="strong"><strong>frequency</strong></span> of values falling within each of the equal width bins partitioning the values. The vertical lines that separate the bars, as labeled on the horizontal axis, indicate the start and end points of the range of values for the bin.</p><div class="tip" title="Tip" style=""><div class="inner"><h3 class="title"><a id="tip29"/>Tip</h3><p>You may have noticed that the preceding histograms have a different number of bins. This is because the <code class="literal">hist()</code> function attempts to identify a reasonable number of bins <a id="id170" class="indexterm"/>for the variable's range. If you'd like to override this default, use the <code class="literal">breaks</code> parameter. Supplying an integer like <code class="literal">breaks = 10</code> would create exactly 10 bins of equal width; supplying a vector like <code class="literal">c(5000, 10000, 15000, 20000)</code> would create bins that break at the specified values.</p></div></div><p>On the <code class="literal">price</code> histogram, each of the 10 bars spans an interval of $2,000, beginning at $2,000 and ending at $22,000. The tallest bar at the center of the figure covers the $12,000 to $14,000 range and has a frequency of 50. Since we know that our data includes 150 cars, we know that one-third of all the cars are priced from $12,000 to $14,000. Nearly 90 cars—more than half—are priced from $12,000 to $16,000.</p><p>The <code class="literal">mileage</code> histogram includes eight bars indicating bins of 20,000 miles each, beginning at 0 and ending at 160,000 miles. Unlike the price histogram, the tallest bar is not at the center of the data, but on the left-hand side of the diagram. The 70 cars contained in this bin have odometer readings from 20,000 to 40,000 miles.</p><p>You might also notice that the shape of the two histograms is somewhat different. It seems that the used car prices tend to be evenly divided on both sides of the middle, while the car mileages stretch further to the right. This characteristic is known as <span class="strong"><strong>skew</strong></span>, or more specifically right skew, because the values on the high end (right side) are far more spread out than the values on the low end (left side). As shown in the following diagram, histograms of skewed data look stretched on one of the sides:</p><div class="mediaobject"><img src="graphics/B03905_02_03.jpg" alt="Visualizing numeric variables – histograms"/></div><p>The ability to quickly <a id="id171" class="indexterm"/>diagnose such patterns in our data is one of the strengths of the histogram as a data exploration tool. This will become even more important as we start examining other patterns of spread in numeric data.</p></div><div class="section" title="Understanding numeric data – uniform and normal distributions"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec05"/>Understanding numeric data – uniform and normal distributions</h3></div></div></div><p>Histograms, boxplots, and <a id="id172" class="indexterm"/>statistics describing the center and spread provide ways to examine the distribution of a variable's values. A variable's <span class="strong"><strong>distribution</strong></span> describes how likely a value is to fall within various ranges.</p><p>If all the values are equally likely to occur—say, for instance, in a dataset recording the values rolled on a fair six-sided die—the distribution is said to be <span class="strong"><strong>uniform</strong></span>. A uniform distribution is easy to detect with a histogram, because the bars are approximately the same height. When visualized with a histogram, it may look something like the following diagram:</p><div class="mediaobject"><img src="graphics/B03905_02_04.jpg" alt="Understanding numeric data – uniform and normal distributions"/></div><p>It's important to note that not all random events are uniform. For instance, rolling a weighted six-sided trick die would result in some numbers coming up more often than others. While each roll of the die results in a randomly selected number, they are not equally likely.</p><p>Take, for instance, the used car data. This is clearly not uniform, since some values are seemingly far more likely to occur than others. In fact, on the price histogram, it seems that values grow less likely to occur as they are further away from both sides of the center bar, resulting in a <a id="id173" class="indexterm"/>bell-shaped distribution of data. This characteristic is so common in real-world data that it is the hallmark of the so-called <span class="strong"><strong>normal distribution</strong></span>. The <a id="id174" class="indexterm"/>stereotypical bell-shaped curve of normal distribution is shown in the following diagram:</p><div class="mediaobject"><img src="graphics/B03905_02_05.jpg" alt="Understanding numeric data – uniform and normal distributions"/></div><p>Although there are numerous types of non-normal distributions, many real-world phenomena generate data that can be described by the normal distribution. Therefore, the normal distribution's properties have been studied in great detail.</p></div><div class="section" title="Measuring spread – variance and standard deviation"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec06"/>Measuring spread – variance and standard deviation</h3></div></div></div><p>Distributions allow <a id="id175" class="indexterm"/>us to characterize a large number of values using a smaller number of parameters. The normal distribution, which describes many types of real-world data, can be defined with just two: center and spread. The center of normal distribution is defined by its mean value, which <a id="id176" class="indexterm"/>we have used earlier. The spread is measured by a statistic called the <span class="strong"><strong>standard deviation</strong></span>.</p><p>In order to calculate the standard deviation, we must first obtain the <span class="strong"><strong>variance</strong></span>, which is defined as the average of the squared differences between each value and the mean value. In mathematical notation, the variance of a set of <span class="emphasis"><em>n</em></span> values of <span class="emphasis"><em>x</em></span> is defined by the following formula. The Greek letter <span class="emphasis"><em>mu</em></span> (similar in appearance to an <span class="emphasis"><em>m</em></span> or <span class="emphasis"><em>u</em></span>) denotes the mean of the values, and the variance itself is denoted by the Greek letter <span class="emphasis"><em>sigma</em></span> squared (similar to a <span class="emphasis"><em>b</em></span> turned sideways):</p><div class="mediaobject"><img src="graphics/B03905_02_06.jpg" alt="Measuring spread – variance and standard deviation"/></div><p>The standard deviation is the square root of the variance, and is denoted by <span class="emphasis"><em>sigma</em></span>, as shown in the following formula:</p><div class="mediaobject"><img src="graphics/B03905_02_07.jpg" alt="Measuring spread – variance and standard deviation"/></div><p>The <code class="literal">var()</code> and <code class="literal">sd()</code> functions can be used to obtain the variance and standard deviation in R. For example, computing the variance and standard deviation on our <code class="literal">price</code> and <code class="literal">mileage</code> variables, we find:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; var(usedcars$price)</strong></span>
<span class="strong"><strong>[1] 9749892</strong></span>
<span class="strong"><strong>&gt; sd(usedcars$price)</strong></span>
<span class="strong"><strong>[1] 3122.482</strong></span>
<span class="strong"><strong>&gt; var(usedcars$mileage)</strong></span>
<span class="strong"><strong>[1] 728033954</strong></span>
<span class="strong"><strong>&gt; sd(usedcars$mileage)</strong></span>
<span class="strong"><strong>[1] 26982.1</strong></span>
</pre></div><p>While interpreting the variance, larger numbers indicate that the data are spread more widely around the mean. The standard deviation indicates, on average, how much each value differs from the mean.</p><div class="tip" title="Tip" style=""><div class="inner"><h3 class="title"><a id="tip30"/>Tip</h3><p>If you compute these <a id="id177" class="indexterm"/>statistics by hand using the formulas in the preceding diagrams, you will obtain a slightly different result than the built-in R functions. This is because the preceding formulae use the population variance (which divides by <span class="emphasis"><em>n</em></span>), while R uses the sample variance (which divides by <span class="emphasis"><em>n - 1</em></span>). Except for very small datasets, the distinction is minor.</p></div></div><p>The standard deviation can be used to quickly estimate how extreme a given value is under the assumption that it came from a normal distribution. The <span class="strong"><strong>68-95-99.7 rule</strong></span> states that 68 percent of the values in a normal distribution fall within one standard deviation of the mean, while 95 percent and 99.7 percent of the values fall within two and three standard deviations, respectively. This is illustrated in the following diagram:</p><div class="mediaobject"><img src="graphics/B03905_02_08.jpg" alt="Measuring spread – variance and standard deviation"/></div><p>Applying this information <a id="id178" class="indexterm"/>to the used car data, we know that since the mean and standard deviation of <code class="literal">price</code> were $12,962 and $3,122, respectively, assuming that the prices are normally distributed, approximately 68 percent of cars in our data were advertised at prices between <span class="emphasis"><em>$12,962 - $3,122 = $9,840</em></span> and <span class="emphasis"><em>$12,962 + $3,122 = $16,804</em></span>.</p><div class="tip" title="Tip" style=""><div class="inner"><h3 class="title"><a id="tip31"/>Tip</h3><p>Although, strictly speaking, the 68-95-99.7 rule only applies to normal distributions, the basic principle applies to any data; values more than three standard deviations away from the mean are exceedingly rare events.</p></div></div></div></div><div class="section" title="Exploring categorical variables"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec29"/>Exploring categorical variables</h2></div></div></div><p>If you recall, the <a id="id179" class="indexterm"/>used car dataset had three categorical variables: <code class="literal">model</code>, <code class="literal">color</code>, and <code class="literal">transmission</code>. Because we used the <code class="literal">stringsAsFactors = FALSE</code> parameter while loading the data, R has left them as the <code class="literal">character</code> (<code class="literal">chr</code>) type vectors rather than automatically converting them into <code class="literal">factor</code> type. Additionally, we might consider treating the year variable as categorical; although it has been loaded as a <code class="literal">numeric</code> (<code class="literal">int</code>) type vector, each year is a category that could apply to multiple cars.</p><p>In contrast to <code class="literal">numeric</code> data, categorical data is typically examined using tables rather than summary statistics. A table that <a id="id180" class="indexterm"/>presents a single categorical variable is known as a <span class="strong"><strong>one-way table</strong></span>. The <code class="literal">table()</code> function can be used to generate one-way tables for our used car data:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; table(usedcars$year)</strong></span>
<span class="strong"><strong>2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 </strong></span>
<span class="strong"><strong>   3    1    1    1    3    2    6   11   14   42   49   16    1</strong></span>
<span class="strong"><strong>&gt; table(usedcars$model)</strong></span>
<span class="strong"><strong> SE SEL SES </strong></span>
<span class="strong"><strong>78  23  49</strong></span>
<span class="strong"><strong>&gt; table(usedcars$color)</strong></span>
<span class="strong"><strong> Black   Blue   Gold   Gray  Green    Red Silver  White Yellow </strong></span>
<span class="strong"><strong>    35     17      1     16      5     25     32     16      3</strong></span>
</pre></div><p>The <code class="literal">table()</code> output lists <a id="id181" class="indexterm"/>the categories of the nominal variable and a count of the number of values falling into this category. Since we know that there are 150 used cars in the dataset, we can determine that roughly one-third of all the cars were manufactured in the year <code class="literal">2010</code>, given that <span class="emphasis"><em>49/150 = 0.327</em></span>.</p><p>R can also perform the calculation of table proportions directly, by using the <code class="literal">prop.table()</code> command on a table produced by the <code class="literal">table()</code> function:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; model_table &lt;- table(usedcars$model)</strong></span>
<span class="strong"><strong>&gt; prop.table(model_table)</strong></span>
<span class="strong"><strong>       SE       SEL       SES </strong></span>
<span class="strong"><strong>0.5200000 0.1533333 0.3266667</strong></span>
</pre></div><p>The results of <code class="literal">prop.table()</code> can be combined with other R functions to transform the output. Suppose that we would like to display the results in percentages with a single decimal place. We can do this by multiplying the proportions by 100, then using the <code class="literal">round()</code> function while specifying <code class="literal">digits = 1</code>, as shown in the following example:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; color_pct &lt;- table(usedcars$color)</strong></span>
<span class="strong"><strong>&gt; color_pct &lt;- prop.table(color_table) * 100</strong></span>
<span class="strong"><strong>&gt; round(color_pct, digits = 1)</strong></span>
<span class="strong"><strong>Black   Blue   Gold   Gray  Green    Red Silver  White Yellow </strong></span>
<span class="strong"><strong> 23.3   11.3    0.7   10.7    3.3   16.7   21.3   10.7    2.0</strong></span>
</pre></div><p>Although this includes the same information as the default <code class="literal">prop.table()</code> output, this is easier to read. The <a id="id182" class="indexterm"/>results show that black is the most common color, since nearly a quarter (23.3 percent) of all the advertised cars are <code class="literal">Black</code>. <code class="literal">Silver</code> is a close second with 21.3 percent and <code class="literal">Red</code> is third with 16.7 percent.</p><div class="section" title="Measuring the central tendency – the mode"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec07"/>Measuring the central tendency – the mode</h3></div></div></div><p>In statistics <a id="id183" class="indexterm"/>terms, the <span class="strong"><strong>mode</strong></span> of a feature is the value occurring most often. Like the mean and median, the mode is another measure of central tendency. It is often used for categorical data, since the mean and median are not defined for nominal variables.</p><p>For example, in the used car data, the mode of the <code class="literal">year</code> variable is 2010, while the modes for the <code class="literal">model</code> and <code class="literal">color</code> variables are <code class="literal">SE</code> and <code class="literal">Black</code>, respectively. A variable may have more than one mode; a <a id="id184" class="indexterm"/>variable with a single mode is <span class="strong"><strong>unimodal</strong></span>, while a variable <a id="id185" class="indexterm"/>with two modes is <span class="strong"><strong>bimodal</strong></span>. Data having multiple modes is more <a id="id186" class="indexterm"/>generally called <span class="strong"><strong>multimodal</strong></span>.</p><div class="tip" title="Tip" style=""><div class="inner"><h3 class="title"><a id="tip32"/>Tip</h3><p>Although you might suspect that you could use the <code class="literal">mode()</code> function, R uses this to obtain the type of variable (as in <code class="literal">numeric</code>, <code class="literal">list</code>, and so on) rather than the statistical mode. Instead, to find the statistical mode, simply look at the table output of the category with the greatest number of values.</p></div></div><p>The mode or modes are used in a qualitative sense to gain an understanding of important values. Yet, it would be dangerous to place too much emphasis on the mode, since the most common value is not necessarily a majority. For instance, although <code class="literal">Black</code> was the most common value for the <code class="literal">color</code> variable, black cars were only about a quarter of all advertised cars.</p><p>It is best to think about modes in relation to the other categories. Is there one category that dominates all the others or are there several? From here, we may ask what the most common values tell us about the variable being measured. If black and silver are commonly used car colors, we might assume that the data are for luxury cars, which tend to be sold in more conservative colors. These colors could also indicate economy cars, which are sold with fewer color options. We will keep this question in mind as we continue to examine this data.</p><p>Thinking about modes as common values allows us to apply the concept of statistical mode to the numeric data. Strictly speaking, it would be unlikely to have a mode for a continuous variable, since no two values are likely to repeat. Yet, if we think about modes as the highest bars on a histogram, we can discuss the modes of variables such as <code class="literal">price</code> and <code class="literal">mileage</code>. It can be helpful to consider mode while exploring the numeric data, particularly <a id="id187" class="indexterm"/>to examine whether or not the data is multimodal.</p><div class="mediaobject"><img src="graphics/B03905_02_09.jpg" alt="Measuring the central tendency – the mode"/></div></div></div><div class="section" title="Exploring relationships between variables"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec30"/>Exploring relationships between variables</h2></div></div></div><p>So far, we have <a id="id188" class="indexterm"/>examined variables one at a time, calculating <a id="id189" class="indexterm"/>only <span class="strong"><strong>univariate</strong></span> statistics. During our investigation, we raised questions that we were unable to answer at that time:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Does the <code class="literal">price</code> data imply that we are examining only economy-class cars or are there also luxury cars with high mileage?</li><li class="listitem" style="list-style-type: disc">Do relationships between the <code class="literal">model</code> and <code class="literal">color</code> data provide insight into the types of cars we are examining?</li></ul></div><p>These type of <a id="id190" class="indexterm"/>questions can be addressed by looking at <span class="strong"><strong>bivariate</strong></span> relationships, which consider the relationship between two variables. Relationships of more <a id="id191" class="indexterm"/>than two variables are called <span class="strong"><strong>multivariate</strong></span> relationships. Let's begin with the bivariate case.</p><div class="section" title="Visualizing relationships – scatterplots"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec08"/>Visualizing relationships – scatterplots</h3></div></div></div><p>A <span class="strong"><strong>scatterplot</strong></span> is a <a id="id192" class="indexterm"/>diagram that visualizes a bivariate relationship. It is a two-dimensional figure in which dots are drawn on a coordinate plane using the values of one <a id="id193" class="indexterm"/>feature to provide the horizontal <span class="emphasis"><em>x</em></span> coordinates and the values of another feature to provide the vertical <span class="emphasis"><em>y</em></span> coordinates. Patterns in the placement of dots reveal the underlying associations between the two features.</p><p>To answer our question about the relationship between <code class="literal">price</code> and <code class="literal">mileage</code>, we will examine a scatterplot. We'll use the <code class="literal">plot()</code> function along with the <code class="literal">main</code>, <code class="literal">xlab</code> and <code class="literal">ylab</code> parameters used previously to label the diagram.</p><p>To use <code class="literal">plot()</code>, we need to specify <code class="literal">x</code> and <code class="literal">y</code> vectors containing the values used to position the dots on the figure. Although the conclusions would be the same regardless of the variable used to supply the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> coordinates, convention dictates that the <span class="emphasis"><em>y</em></span> variable is the one that is presumed to depend on the other (and is therefore known as the dependent variable). Since <a id="id194" class="indexterm"/>a seller cannot modify the odometer reading, mileage is unlikely to be dependent on the car's price. Instead, our hypothesis is that the price depends on the odometer mileage. Therefore, we will use <code class="literal">price</code> as the <span class="emphasis"><em>y</em></span>, or dependent, variable.</p><p>The full command to create our scatterplot is:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; plot(x = usedcars$mileage, y = usedcars$price,</strong></span>
<span class="strong"><strong>          main = "Scatterplot of Price vs. Mileage",</strong></span>
<span class="strong"><strong>          xlab = "Used Car Odometer (mi.)",</strong></span>
<span class="strong"><strong>          ylab = "Used Car Price ($)")</strong></span>
</pre></div><p>This results in the following scatterplot:</p><div class="mediaobject"><img src="graphics/B03905_02_10.jpg" alt="Visualizing relationships – scatterplots"/></div><p>Using the scatterplot, we notice a clear relationship between the price of a used car and the odometer reading. To read the plot, examine how values of the <span class="emphasis"><em>y</em></span> axis variable change as the values on the <span class="emphasis"><em>x</em></span> axis increase. In this case, car prices tend to be lower as the mileage increases. If you have ever sold or shopped for a used car, this is not a profound insight.</p><p>Perhaps a more interesting finding is the fact that there are very few cars that have both high price and high mileage, aside from a lone outlier at about 125,000 miles and $14,000. The absence of more points like this provides evidence to support a conclusion that our data is unlikely to include any high mileage luxury cars. All of the most expensive cars in the data, particularly those above $17,500, seem to have extraordinarily low mileage, implying that we could be looking at a brand new type of car retailing for about $20,000.</p><p>The relationship we've found between car prices and mileage is known as a negative association, because it forms a pattern of dots in a line sloping downward. A positive association would appear to <a id="id195" class="indexterm"/>form a line sloping upward. A flat line, or a seemingly random scattering of dots, is evidence that the two variables are not associated at all. The strength of a linear association between two variables is measured by a statistic known as <span class="strong"><strong>correlation</strong></span>. Correlations are discussed in detail in <a class="link" href="ch06.html" title="Chapter 6. Forecasting Numeric Data – Regression Methods">Chapter 6</a>, <span class="emphasis"><em>Forecasting Numeric Data – Regression Methods</em></span>, which covers the methods for modeling linear relationships.</p><div class="tip" title="Tip" style=""><div class="inner"><h3 class="title"><a id="tip33"/>Tip</h3><p>Keep in mind that not all associations form straight lines. Sometimes the dots form a <span class="emphasis"><em>U</em></span> shape, or a <span class="emphasis"><em>V</em></span> shape; sometimes the pattern seems to be weaker or stronger for increasing values of the <code class="literal">x</code> or <code class="literal">y</code> variable. Such patterns imply that the relationship between the two variables is not linear.</p></div></div></div><div class="section" title="Examining relationships – two-way cross-tabulations"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec09"/>Examining relationships – two-way cross-tabulations</h3></div></div></div><p>To examine a <a id="id196" class="indexterm"/>relationship between two nominal variables, a <a id="id197" class="indexterm"/>
<span class="strong"><strong>two-way cross-tabulation</strong></span> is used (also known as a <span class="strong"><strong>crosstab</strong></span> or <span class="strong"><strong>contingency table</strong></span>). A cross-tabulation is similar to a scatterplot in that it allows you to examine how the values of one variable vary by the values of another. The format is a table in which the rows are the levels of one variable, while the columns are the levels of another. Counts in each of the table's cells indicate the number of values falling into the particular row and column combination.</p><p>To answer our earlier question about whether there is a relationship between car <code class="literal">model</code> and <code class="literal">color</code>, we will examine a crosstab. There are several functions to produce two-way tables in R, including <code class="literal">table()</code>, which we used for one-way tables. The <code class="literal">CrossTable()</code> option in the <code class="literal">gmodels</code> package by Gregory R. Warnes is perhaps the most user-friendly function, as it presents the row, column, and margin percentages in a single table, saving us the trouble of combining this data ourselves. To install the <code class="literal">gmodels</code> package, type:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; install.packages("gmodels")</strong></span>
</pre></div><p>After the package installs, type <code class="literal">library(gmodels)</code> to load the package. You will need to do this during each R session in which you plan on using the <code class="literal">CrossTable()</code> function.</p><p>Before proceeding with our analysis, let's simplify our project by reducing the number of levels in the <code class="literal">color</code> variable. This variable has nine levels, but we don't really need this much detail. What we are really interested in is whether or not the car's color is conservative. Toward this end, we'll divide the nine colors into two groups: the first group will include the conservative colors <code class="literal">Black</code>, <code class="literal">Gray</code>, <code class="literal">Silver</code>, and <code class="literal">White</code>; and the second group will include <code class="literal">Blue</code>, <code class="literal">Gold</code>, <code class="literal">Green</code>, <code class="literal">Red</code>, and <code class="literal">Yellow</code>. We will create a binary indicator variable (often <a id="id198" class="indexterm"/>called a <span class="strong"><strong>dummy variable</strong></span>), indicating whether or not the car's color is conservative by our definition. Its value will be <code class="literal">1</code> if true, <code class="literal">0</code> otherwise:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; usedcars$conservative &lt;-</strong></span>
<span class="strong"><strong>       usedcars$color %in% c("Black", "Gray", "Silver", "White")</strong></span>
</pre></div><p>You may have noticed a new command here: the <code class="literal">%in%</code> operator returns <code class="literal">TRUE</code> or <code class="literal">FALSE</code> for each value in the vector on the left-hand side of the operator depending on whether the value is found in the vector on the right-hand side. In simple terms, you can translate this line as "Is the used car color in the set of <code class="literal">Black</code>, <code class="literal">Gray</code>, <code class="literal">Silver</code>, and <code class="literal">White</code>?"</p><p>Examining the <code class="literal">table()</code> output for our newly created variable, we see that about two-thirds of the cars have conservative colors, while one-third do not have conservative colors:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; table(usedcars$conservative)</strong></span>
<span class="strong"><strong>FALSE  TRUE</strong></span>
<span class="strong"><strong>   51    99</strong></span>
</pre></div><p>Now, let's look at a cross-tabulation to see how the proportion of conservatively colored cars varies by the model. Since we're assuming that the model of the car dictates the choice of color, we'll treat the conservative color indicator as the dependent (<code class="literal">y</code>) variable. The <code class="literal">CrossTable()</code> command is therefore:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; CrossTable(x = usedcars$model, y = usedcars$conservative)</strong></span>
</pre></div><p>The preceding command results in the following table:</p><div class="mediaobject"><img src="graphics/B03905_02_11.jpg" alt="Examining relationships – two-way cross-tabulations"/></div><p>There is a wealth of data in the <code class="literal">CrossTable()</code> output. The legend at the top (labeled <code class="literal">Cell Contents</code>) indicates how to interpret each value. The rows in the table indicate the three models of used cars: <code class="literal">SE</code>, <code class="literal">SEL</code>, and <code class="literal">SES</code> (plus an additional row for the total across all models). The columns indicate whether or not the car's color is conservative (plus a column totaling across both types of color). The first value in each cell indicates the number of cars with that combination of model and color. The proportions indicate that the cell's proportion is relative to the chi-square statistic, row's total, column's total, and table's total.</p><p>What we are most interested in is the row proportion for conservative cars for each model. The row proportions tell us that 0.654 (65 percent) of <code class="literal">SE</code> cars are colored conservatively in comparison to 0.696 (70 percent) of <code class="literal">SEL</code> cars and 0.653 (65 percent) of <code class="literal">SES</code>. These differences are relatively small, suggesting that there are no substantial differences in the types of colors chosen by the model of the car.</p><p>The chi-square values refer to the cell's contribution in the <span class="strong"><strong>Pearson's Chi-squared test for independence</strong></span> between two variables. This test measures how likely it is that the difference in the cell counts in the table is due to chance alone. If the probability is very low, it provides strong evidence that the two variables are associated.</p><p>You can obtain the chi-squared test results by adding an additional parameter specifying <code class="literal">chisq = TRUE</code> while calling the <code class="literal">CrossTable()</code> function. In this case, the probability is about 93 percent, suggesting that it is very likely that the variations in cell count are due to chance alone and not due to a true association between the model and the color.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Summary</h1></div></div></div><p>In this chapter, we learned about the basics of managing data in R. We started by taking an in-depth look at the structures used for storing various types of data. The foundational R data structure is the vector, which is extended and combined into more complex data types such as lists and data frames. The data frame is an R data structure that corresponds to the notion of a dataset, having both features and examples. R provides functions for reading and writing data frames to spreadsheet-like tabular data files.</p><p>We then explored a real-world dataset containing data on used car prices. We examined numeric variables using common summary statistics of center and spread, and visualized relationships between prices and odometer readings with a scatterplot. We examined nominal variables using tables. In examining the used car data, we followed an exploratory process that can be used to understand any dataset. These skills will be required for the other projects throughout this book.</p><p>Now that we have spent some time understanding the basics of data management with R, you are ready to begin using machine learning to solve real-world problems. In the next chapter, we will tackle our first classification task using nearest neighbor methods.</p></div></body></html>