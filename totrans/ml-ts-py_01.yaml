- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Time-Series Analysis with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Time-Series analysis revolves around getting familiar with a dataset and coming
    up with ideas and hypotheses. It can be thought of as "storytelling for data scientists"
    and is a critical step in machine learning, because it can inform and help shape
    tentative conclusions to test while training a machine learning model. Roughly
    speaking, the main difference between time-series analysis and machine learning
    is that time-series analysis does not include formal statistical modeling and
    inference.
  prefs: []
  type: TYPE_NORMAL
- en: While it can be daunting and seem complex, it is a generally very structured
    process. In this chapter, we will go through the fundamentals in Python for dealing
    with time-series patterns. In Python, we can do time-series analysis by interactively
    querying our data using a number of tools that we have at our fingertips. This
    starts from creating and loading time-series datasets to identifying trend and
    seasonality. We'll outline both the structure of time-series analysis, and the
    constituents both in terms of theory and practice in Python by going through examples.
  prefs: []
  type: TYPE_NORMAL
- en: The main example will use a dataset of air pollution in London and Delhi. You
    can find this example as a Jupyter notebook in the book's GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is time-series analysis?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with time-series in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uncovering relationships between variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying trend and seasonality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll start with a characterization and an attempt at a definition of time-series
    analysis.
  prefs: []
  type: TYPE_NORMAL
- en: What is time-series analysis?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term **time-series analysis** (**TSA**) refers to the statistical approach
    to time-series or the analysis of trend and seasonality. It is often an *ad hoc*
    exploration and analysis that usually involves visualizing distributions, trends,
    cyclic patterns, and relationships between features, and between features and
    the target(s).
  prefs: []
  type: TYPE_NORMAL
- en: More generally, we can say TSA is roughly **exploratory data analysis** (**EDA**)
    that's specific to time-series data. This comparison can be misleading however
    since TSA can include both descriptive and exploratory elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see quickly the differences between descriptive and exploratory analysis:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Descriptive analysis** summarizes characteristics of a dataset'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exploratory analysis** analyzes for patterns, trends, or relationships between
    variables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, TSA is the initial investigation of a dataset with the goal of discovering
    patterns, especially trend and seasonality, and obtaining initial insights, testing
    hypotheses, and extracting meaningful summary statistics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Definition: Time-Series Analysis (TSA) is the process of extracting a summary
    and other statistical information from time-series, most importantly, the analysis
    of trend and seasonality.'
  prefs: []
  type: TYPE_NORMAL
- en: Since an important part of TSA is gathering statistics and representing your
    dataset graphically through visualization, we'll do a lot of plots in this chapter.
    Many statistics and plots described in this chapter are specific to TSA, so even
    if you are familiar with EDA, you'll find something new.
  prefs: []
  type: TYPE_NORMAL
- en: A part of TSA is collecting and reviewing data, examining the distribution of
    variables (and variable types), and checking for errors, outliers, and missing
    values. Some errors, variable types, and anomalies can be corrected, therefore
    EDA is often performed hand in hand with preprocessing and feature engineering,
    where columns and fields are selected and transformed. The whole process from
    data loading to machine learning is highly iterative and may involve multiple
    instances of TSA at different points.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few crucial steps for working with time-series:'
  prefs: []
  type: TYPE_NORMAL
- en: Importing the dataset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data cleaning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uncovering relationships between variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying trend and seasonality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preprocessing (including feature engineering)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Training a machine learning model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing the data can be considered prior to TSA, and data cleaning, feature
    engineering, and training a machine learning model are not strictly part of TSA.
  prefs: []
  type: TYPE_NORMAL
- en: Importing the data includes parsing, for example extracting dates. The three
    steps that are central to TSA are understanding variables, uncovering relationships
    between variables, and identifying trend and seasonality. There's a lot more to
    say about each of them, and in this chapter, we'll talk about them in more detail
    in their dedicated sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps belonging to TSA and leading to preprocessing (feature engineering)
    and machine learning are highly iterative, and can be visually appreciated in
    the following time-series machine learning flywheel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Flywheel%20-%20page%201.png](img/B17577_02_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: The time-series machine learning flywheel'
  prefs: []
  type: TYPE_NORMAL
- en: This flywheel emphasizes the iterative nature of the work. For example, data
    cleaning comes often after loading the data, but will come up again after we've
    made another discovery about our variables. I've highlighted TSA in dark, while
    steps that are not strictly part of TSA are grayed out.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go through something practical! We'll start by loading a dataset. Right
    after importing the data, we'd ask questions like what's the size of the dataset
    (the number of observations)? How many features or columns do we have? What are
    the column types?
  prefs: []
  type: TYPE_NORMAL
- en: We'll typically look at histograms or distribution plots. For assessing relationships
    between features and target variables, we'd calculate correlations and visualize
    them as a correlation heatmap, where the correlation strength between variables
    is mapped to colors.
  prefs: []
  type: TYPE_NORMAL
- en: We'd look for missing values – in a spreadsheet, these would be empty cells
    – and we'd clean up and correct these irregularities, where possible.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to be analyzing relationships between variables, and in TSA, one
    of its peculiarities is that we need to investigate the relationship of time with
    each variable.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, a useful way of distinguishing different types of techniques could
    be between univariate and multivariate analysis, and between graphical and non-graphical
    techniques. **Univariate analysis** means we are looking at a single variable.
    This means we could be inspecting values to get the means and the variance, or
    – for the graphical side – plotting the distribution. We summarize these techniques
    in the *Understanding the variables* section.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, **multivariate analysis** means we are calculating correlations
    between variables, or – for the graphical side – drawing a scatter plot, for example.
    We'll delve into these techniques in the *Uncovering relationships between variables*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Before we continue, let's go through a bit of the basics of time-series with
    Python. This will cover the basic operations with time-series data as an introduction.
    After this, we'll go through Python commands with an actual dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Working with time-series in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python has a lot of libraries and packages for time-series, such as `datetime`,
    `time`, `calendar`, `dateutil`, and `pytz`, which can be highly confusing for
    beginners. At the same time, there are many different data types like `date`,
    `time`, `datetime`, `tzinfo`, `timedelta`, `relativedelta`, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to using them, the devil is in the details. Just to name one
    example: many of these types are insensitive to the timezone. You should feel
    reassured, however, knowing that to get started, familiarity with a small subset
    of these libraries and data types is enough.'
  prefs: []
  type: TYPE_NORMAL
- en: Requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll use several libraries, which we can quickly install
    from the terminal (or similarly from Anaconda Navigator):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We'll execute the commands from the Python (or IPython) terminal, but equally
    we could execute them from a Jupyter notebook (or a different environment).
  prefs: []
  type: TYPE_NORMAL
- en: It's a good start if we at least know datetime and pandas, two very prominent
    libraries, which we'll cover in the following two sections. We'll create basic
    objects and do simple manipulations on them.
  prefs: []
  type: TYPE_NORMAL
- en: Datetime
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `date` and `datetime` data types are not primitive types in Python the way
    that numbers (`float` and `int`), `string`, `list`, `dictionary`, `tuple`, or
    `file` are. To work with `date` and `datetime` objects, we have to import datetime,
    a library that is part of the Python Standard Library, and the libraries that
    come by default with CPython and other main Python distributions.
  prefs: []
  type: TYPE_NORMAL
- en: datetime comes with objects such as `date`, `datetime`, `time`, and `timedelta`,
    among others. The difference between `datetime` and `date` objects is that the
    `datetime` object includes time information in addition to a date.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a date, we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To get today''s date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To get some other date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want a `datetime` object (a timestamp) instead, we can do this as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This will get the current timestamp. We can create a `datetime` for a specific
    date and time as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can get a string output in isoformat:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: isoformat, short for the ISO 8601 format, is an international standard for representing
    dates and times.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also work with time differences using `timedelta`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'These `timedelta` objects can be added to other objects for calculations. We
    can do calculations with a `timedelta` object, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The datetime library can parse string inputs to `date` and `datetime` types
    and output these objects as `string`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can format the output with string format options, for example like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This would give us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can read in a `date` or `datetime` object from a string, and
    we can use the same format options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can find a complete list of formatting options that you can use both for
    parsing strings and printing `datetime` objects here: [https://strftime.org/](https://strftime.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'A few important ones are listed in this table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Format string | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| %Y | Year as 4 digits |'
  prefs: []
  type: TYPE_TB
- en: '| %y | Year as 2 digits |'
  prefs: []
  type: TYPE_TB
- en: '| %m | Month as a number |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Day |'
  prefs: []
  type: TYPE_TB
- en: '| %H | Hour as 2 digits |'
  prefs: []
  type: TYPE_TB
- en: '| %M | Minute as 2 digits |'
  prefs: []
  type: TYPE_TB
- en: 'Figure 2.2: Format strings for dates'
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s useful to remember these strings with formatting options. For example,
    the format string for a US date separated by slashes would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: pandas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We introduced the pandas library in the previous chapter. pandas is one of the
    most important libraries in the Python ecosystem for data science, used for data
    manipulation and analysis. Initially released in 2008, it has been a major driver
    of Python's success.
  prefs: []
  type: TYPE_NORMAL
- en: pandas comes with significant time-series functionality such as date range generation,
    frequency conversion, moving window statistics, date shifting, and lagging.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go through some of these basics. We can create a time-series as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us a `DateTimeIndex` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also create a time-series as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This would give us a time-series like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this type is called a `DatetimeIndex`. This means we can use
    this data type for indexing a dataset.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most important functionalities is parsing to `date` or `datetime`
    objects from either `string` or separate columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We've created two time-series.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can take a rolling window for calculations like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Can you guess the result of this? If not, why don't you put this into your Python
    interpreter?
  prefs: []
  type: TYPE_NORMAL
- en: 'A time-series would usually be an index with a time object and one or more
    columns with numeric or other types, such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can have a look at our time-series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can index these time-series datasets like any other pandas Series or DataFrame.
    `ts[:2].index` would give us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Interestingly, we can index directly with strings or datetime objects. For
    example, `ts[''2021-03-28'':''2021-03-30'']` gives us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You can shift or lag the values in a time-series back and forward in time using
    the `shift` method. This changes the alignment of the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also change the resolution of time-series objects, for example like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Please note the difference between `datetime` and `pd.DateTimeIndex`. Even though
    they encode the same kind of information, they are different types and they might
    not always play well with each other. Therefore, I'd recommend to always explicitly
    convert types when doing comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, let's go through a basic example of importing a time-series
    dataset, getting summary statistics, and plotting some variables.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're going to load up a time-series dataset of air pollution, then we are going
    to do some very basic inspection of variables.
  prefs: []
  type: TYPE_NORMAL
- en: This step is performed on each variable on its own (univariate analysis) and
    can include summary statistics for each of the variables, histograms, finding
    missing values or outliers, and testing stationarity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important descriptors of continuous variables are the mean and the
    standard deviation. As a reminder, here are the formulas for the mean and the
    standard deviation. We are going to build on these formulas later with more complex
    formulas. The **mean** usually refers to the arithmetic mean, which is the most commonly
    used average and is defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17577_02_001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The **standard deviation** is the square root of the average squared difference
    to this mean value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17577_02_002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The **standard error** (**SE**) is an approximation of the standard deviation
    of sampled data. It measures the dispersion of sample means around the population
    mean, but normalized by the root of the sample size. The more data points involved
    in the calculation, the smaller the standard error tends to be. The SE is equal
    to the standard deviation divided by the square root of the sample size:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17577_02_003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'An important application of the SE is the estimation of confidence intervals
    of the mean. A **confidence interval** gives a range of values for a parameter.
    For example, the 95^(th) percentile upper confidence limit, ![](img/B17577_02_004.png),
    is defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17577_02_005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Similarly, replacing the plus with a minus, the lower confidence interval is
    defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17577_02_006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The **median** is another average, particularly useful when the data can''t
    be described accurately by the mean and standard deviations. This is the case
    when there''s a long tail, several peaks, or a skew in one or the other direction.
    The median is defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17577_02_007.png)'
  prefs: []
  type: TYPE_IMG
- en: This assumes that *X* is ordered by value in ascending or descending direction.
    Then, the value that lies in the middle, just at ![](img/B17577_02_008.png), is
    the median. The median is the 50^(th) **percentile**, which means that it is higher
    than exactly half or 50% of the points in *X*. Other important percentiles are
    the 25^(th) and the 75^(th), which are also the first **quartile** and the third
    quartile. The difference between these two is called the **interquartile range**.
  prefs: []
  type: TYPE_NORMAL
- en: These are the most common descriptors, but not the only ones even by a long
    stretch. We won't go into much more detail here, but we'll see a few more descriptors
    later.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get our hands dirty with some code!
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll import datetime, pandas, matplotlib, and seaborn to use them later.
    Matplotlib and seaborn are libraries for plotting. Here it goes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Then we'll read in a CSV file. The data is from the **Our World in Data** (**OWID**)
    website, a collection of statistics and articles about the state of the world,
    maintained by Max Roser, research director in economics at the University of Oxford.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can load local files or files on the internet. In this case, we''ll load
    a dataset from GitHub. This is a dataset of air pollutants over time. In pandas
    you can pass the URL directly into the `read_csv()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: If you have problems downloading the file, you can download it manually from
    the book's GitHub repository from the `chapter2` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we know the size of the dataset (331 rows) and the column names. The column
    names are a bit long, let''s simplify it by renaming them and then carry on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The minimum and the maximum year are these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: pandas brings lots of methods to explore and discover your dataset – `min()`,
    `max()`, `mean()`, `count()`, and `describe()` can all come in very handy.
  prefs: []
  type: TYPE_NORMAL
- en: City, Smoke, and SPM are much clearer names for the variables. We've learned
    that our dataset covers two cities, London and Delhi, and over a time period between
    1700 and 2016\.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll convert our Year column from `int64` to `datetime`. This will help with
    plotting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Year is now a `datetime64[ns]` type. It's a `datetime` of 64 bits. Each value
    describes a nanosecond, the default unit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check for missing values and get descriptive summary statistics of columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The Smoke variable has 9% missing values. For now, we can just focus on the
    SPM variable, which doesn't have any missing values.
  prefs: []
  type: TYPE_NORMAL
- en: The pandas `describe()` method gives us counts of non-null values, mean and
    standard deviation, 25th, 50th, and 75th percentiles, and the range as the minimum
    and maximum.
  prefs: []
  type: TYPE_NORMAL
- en: A **histogram**, first introduced by Karl Pearson, is a count of values within
    a series of ranges called bins (or buckets). The variable is first divided into
    a series of intervals, and then all points that fall into each interval are counted
    (bin counts). We can present these counts visually as a barplot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s plot a histogram of the SPM variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the plot we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![pollution_hist.png](img/B17577_02_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: Histogram of the SPM variable'
  prefs: []
  type: TYPE_NORMAL
- en: A histogram can help if you have continuous measurements and want to understand
    the distribution of values. Further, a histogram can indicate if there are outliers.
  prefs: []
  type: TYPE_NORMAL
- en: This closes the first part of our TSA. We'll come back to our air pollution
    dataset later.
  prefs: []
  type: TYPE_NORMAL
- en: Uncovering relationships between variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we are not dealing with a univariate time-series where there's only a single
    variable, the relationship between the variables needs to be investigated. This
    includes the direction and rough size of any correlations. This is important to
    avoid feature leakage and collinearity.
  prefs: []
  type: TYPE_NORMAL
- en: '**Feature leakage** is when a variable unintentionally gives away the target.
    For example, the variable named `amount_paid` would give away the label `has_paid.`
    A more complex example would be if we were analyzing data for an online supermarket,
    and our dataset consisted of customer variables such as age, number of purchases
    in the past, length of visit, and finally the contents of their cart. What we
    want to predict, our target, is the result of their buying decision as either
    abandoned (when they canceled their purchase) or paid. We could find that a purchase
    is highly correlated with bags in their cart due to just the simple fact that
    bags are added at the last step. However, concluding we should offer bags to customers
    when they land on our site would probably miss the point, when it''s the length
    of their stay that could be, in fact, the determining variable, and an intervention
    through a widget or customer service agent might be much more effective.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Collinearity** means that independent variables (features) are correlated.
    The latter case can be problematic in linear models. Therefore, if we carry out
    linear regression and find two variables that are highly correlated between themselves,
    we should remove one of them or use dimensionality reduction techniques such as
    Principal Component Analysis (PCA).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Pearson correlation** coefficient was developed by Karl Pearson, whom
    we''ve discussed in the previous chapter, and named in his honor to distinguish
    it from other correlation coefficients. The Pearson correlation coefficient between
    two variables *X* and *Y* is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17577_02_009.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/B17577_02_010.png) is the covariance between the two variables defined
    as the expected value (the mean) between the differences of each point to the
    variable mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17577_02_011.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/B17577_02_012.png) is the standard deviation of the variable *X*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Expanded, the formula looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17577_02_013.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There are three types of correlation: positive, negative, and no correlation.
    Positive correlation means that as one variable increases the other does as well.
    In the case of the Pearson correlation coefficient, the increase of one variable
    to the other should be linear.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we looked at a plot of global life expectancy from 1800 onward, we''d see
    an increase of years lived with the time axis. You can see the plot of global
    life expectancy based on data on OWID:'
  prefs: []
  type: TYPE_NORMAL
- en: '![life_expectancy.png](img/B17577_02_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.4: Life expectancy from 1800 to today'
  prefs: []
  type: TYPE_NORMAL
- en: We can see how life expectancy has been increasing steadily since the end of
    the 19^(th) century until today.
  prefs: []
  type: TYPE_NORMAL
- en: This plot is called a **run chart** or temporal **line chart**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to calculate the Pearson correlation, we can use a function from SciPy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Here's the Pearson correlation and the p-value that indicates significance (the
    lower, the more significant)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We see a very strong positive correlation of time with life expectancy, 0.94,
    at very high significance (the second number in the return). You can find more
    details about the dataset on the OWID website.
  prefs: []
  type: TYPE_NORMAL
- en: 'Conversely, we would see a negative correlation of time with child mortality
    – as the year increases, child mortality decreases. This plot shows the child
    mortality per 1,000 children on data taken from OWID:'
  prefs: []
  type: TYPE_NORMAL
- en: '![child_mortality.png](img/B17577_02_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.5: Child mortality from 1800 to today in the UK, France, and the USA'
  prefs: []
  type: TYPE_NORMAL
- en: In this plot, we can see that in all three countries child mortality has been
    decreasing since the start of the 19^(th) century until today.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of the United States, we'll find a negative correlation of -0.95
    between child mortality and time.
  prefs: []
  type: TYPE_NORMAL
- en: We can also compare the countries to each other. We can calculate correlations
    between each feature. In this case, each feature contains the values for the three
    countries.
  prefs: []
  type: TYPE_NORMAL
- en: 'This gives a **correlation matrix** of 3x3, which we can visualize as a heatmap:'
  prefs: []
  type: TYPE_NORMAL
- en: '![correlation_heatmap.png](img/B17577_02_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.6: Correlation heatmap of child mortality between the UK, France,
    and the USA'
  prefs: []
  type: TYPE_NORMAL
- en: In this correlation heatmap, we can see that countries are highly correlated
    (for example, a correlation of 0.78 between France and the United Kingdom).
  prefs: []
  type: TYPE_NORMAL
- en: The diagonal of the correlation matrix is always 1.0, and the matrix is symmetrical
    across the diagonal. Therefore, sometimes we only show the lower triangle below
    the diagonal (or sometimes the upper triangle). We can see that child mortality
    in the United Kingdom is more similar to that of the United States than that of
    France.
  prefs: []
  type: TYPE_NORMAL
- en: Does this mean that the UK went through a similar development as the United
    States? These statistics and visualizations can often generate questions to answer,
    or hypotheses that we can test.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned before, the full notebooks for the different datasets are available
    on GitHub, however, here''s the snippet for the heatmap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The correlation coefficient struggles with cases where the increases are non-linear
    or non-continuous, or (because of the squared term) when there are outliers. For
    example, if we looked at air pollution from the 1700s onward, we'd see a steep
    increase in air pollutants from coal and – with the introduction of the steam
    engine – a decrease in pollutants.
  prefs: []
  type: TYPE_NORMAL
- en: A **scatter plot** can be used for showing and comparing numeric values. It
    plots values of two variables against each other. Usually, the variables are numerical
    – otherwise, we'd call this a table. Scatter plots can be crowded in certain areas,
    and therefore are deceptive if this can't be appreciated visually. Adding jitter
    and transparency can help to some degree, however, we can combine a scatter plot
    with the histograms of the variables we are plotting against each other, so we
    can see how many points on one or the other variable are being displayed. Scatter
    plots often have a best-fit line superimposed in order to visualize how one variable
    is the function of another variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of how to plot a scatter plot with marginal histograms of
    the two variables in the pollution dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the resulting plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Machine-Learning%20for%20Time-Series%20with%20Python/spm_scatter.png](img/B17577_02_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.7: Scatter plot with marginal histograms of Smoke against SPM'
  prefs: []
  type: TYPE_NORMAL
- en: In the scatter plot, we can see that the two variables are extremely similar
    – the values are all on the diagonal. The correlation between these two variables
    is perfect, 1.0, which means that they are in fact identical.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve seen the dataset of **Suspended Particulate Matter** (**SPM**) before.
    Let''s plot SPM over time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Machine-Learning%20for%20Time-Series%20with%20Python/spm_1700_to_today.png](img/B17577_02_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.8: Suspended particle matter from the 1700s to today'
  prefs: []
  type: TYPE_NORMAL
- en: We can see in the plot that the air quality (measured as suspended particle
    matter) in London was getting worse until around 1880 (presumably because of heating
    materials such as wood and coal), however, has since been improving.
  prefs: []
  type: TYPE_NORMAL
- en: We find a correlation coefficient of -0.36 with high significance. The steep
    decline of pollutants from 1880 onward dominates over the 180 years of slow growth.
    If we looked separately at the time from 1700 to 1880 and from 1880 to the present,
    we'd find 0.97 and -0.97 respectively, examples of very strong correlation and
    very strong anti-correlation.
  prefs: []
  type: TYPE_NORMAL
- en: The **Spearman rank correlation** can handle outliers and non-linear relationships
    much better than the Pearson correlation coefficient – although it can't handle
    non-continuous cases like the one above. The Spearman correlation is the Pearson
    correlation, only applied on ranks of variables' values instead of the variables'
    values directly. The Spearman correlation of the time-series for air pollution
    is -0.19, and for the two time periods before and after 1880 we get 0.99 and -0.99,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of the Spearman correlation coefficient, the numerical differences
    are ignored – what counts is the order of the points. In this case, the order
    of the points within the two time periods aligns nearly perfectly.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll talk about trend and seasonality.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying trend and seasonality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Trend, seasonality, and cyclic variations are the most important characteristics
    of time-series. A **trend** is the presence of a long-term increase or decrease
    in the sequence. **Seasonality** is a variation that occurs at specific regular
    intervals of less than a year. Seasonality can occur on different time spans such
    as daily, weekly, monthly, or yearly. Finally, **cyclic variations** are rises
    and falls that are not of a fixed frequency.
  prefs: []
  type: TYPE_NORMAL
- en: An important characteristic of time-series is **stationarity**. This refers
    to a property of time-series not to change distribution over time, or in other
    words, that the process that produces the time-series doesn't change with time.
    Time-Series that don't change over time are called **stationary** (or **stationary
    processes**). Many models or measures assume stationarity and might not work properly
    if the data is not stationary. Therefore, with these algorithms, the time-series
    should be decomposed first into the main signal, and then the seasonal and trend
    components. In this decomposition, we would subtract the trend and seasonal components
    from the original time-series.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we''ll first go through an example of how to estimate trend
    and seasonality using curve fitting. Then, we''ll look at other tools that can
    help discover trends, seasonality, and cyclic variations. These include statistics
    such as autocorrelation and the augmented Dickey–Fuller test, and visualizations
    such as the autocorrelation plot (also: lag plot) and the periodogram.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with a hopefully clear example of how seasonality and trend can
    be estimated in just a few lines of Python. For this, we'll come back to the GISS
    Surface Temperature Analysis dataset released by NASA. We'll load the dataset,
    and we'll do curve fitting, which comes straight out of the box in NumPy.
  prefs: []
  type: TYPE_NORMAL
- en: We'll download the dataset from Datahub ([https://datahub.io/core/global-temp](https://datahub.io/core/global-temp))
    or you can find it from the book's GitHub repository (in the `chapter2` folder).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can load it up and pivot it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can use NumPy''s polyfit functionality. It fits a polynomial of the
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17577_02_014.png)'
  prefs: []
  type: TYPE_IMG
- en: In this formula, *k* is the degree of the polynomial and *b* is the coefficients
    we are trying to find.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is just a function in NumPy to fit the coefficients. We can use the same
    function to fit seasonal variation and trend. Since trend can dominate over seasonality,
    before estimating seasonality, we remove the trend:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Let's plot seasonality and trend on top of our global temperature increases!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the graph that we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![temperatures_trend_seasonality.png](img/B17577_02_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.9: Temperature change from the late 19^(th) century to today'
  prefs: []
  type: TYPE_NORMAL
- en: This was to show that you can use plug-in functionality in NumPy for curve fitting
    in order to find both trend and seasonality. If you want to experiment further,
    you can play with the degree of the polynomial or with the seasonality component
    to see if you can get a better fit, or find another seasonality component. We
    could have used functionality from other libraries such as `seasonal.seasonal_decompose()`
    in `statsmodels`, or Facebook's Prophet, which decomposes using Fourier coefficients
    for the seasonal components.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've seen how to estimate seasonality and trend, let's move on to
    other statistics and visualizations. Continuing with the pollution dataset, and
    picking up the EEG dataset we saw in *Chapter 1*, we'll show practically in Python
    how to get these statistics and plots, and how to identify trend and seasonality.
  prefs: []
  type: TYPE_NORMAL
- en: '**Autocorrelation** is the correlation of a signal with a lagged version of
    itself. The autocorrelation plot draws the autocorrelation as a function of lag.
    The autocorrelation plot can help find repeating patterns, and is often used in
    signal processing. The autocorrelation can help spot a periodic signal. Let''s
    plot the autocorrelation of the pollution data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the plot that we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![autocorrelation.png](img/B17577_02_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.10: Autocorrelaton plot of pollution in London'
  prefs: []
  type: TYPE_NORMAL
- en: We can see high autocorrelations with a lag of only a few years. There is a
    negative autocorrelation at around 100 years, after which point the autocorrelation
    stays around 0.
  prefs: []
  type: TYPE_NORMAL
- en: The plot of SPM clearly shows that air pollution is not a stationary process,
    since the autocorrelation is not flat. You can also compare the run of pollution
    that shows there's a **trend**, and therefore the mean also changes – another
    indication that the series is not stationary.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also test this statistically. A test for stationarity is the augmented
    Dickey–Fuller test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The second return value is the p-value that gives the significance or the probability
    of obtaining test results at least as extreme as the observation given the null
    hypothesis. With p-values below 5% or 0.05 we would typically reject the null
    hypothesis, and we could assume that our time-series is stationary. In our case,
    we can't assume that the series is stationary.
  prefs: []
  type: TYPE_NORMAL
- en: We saw the graph of **electroencephalography** (**EEG**) signals in *Chapter
    1*, *Introduction to Time-Series with Python*, and we mentioned that EEG signals
    show brain waves at several frequency ranges.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can visualize this nicely. Let''s go through it step by step in Python.
    We first need to do a few imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'OpenML is a project that provides benchmark datasets and a website for comparison
    of machine learning algorithms. The scikit-learn library provides an interface
    to OpenML that allows us to fetch data from OpenML. The whole measurement spans
    117 seconds. So we need to set this up correctly as an index in pandas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We can slice our dataset directly. Please note that the `DatetimeIndex` is
    anchored in 1970, but we can ignore this safely here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the slice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This slicing avoids an artifact, a strong spike, occurring at around 1:20.
  prefs: []
  type: TYPE_NORMAL
- en: 'The graph we saw in *Chapter 1*, we can plot as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the graph again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Machine-Learning%20for%20Time-Series%20with%20Python/voltage_over_time.png](img/B17577_02_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.11: Voltage over time in an EEG signal'
  prefs: []
  type: TYPE_NORMAL
- en: This is the plot of the EEG signal over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also resample the data to look at the series more coarsely, with less
    resolution, for example like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the graph with three subplots we get from resampling to frequencies
    of 1 second, 2 seconds, and 5 seconds, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '![eeg_resampled.png](img/B17577_02_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.12: Resampled EEG signals'
  prefs: []
  type: TYPE_NORMAL
- en: Each of the resampled signals in the plot could be more or less useful for analysis
    depending on the application. For high-frequency analysis, we shouldn't resample
    at all, while if we are trying to remove as much noise as possible, we should
    resample to a more coarse time resolution.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can look at cyclic activity on a plot of spectral density. We can do this
    by applying a Fourier transform. Here, we go with the Welch method, which averages
    over time before applying the discrete Fourier transform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The spectral density plot, the **periodogram**, looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![spectral_eeg.png](img/B17577_02_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.13: Periodogram of the EEG signals'
  prefs: []
  type: TYPE_NORMAL
- en: The information in this plot is like the autocorrelation plot that we drew for
    pollution, however, it gives us information about how prominent certain frequencies
    are. In this case we see that low frequencies are particularly powerful. In other
    words, the signal shows a slow oscillation.
  prefs: []
  type: TYPE_NORMAL
- en: This brings the chapter to an end. Let's summarize what we've covered.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced TSA as the process of extracting summary and
    other statistical information from time-series. We broke this process down into
    understanding the variables, uncovering relationships between variables, and identifying
    trend and seasonality.
  prefs: []
  type: TYPE_NORMAL
- en: We introduced datetime and pandas, the libraries *sine qua non* in TSA, and
    their functionalities for time-series; for example, resampling. Throughout the
    chapter, we listed and defined many summary statistics including mean, standard
    deviation, median, SE, confidence interval, Pearson correlation, and covariance.
  prefs: []
  type: TYPE_NORMAL
- en: We also talked about the concepts of seasonality, cyclic variation, and stationarity.
    We discussed why stationarity is important, and how to test for stationarity.
  prefs: []
  type: TYPE_NORMAL
- en: We also showed plotting functionality with Matplotlib and Seaborn, and how to
    generate different plots such as run charts, temporal line charts, correlation
    heatmaps, histograms, scatter plots, autocorrelation plots, and periodograms.
    In the practical example, we used an autocorrelation plot, which shows the correlation
    between different time steps, and the periodogram, which visualizes the power
    spectral density.
  prefs: []
  type: TYPE_NORMAL
