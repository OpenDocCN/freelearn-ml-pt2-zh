<html><head></head><body>
    <section>
      <header class="header-title chapter-title">
                    Anomaly Detection – Finding Outliers in Data
                </header>
      <article>
        <p class="mce-root">Detecting anomalies in data is a recurring theme in machine learning. In <a href="https://cdp.packtpub.com/hands_on_machine_learning_with_scikit_learn/wp-admin/post.php?post=32&amp;action=edit">Chapter 10</a><a href="https://cdp.packtpub.com/hands_on_machine_learning_with_scikit_learn/wp-admin/post.php?post=32&amp;action=edit">,</a><em>Imbalanced Learning – Not Even 1% Win the Lottery</em>, we learned how to spot these interesting minorities in our data. Back then, the data was labeled and the classification algorithms from the previous chapters were apt for the problem. Aside from <strong>labeled anomaly detection</strong> problems, there are cases where data is unlabeled.</p>
        <p class="mce-root">In this chapter, we are going to learn how to identify outliers in our data, even when no labels are provided. We will use three different algorithms and we will learn about the two branches of <strong>unlabeled anomaly detection</strong>. Here are the topics that will be covered in this chapter:</p>
        <ul>
          <li>Unlabeled anomaly detection</li>
          <li>Detecting anomalies using basic statistics</li>
          <li>Detecting outliers using <kbd>EllipticEnvelope</kbd></li>
          <li>Outlier and novelty detection using <strong>Local Outlier Factor</strong> (<strong>LOF</strong>)</li>
          <li>Detecting outliers using isolation forest</li>
        </ul>
        <h1 id="uuid-c826547d-55f4-4e89-a8be-f5b5bb3573a2">Unlabeled anomaly detection</h1>
        <p>In this chapter, we will start with some unlabeled data and we will need to spot the anomalous samples in it. We may be given inliers only, and we want to learn what normal data looks likefrom them. Then, after fitting a model on our inliers, we are given new data and need to spot any outliers that diverge from the data seen so far. These kinds of problems are referred to as <strong>novelty detectio</strong><strong>n</strong>. On the other hand, if we fit our model on a dataset that consists of a combination of inliers and outliers, then this problem is referred to as an <strong>outlier detection</strong> problem. </p>
        <p>Like any other unlabeled algorithm, the <kbd>fit</kbd> method ignores any labels given. This method's interface allows you to pass in both <em>x</em> and <em>y</em>, for the sake of consistency, but <em>y</em> is simply ignored. In cases of novelty detection, it is logical to firstuse the<kbd>fit</kbd>method on a dataset that includes no outliers, and then use the algorithm's<kbd>predict</kbd>method later on for data that includes both inliers and outliers. Conversely, for outlier detection problems, it is common to apply your <kbd>fit</kbd> method and predict all at once with the <kbd>fit_predict</kbd> method.</p>
        <p>Before using any of our algorithms, we need to create a sample dataset to be used throughout this chapter. Our data will include 1,000 samples, with 98% of them coming from certain distributions and the remaining 2% coming from different distributions. In the next section, we are going to see how to create this sample data in detail. </p>
        <h2 id="uuid-0b28e419-e446-4269-afc3-c3b6300aec78">Generating sample data</h2>
        <p>The <kbd>make_classification</kbd> function allows us to specify the number of samples, as well as the number of features. We can limit the number of informative features and make some features redundant—that is, dependent on the informative features. We can also make some features copies of any of the informative or redundant features. In our current use case, we will make sure that all our features are informative since we are going to limit ourselves to two features only. Since the <kbd>make_classification</kbd> function is meant to produce data for classification problems, it returns both <em>x</em> and <em>y</em>.</p>
        <p>We will ignore <em>y</em> when building our models and only use it for evaluation later on. We will make sure each class comes from two different distributions by setting <kbd>n_clusters_per_class</kbd> to <kbd>2</kbd>. We will keep the two features to the same scale by setting <kbd>scale</kbd> to a single value. We will also make sure the data is randomly shuffled (<kbd>shuffle=True</kbd>) and that no samples from one class are labeled as members of the other class (<kbd>flip_y=0</kbd>). Finally, we will set <kbd>random_state</kbd> to <kbd>0</kbd> to make sure we get the exact same random data when running the following code on our computer:</p>
        <pre>from sklearn.datasets import make_classification<br/><br/>x, y = make_classification(<br/>    n_samples=1000, n_features=2, n_informative=2, n_redundant=0, n_repeated=0, <br/>    n_classes=2, n_clusters_per_class=2, weights=[0.98, ], class_sep=0.5, <br/>    scale=1.0, shuffle=True, flip_y=0, random_state=0<br/>)</pre>
        <p>Now that the sample data is ready, it is time to think of ways to detect the outliers in it. </p>
        <h1 id="uuid-0658501b-a99c-46ff-8cfe-2fbdf8927795">Detecting anomalies using basic statistics</h1>
        <p>Rather than jumping straight into the available algorithms in scikit-learn, let's start by thinking about ways to detect the anomalous samples. Imagine measuring the traffic to your website every hour, which gives you the following numbers:</p>
        <pre>hourly_traffic = [<br/>    120, 123, 124, 119, 196, <br/>    121, 118, 117, 500, 132<br/>]</pre>
        <p>Looking at these numbers, <kbd>500</kbd> sounds quite high compared to the others. Formally speaking, if the hourly traffic data is assumed to be normally distributed, then <kbd>500</kbd> is further away from its mean or expected value. We can measure this by calculating the mean of these numbers and then checking the numbers that are more than 2 or 3 standard deviations away from the mean. Similarly, we can calculate a high quantile and check which numbers are above it. Here, we find the values above the 95<sup>th</sup> percentile:</p>
        <pre>pd.Series(hourly_traffic) &gt; pd.Series(hourly_traffic).quantile(0.95)</pre>
        <p>This code will give an array of the <kbd>False</kbd> values, except for the penultimate value, which is the one corresponding to <kbd>500</kbd>. Before printing out the results, let's put the preceding code in the form of an estimator with its <kbd>fit</kbd> and <kbd>predict</kbd> methods. The <kbd>fit</kbd> method calculates the threshold and saves it, and the <kbd>predict</kbd> method compares the new data to the saved threshold. I also added a <kbd>fit_predict</kbd> method that carries out these two operations in sequence. Here is the code for the estimator:</p>
        <pre>class PercentileDetection:<br/><br/>    def __init__(self, percentile=0.9):<br/>        self.percentile = percentile<br/><br/>    def fit(self, x, y=None):<br/>        self.threshold = pd.Series(x).quantile(self.percentile)<br/><br/>    def predict(self, x, y=None):<br/>        return (pd.Series(x) &gt; self.threshold).values<br/><br/>    def fit_predict(self, x, y=None):<br/>        self.fit(x)<br/>        return self.predict(x) </pre>
        <p>We can now use our newly created estimator. In the following code snippet, we use the 95<sup>th</sup> percentile for our estimator. We then put the resulting predictions alongside the original data into a data frame. Finally, I added some styling logic to mark the rows with outliers in bold:</p>
        <pre>outlierd = PercentileDetection(percentile=0.95)<br/>pd.DataFrame(<br/>    {<br/>        'hourly_traffic': hourly_traffic,<br/>        'is_outlier': outlierd.fit_predict(hourly_traffic)<br/>    }<br/>).style.apply(<br/>    lambda row: ['font-weight: bold'] * len(row) <br/>        if row['is_outlier'] == True <br/>        else ['font-weight: normal'] * len(row),<br/>    axis=1<br/>)</pre>
        <p>Here is the resulting data frame:</p>
        <p class="CDPAlignCenter CDPAlign">
          <img src="assets/252fef3a-a4df-40de-85fb-cf0a6cf8dedc.png" style="width:13.25em;"/>
        </p>
        <p>Can we apply the same logic to the dataset from the previous section? Well, yes, but we need to figure out how to apply it to multi-dimensional data first. </p>
        <h2 id="uuid-078f249e-7e60-4a3e-8878-57fe7577e347">Using percentiles for multi-dimensional data</h2>
        <p>Unlike the <kbd>hourly_traffic</kbd> data, the data we generated using the <kbd>make_classification</kbd> function is multi-dimensional. We have more than one feature to check this time. Obviously, we can check each feature separately. Here is the code for checking the outliers with respect to the first feature:</p>
        <pre>outlierd = PercentileDetection(percentile=0.98)<br/>y_pred = outlierd.fit_predict(x[:,0])</pre>
        <p>We can do the same for the other feature as well:</p>
        <pre>outlierd = PercentileDetection(percentile=0.98)<br/>y_pred = outlierd.fit_predict(x[:,1])</pre>
        <p>Now, we have ended up with two predictions. We can combine them in a way that each sample is marked as an outlier if it is an outlier with respect to any of the two features. In the following code snippet, we will tweak the <kbd>PercentileDetection</kbd><em><strong/></em>estimator to do that:</p>
        <pre>class PercentileDetection:<br/><br/>    def __init__(self, percentile=0.9):<br/>        self.percentile = percentile<br/><br/>    def fit(self, x, y=None):<br/>        self.thresholds = [<br/>            pd.Series(x[:,i]).quantile(self.percentile)<br/>            for i in range(x.shape[1])<br/>        ]<br/><br/>    def predict(self, x, y=None):<br/>        return (x &gt; self.thresholds).max(axis=1)<br/><br/>    def fit_predict(self, x, y=None):<br/>        self.fit(x)<br/>        return self.predict(x)</pre>
        <p>Now, we can use the tweaked estimator as follows:</p>
        <pre>outlierd = PercentileDetection(percentile=0.98)<br/>y_pred = outlierd.fit_predict(x) </pre>
        <p>We can also use the labels we ignored earlier to calculate the precision and recall of our new estimator. Since we care about the minority class, whose label is <kbd>1</kbd>, we set <kbd>pos_label</kbd> to <kbd>1</kbd> in the following code snippet:</p>
        <pre>from sklearn.metrics import precision_score, recall_score<br/><br/>print(<br/>    'Precision: {:.02%}, Recall: {:.02%} [Percentile Detection]'.format(<br/>        precision_score(y, y_pred, pos_label=1),<br/>        recall_score(y, y_pred, pos_label=1),<br/>    )<br/>)</pre>
        <p>This gives a precision of <kbd>4%</kbd> and a recall of <kbd>5%</kbd>. Did you expect better results? I did too. Maybe we need to plot our data to understand what might be the problem with our method. Here is the dataset, where each sample is marked according to its label:</p>
        <p class="CDPAlignCenter CDPAlign">
          <img src="assets/c802e490-abac-42b3-a719-e7a2fcbf9e36.png" style="width:29.08em;"/>
        </p>
        <p>Our method checks each point and sees whether it is extreme on one of the two axes. Despite the fact that the outliers are further away from the inliers, there are still inliers that share the same horizontal or vertical position of each point of the outliers. In other words, if you project your points onto any of the two axes, you will not be able to separate the outliers from the inliers anymore. So, we need a way to consider the two axes at once. What if we find the mean point of the two axes—that is, the center of our data—and then draw a circle or an ellipse around it? Then, we can consider any point that falls outside this ellipse an outlier. Would this new strategy help? Luckily, that's what the <kbd>EllipticEnvelope </kbd>algorithm does. </p>
        <h1 id="uuid-5e97449b-947f-4976-b74a-8aabb1b8d37e">Detecting outliers using EllipticEnvelope</h1>
        <div class="packt_quote">"I'm intimidated by the fear of being average."</div>
        <div class="packt_quote CDPAlignRight CDPAlign">– Taylor Swift</div>
        <p>The <kbd>EllipticEnvelope</kbd> algorithm finds the center of the data samples and then draws an ellipsoid around that center. The radii of the ellipsoid in each axis are measured in the <strong>Mahalanobis</strong> distance. You can think of the Mahalanobis distance as a Euclideandistance whose units are the number of standard deviations in each direction. After the ellipsoid is drawn, the points that fall outside it can be considered outliers.</p>
        <div class="packt_infobox">The <strong>multivariate Gaussian distribution</strong> is a key concept of the <kbd>EllipticEnvelope</kbd> algorithm. It's a generalization of the one-dimensional Gaussian distribution. If the Gaussian distribution is defined by single-valued mean and variance, then the multivariate Gaussian distribution is defined by matrices for means and covariances. The multivariate Gaussian distribution is then used to draw an ellipsoid that defines what is normal and what is an outlier.</div>
        <p>Here is how we use the <kbd>EllipticEnvelope</kbd> algorithm to detect the data outliers, using the algorithm's default settings. Keep in mind that the <kbd>predict</kbd> methods for all the outlier detection algorithms in this chapter return <kbd>-1</kbd> for outliers and <kbd>1</kbd> for inliers:</p>
        <pre>from sklearn.covariance import EllipticEnvelope<br/><br/>ee = EllipticEnvelope(random_state=0)<br/>y_pred = ee.fit_predict(x) == -1</pre>
        <p>We can calculate the precision and the recall scores for the predictions using the exact same code from the previous section:</p>
        <pre>from sklearn.metrics import precision_score, recall_score<br/><br/>print(<br/>    'Precision: {:.02%}, Recall: {:.02%} [EllipticEnvelope]'.format(<br/>        precision_score(y, y_pred, pos_label=1),<br/> recall_score(y, y_pred, pos_label=1),<br/>    )<br/>)</pre>
        <p>This time, we get a precision of <kbd>9%</kbd> and a recall of <kbd>45%</kbd>. That's already better than the previous scores, but can we do better? Well, if you take another look at the data, you will notice that it is non-convex. We already know that the samples in each class come from more than one distribution, and so the shape of the points doesn't seem like it would perfectly fit into an ellipse. This means that we should instead use an algorithm that bases its decision on local distances and densities, rather than comparing everything to a fixed centroid. The <strong>Local Outlier Factor</strong> (<strong>LOF</strong>) gives us that feature. If the <strong>k-means</strong><strong>clustering</strong><strong>algorithm</strong> of the previous chapter falls into the same group as the elliptic envelope algorithm, then the LOF would be the counterpart of the <strong>DBSCAN</strong> algorithm. </p>
        <h1 id="uuid-e22acb91-6ccd-4c3d-b9d3-2d9e92eed504">Outlier and novelty detection using LOF</h1>
        <div class="packt_quote">"Madness is rare in individuals – but in groups, parties, nations, and ages, it is the rule."</div>
        <div class="packt_quote CDPAlignRight CDPAlign">– Friedrich Nietzsche</div>
        <p>LOF takes an opposite approach to Nietzsche's—it compares the density of a sample to the local densities of its neighbors. A sample existing in a low-density area compared to its neighbors is considered an outlier. Like any other neighbor-based algorithms, we have parameters to specify the number of neighbors to consider (<kbd>n_neighbors</kbd>) and the distance metric to use to find the neighbors (<kbd>metric</kbd> and <kbd>p</kbd>). By default, the Euclidean distance is used—that is, <kbd>metric='minkowski'</kbd> and <kbd>p=2</kbd>. You can refer to <a href="https://cdp.packtpub.com/hands_on_machine_learning_with_scikit_learn/wp-admin/post.php?post=28&amp;action=edit">Chapter 5</a>, <em>Image Processing with Nearest Neighbors</em>, for more information about the available distance metrics. Here is how we use<kbd>LocalOutlierFactor</kbd> for outlier detection, using 50 neighbors and its default distance metric:</p>
        <pre>from sklearn.neighbors import LocalOutlierFactor<br/><br/>lof = LocalOutlierFactor(n_neighbors=50)<br/>y_pred = lof.fit_predict(x) == -1</pre>
        <p>The precision and recall scores have now further improved the event. We got a precision value of <kbd>26%</kbd> and a recall value of <kbd>65%</kbd>.</p>
        <p>Just like the classifiers, which have the <kbd>predict</kbd> method as well as <kbd>predict_proba</kbd>, outlier detection algorithms not only give us binary predictions, but can also tell us how confident they are that a sample is an outlier. Once the LOF algorithm is fitted, it stores its outlier factor scores in <kbd>negative_outlier_factor_</kbd>. A sample is more likely to be an outlier if the score is closer to <kbd>-1</kbd>. So, we can use this score and set its bottom 1%, 2%, or 10% values as outliers, and consider the rest inliers. Here is a comparison for the different performance metrics at each of the aforementioned thresholds:</p>
        <pre>from sklearn.metrics import precision_score, recall_score<br/><br/>lof = LocalOutlierFactor(n_neighbors=50)<br/>lof.fit(x)<br/><br/>for quantile in [0.01, 0.02, 0.1]:<br/><br/>    y_pred = lof.negative_outlier_factor_ &lt; np.quantile(<br/>        lof.negative_outlier_factor_, quantile<br/>    ) <br/><br/>    print(<br/>        'LOF: Precision: {:.02%}, Recall: {:.02%} [Quantile={:.0%}]'.format(<br/>            precision_score(y, y_pred, pos_label=1),<br/>            recall_score(y, y_pred, pos_label=1),<br/>            quantile<br/>        )<br/>    )</pre>
        <p>Here are the different precision and recall scores:</p>
        <pre># LOF: Precision: 80.00%, Recall: 40.00% [Quantile=1%]
# LOF: Precision: 50.00%, Recall: 50.00% [Quantile=2%]
# LOF: Precision: 14.00%, Recall: 70.00% [Quantile=10%]</pre>
        <p>As in the case with the classifiers' probabilities, there is a trade-off here between the precision and recall scores for the different thresholds. This is how you can fine-tune your predictions to suit your needs. You can also use <kbd>negative_outlier_factor_</kbd> to plot the <strong>Receiver Operating Characteristic</strong> (<strong>ROC</strong>) or <strong>Precision-Recall</strong> (<strong>PR</strong>) curves if the true labels are known. </p>
        <p>Aside from its use for outlier detection, theLOF<em><strong/></em>algorithm can also be used for novelty detection. </p>
        <h2 id="uuid-0838d795-7d1f-4a37-b817-7f3f4bb05962">Novelty detection using LOF</h2>
        <p>When used for outlier detection, the algorithm has to be fitted on the dataset with both its inliers and outliers. In the case of novelty detection, we are expected to fit the algorithm on the inliers only, and then predict on a contaminated dataset later on. Furthermore, to be used for novelty detection, you have <kbd>novelty=True</kbd> during the algorithm's initialization. Here, we remove the outliers from our data and use the resulting subsample, <kbd>x_inliers</kbd>, with the <kbd>fit</kbd> function. Then, we predict for the original dataset as normal:</p>
        <pre>from sklearn.neighbors import LocalOutlierFactor<br/><br/>x_inliers = x[y==0]<br/><br/>lof = LocalOutlierFactor(n_neighbors=50, novelty=True)<br/>lof.fit(x_inliers)<br/>y_pred = lof.predict(x) == -1</pre>
        <p>The resulting precision (<kbd>26.53%</kbd>) and recall (<kbd>65.00%</kbd>) values did not vary much compared to when we used the algorithm for outlier detection. In the end, the choice in terms of novelty detection versus the outlier detection approach is a tactical one. It depends on the available data when the model is built and whether it contains outliers. </p>
        <p>You probably already know by now that I like using the ensemble methods, and so it is hard for me to end this chapter without presenting an ensemble algorithm for outlier detection. In the next section, we are going to look at the <strong>isola</strong><strong>tion</strong><strong>forest</strong> algorithm.</p>
        <h1 id="uuid-65eb00a5-b29f-495c-8487-bfad2c78521f">Detecting outliers using isolation forest</h1>
        <p>In previous approaches, we started by defining what normal is, and then considered anything that doesn't conform to this as outliers. The isolation forest algorithm follows a different approach. Since the outliers are few and different, they are easier to isolate from the rest. So, when building a forest of random trees, a sample that ends in leaf nodes early in a tree—that is, it did not need a lot of branching effort to be isolated—is more likely to be an outlier.</p>
        <p>As a tree-based ensemble, this algorithm shares many hyperparameters with its counterparts, such as the number of random trees to build (<kbd>n_estimators</kbd>), the ratio of samples to use when building each tree (<kbd>max_samples</kbd>), the ratio of features to consider when building each tree (<kbd>max_features</kbd>), and whether to sample with a replacement or not (<kbd>bootstrap</kbd>). You can also build the trees in parallel using all the available CPUs on your machine by setting <kbd>n_jobs</kbd> to <kbd>-1</kbd>. Here, we will build an isolation forest algorithm of 200 trees, then use it to predict the outliers in our dataset. Like all the other algorithms in this chapter, a prediction of <kbd>-1</kbd> means that the sample is seen as an outlier:</p>
        <pre>from sklearn.ensemble import IsolationForest<br/><br/>iforest = IsolationForest(n_estimators=200, n_jobs=-1, random_state=10)<br/>y_pred = iforest.fit_predict(x) == -1</pre>
        <p>The resulting precision (<kbd>6.5%</kbd>) and recall (<kbd>60.0%</kbd>) values are not as good as the previous approaches. Clearly, LOF is the most suitable algorithm for the data we have at hand here. We were able to compare the three algorithms since the original labels were available to us. In reality, labels are usually unavailable, and it is hard to decide which algorithm to use. The field of unlabeled anomaly detection evaluation is actively being researched, and I hope to see scikit-learn implement reliable evaluation metrics once they are available in the future.</p>
        <div class="packt_infobox">In the case of supervised learning, you can use true labels to evaluate models using the PR curves. When it comes to unlabeled data, recent researchers are trying to tailor evaluation criteria, such as the <strong>Excess-Mass</strong> (<strong>EM</strong>) and <strong>Mass-Volume</strong> (<strong>MV</strong>) curves.</div>
        <h1 id="uuid-b40cc953-b90c-424d-8fb5-f882a31770da">Summary</h1>
        <p>So far in this book, we have used supervised learning algorithms to spot anomalous samples. This chapter offered additional solutions when no labels are provided. The solutions explained here stem from different fields of machine learning, such as statistical learning, nearest-neighbor, and tree-based ensembles. Each one of the three tools explained here can excel, but also have disadvantages. We also learned that evaluating machine learning algorithms when no labels are provided is tricky.  </p>
        <p>This chapter will deal with unlabeled data. In the previous chapter, we learned how to cluster data, and then we learned how to detect the outliers in it here. We still have one more unsupervised learning topic to discuss in this book, though. In the next chapter, we will cover an important topic relating to e-commerce—recommendation engines. Since it is the last chapter of this book, I'd alsolike to go through the possible approaches to machine learning model deployment. We will learn how to save and load our models and how to deploy them on <strong>Application Programming Interfaces</strong> (<strong>APIs</strong>).</p>
      </article>
    </section>
  </body></html>