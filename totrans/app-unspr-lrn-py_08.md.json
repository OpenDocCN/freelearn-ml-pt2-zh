["```py\n    import matplotlib.pyplot as plt\n    import mlxtend.frequent_patterns\n    import mlxtend.preprocessing\n    import numpy\n    import pandas\n    ```", "```py\n    example = [\n        ['milk', 'bread', 'apples', 'cereal', 'jelly', \n         'cookies', 'salad', 'tomatoes'],\n        ['beer', 'milk', 'chips', 'salsa', 'grapes', \n         'wine', 'potatoes', 'eggs', 'carrots'],\n        ['diapers', 'baby formula', 'milk', 'bread', \n         'chicken', 'asparagus', 'cookies'],\n        ['milk', 'cookies', 'chicken', 'asparagus', \n         'broccoli', 'cereal', 'orange juice'],\n        ['steak', 'asparagus', 'broccoli', 'chips', \n         'salsa', 'ketchup', 'potatoes', 'salad'],\n        ['beer', 'salsa', 'asparagus', 'wine', 'cheese', \n         'crackers', 'strawberries', 'cookies'],\n        ['chocolate cake', 'strawberries', 'wine', 'cheese', \n         'beer', 'milk', 'orange juice'],\n        ['chicken', 'peas', 'broccoli', 'milk', 'bread', \n         'eggs', 'potatoes', 'ketchup', 'crackers'],\n        ['eggs', 'bread', 'cheese', 'turkey', 'salad', \n         'tomatoes', 'wine', 'steak', 'carrots'],\n        ['bread', 'milk', 'tomatoes', 'cereal', 'chicken', \n         'turkey', 'chips', 'salsa', 'diapers']\n    ]\n    ```", "```py\n    N = len(example)\n    f_x = sum(['milk' in i for i in example]) # milk\n    f_y = sum(['bread' in i for i in example]) # bread\n    f_x_y = sum([\n        all(w in i for w in ['milk', 'bread']) \n        for i in example\n    ])\n    print(\n        \"N = {}\\n\".format(N) + \n        \"Freq(x) = {}\\n\".format(f_x) + \n        \"Freq(y) = {}\\n\".format(f_y) + \n        \"Freq(x, y) = {}\".format(f_x_y)\n    )\n    ```", "```py\n    support = f_x_y / N\n    print(\"Support = {}\".format(round(support, 4)))\n    ```", "```py\n    confidence = support / (f_x / N)\n    print(\"Confidence = {}\".format(round(confidence, 4)))\n    ```", "```py\n    lift = confidence / (f_y / N)\n    print(\"Lift = {}\".format(round(lift, 4)))\n    ```", "```py\n    leverage = support - ((f_x / N) * (f_y / N))\n    print(\"Leverage = {}\".format(round(leverage, 4)))\n    ```", "```py\n    conviction = (1 - (f_y / N)) / (1 - confidence)\n    print(\"Conviction = {}\".format(round(conviction, 4)))\n    ```", "```py\n    online = pandas.read_excel(\n        io=\"~/Desktop/Online Retail.xlsx\", \n        sheet_name=\"Online Retail\", \n        header=0\n    )\n    ```", "```py\n    online.head(10)\n    ```", "```py\n    online.dtypes\n    ```", "```py\n    print(\n         \"Data dimension (row count, col count): {dim}\"\n         .format(dim=online.shape)\n    )\n    print(\n         \"Count of unique invoice numbers: {cnt}\"\n         .format(cnt=online.InvoiceNo.nunique())\n    )\n    print(\n         \"Count of unique customer ids: {cnt}\"\n         .format(cnt=online.CustomerID.nunique())\n    )\n    ```", "```py\n    Data dimension (row count, col count): (541909, 8)\n    Count of unique invoice numbers: 25900\n    Count of unique customer ids: 4372\n    ```", "```py\n    online['IsCPresent'] = (\n        online['InvoiceNo']\n        .astype(str)\n        .apply(lambda x: 1 if x.find('C') != -1 else 0)\n    )\n    ```", "```py\n    online1 = (\n        online\n        # filter out non-positive quantity values\n        .loc[online[\"Quantity\"] > 0]\n        # remove InvoiceNos starting with C\n        .loc[online['IsCPresent'] != 1]\n        # column filtering\n        .loc[:, [\"InvoiceNo\", \"Description\"]]\n        # dropping all rows with at least one missing value\n        .dropna()\n    )\n    ```", "```py\n    online1.head(10)\n    ```", "```py\n    print(\n        \"Data dimension (row count, col count): {dim}\"\n        .format(dim=online1.shape)\n    )\n    print(\n        \"Count of unique invoice numbers: {cnt}\"\n        .format(cnt=online1.InvoiceNo.nunique())\n    )\n    ```", "```py\n    Data dimension (row count, col count): (530693, 2)\n    Count of unique invoice numbers: 20136\n    ```", "```py\n    invoice_no_list = online1.InvoiceNo.tolist()\n    invoice_no_list = list(set(invoice_no_list))\n    print(\n        \"Length of list of invoice numbers: {ln}\"\n        .format(ln=len(invoice_no_list))\n    )\n    ```", "```py\n    Length of list of invoice numbers: 20136\n    ```", "```py\n    subset_invoice_no_list = invoice_no_list[0:5000]\n    print(\n        \"Length of subset list of invoice numbers: {ln}\"\n        .format(ln=len(subset_invoice_no_list))\n    )\n    ```", "```py\n    Length of subset list of invoice numbers: 5000\n    ```", "```py\n    online1 = online1.loc[online1[\"InvoiceNo\"].isin(subset_invoice_no_list)]\n    ```", "```py\n    online1.head(10)\n    ```", "```py\n    print(\n        \"Data dimension (row count, col count): {dim}\"\n        .format(dim=online1.shape)\n    )\n    print(\n        \"Count of unique invoice numbers: {cnt}\"\n        .format(cnt=online1.InvoiceNo.nunique())\n    )\n    ```", "```py\n    Data dimension (row count, col count): (129815, 2)\n    Count of unique invoice numbers: 5000\n    ```", "```py\n    invoice_item_list = []\n    for num in list(set(online1.InvoiceNo.tolist())):\n        # filter dataset down to one invoice number\n        tmp_df = online1.loc[online1['InvoiceNo'] == num]\n        # extract item descriptions and convert to list\n        tmp_items = tmp_df.Description.tolist()\n        # append list invoice_item_list\n        invoice_item_list.append(tmp_items)\n\n    print(invoice_item_list[1:5])\n    ```", "```py\ndef manual_encoding(ll):\n    # unlist the list of lists input\n    # result is one list with all the elements of the sublists\n    list_dup_unsort_items = [element for sub in ll for element in sub]\n    # two cleaning steps:\n    #     1\\. remove duplicate items, only want one of each item in list\n    #     2\\. sort items in alphabetical order\n    list_nondup_sort_items = sorted(list(set(list_dup_unsort_items)))\n\n    # initialize DataFrame with all elements having False value\n    # name the columns the elements of list_dup_unsort_items\n    manual_df = pandas.DataFrame(\n        False, \n        index=range(len(ll)), \n        columns=list_dup_unsort_items\n    )\n\n    # change False to True if element is in individual transaction list\n    # each row is represents the contains of an individual transaction\n    # (sublist from the original list of lists)\n    for i in range(len(ll)):\n        for j in ll[i]:\n            manual_df.loc[i, j] = True\n\n    # return the True/False DataFrame\n    return manual_df\n```", "```py\n    online_encoder = mlxtend.preprocessing.TransactionEncoder()\n    online_encoder_array = online_encoder.fit_transform(invoice_item_list)\n    print(online_encoder_array)\n    ```", "```py\n    online_encoder_df = pandas.DataFrame(\n        online_encoder_array, \n        columns=online_encoder.columns_\n    )\n    # this is a very big table, so for more \n    # easy viewing only a subset is printed\n    online_encoder_df.loc[\n        4970:4979, \n        online_encoder_df.columns.tolist()[0:8]\n    ]\n    ```", "```py\n    print(\n        \"Data dimension (row count, col count): {dim}\"\n        .format(dim=online_encoder_df.shape)\n    )\n    ```", "```py\n    Data dimension (row count, col count): (5000, 3334)\n    ```", "```py\nL1 = {frequent items}\nFor k = 1 and L1 != empty set do\n    Ck+1 = candidate item sets derived from Lk\n    For each transaction t in the dataset do\n        Increment the count of the candidates in Ck+1 that appear in t\n    Compute the support for the candidates in Ck+1 using the appearance counts\n    Lk+1 = the candidates in Ck+1 meeting the minimum support requirement\n        End\nReturn L = UkLk = all frequent item sets with corresponding support values\n```", "```py\n    mod = mlxtend.frequent_patterns.apriori(online_encoder_df)\n    mod\n    ```", "```py\n    mod_minsupport = mlxtend.frequent_patterns.apriori(\n        online_encoder_df,\n        min_support=0.01\n    )\n    mod_minsupport.loc[0:6]\n    ```", "```py\n    mod_colnames_minsupport = mlxtend.frequent_patterns.apriori(\n        online_encoder_df, \n        min_support=0.01,\n        use_colnames=True\n    )\n    mod_colnames_minsupport.loc[0:6]\n    ```", "```py\n    mod_colnames_minsupport['length'] = (\n        mod_colnames_minsupport['itemsets'].apply(lambda x: len(x))\n    )\n    mod_colnames_minsupport.loc[0:6]\n    ```", "```py\n    mod_colnames_minsupport[\n        mod_colnames_minsupport['itemsets'] == frozenset(\n            {'10 COLOUR SPACEBOY PEN'}\n        )\n    ]\n    ```", "```py\n    mod_colnames_minsupport[\n        (mod_colnames_minsupport['length'] == 2) & \n        (mod_colnames_minsupport['support'] >= 0.02) &\n        (mod_colnames_minsupport['support'] < 0.021)\n    ] \n    ```", "```py\n    mod_colnames_minsupport.hist(\"support\", grid=False, bins=30)\n    plt.title(\"Support\")\n    ```", "```py\n    rules = mlxtend.frequent_patterns.association_rules(\n        mod_colnames_minsupport, \n        metric=\"confidence\",\n        min_threshold=0.6, \n        support_only=False\n    )\n    rules.loc[0:6]\n    ```", "```py\n    print(\"Number of Associations: {}\".format(rules.shape[0]))\n    ```", "```py\n    rules2 = mlxtend.frequent_patterns.association_rules(\n        mod_colnames_minsupport, \n        metric=\"lift\",\n        min_threshold=50, \n        support_only=False\n    )\n    rules2.loc[0:6]\n    ```", "```py\n    print(\"Number of Associations: {}\".format(rules2.shape[0]))\n    ```", "```py\n    rules.plot.scatter(\"support\", \"confidence\", alpha=0.5, marker=\"*\")\n    plt.xlabel(\"Support\")\n    plt.ylabel(\"Confidence\")\n    plt.title(\"Association Rules\")\n    plt.show()\n    ```", "```py\n    rules.hist(\"confidence\", grid=False, bins=30)\n    plt.title(\"Confidence\")\n    ```", "```py\n    rules.hist(\"lift\", grid=False, bins=30)\n    plt.title(\"Lift\")\n    ```", "```py\n    rules.hist(\"leverage\", grid=False, bins=30)\n    plt.title(\"Leverage\")\n    ```", "```py\n    plt.hist(\n        rules[numpy.isfinite(rules['conviction'])].conviction.values, \n        bins = 30\n    )\n    plt.title(\"Conviction\")\n    ```"]